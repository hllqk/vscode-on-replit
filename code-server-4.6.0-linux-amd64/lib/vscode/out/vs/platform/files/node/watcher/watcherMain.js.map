{"version":3,"sources":["out-vscode-reh-web/vs/platform/files/node/watcher/fake","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/decorators.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/errors.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/arrays.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/functional.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/iterator.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/lazy.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/lifecycle.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/linkedList.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/platform.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/process.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/path.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/processes.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/stopwatch.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/event.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/cancellation.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/cache.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/stream.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/buffer.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/strings.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/map.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/normalization.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/types.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/objects.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/uri.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/console.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/marshalling.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/glob.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/node/decoder.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/node/pfs.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/node/extpath.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/errorMessage.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/node/processes.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/instantiation/common/instantiation.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/common/files.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/common/watcher.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/node/watcher/nodejs/nodejsWatcherLib.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/node/watcher/nodejs/nodejsWatcher.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/node/watcher/parcel/parcelWatcher.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/node/watcher/watcher.ts","out-vscode-reh-web/vs/platform/files/node/watcher/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/platform/files/node/watcher/watcherMain.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function createDecorator(mapFn: (fn: Function, key: string) => Function): Function {\n\treturn (target: any, key: string, descriptor: any) => {\n\t\tlet fnKey: string | null = null;\n\t\tlet fn: Function | null = null;\n\n\t\tif (typeof descriptor.value === 'function') {\n\t\t\tfnKey = 'value';\n\t\t\tfn = descriptor.value;\n\t\t} else if (typeof descriptor.get === 'function') {\n\t\t\tfnKey = 'get';\n\t\t\tfn = descriptor.get;\n\t\t}\n\n\t\tif (!fn) {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\n\t\tdescriptor[fnKey!] = mapFn(fn, key);\n\t};\n}\n\nexport function memoize(_target: any, key: string, descriptor: any) {\n\tlet fnKey: string | null = null;\n\tlet fn: Function | null = null;\n\n\tif (typeof descriptor.value === 'function') {\n\t\tfnKey = 'value';\n\t\tfn = descriptor.value;\n\n\t\tif (fn!.length !== 0) {\n\t\t\tconsole.warn('Memoize should only be used in functions with zero parameters');\n\t\t}\n\t} else if (typeof descriptor.get === 'function') {\n\t\tfnKey = 'get';\n\t\tfn = descriptor.get;\n\t}\n\n\tif (!fn) {\n\t\tthrow new Error('not supported');\n\t}\n\n\tconst memoizeKey = `$memoize$${key}`;\n\tdescriptor[fnKey!] = function (...args: any[]) {\n\t\tif (!this.hasOwnProperty(memoizeKey)) {\n\t\t\tObject.defineProperty(this, memoizeKey, {\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: fn!.apply(this, args)\n\t\t\t});\n\t\t}\n\n\t\treturn this[memoizeKey];\n\t};\n}\n\nexport interface IDebounceReducer<T> {\n\t(previousValue: T, ...args: any[]): T;\n}\n\nexport function debounce<T>(delay: number, reducer?: IDebounceReducer<T>, initialValueProvider?: () => T): Function {\n\treturn createDecorator((fn, key) => {\n\t\tconst timerKey = `$debounce$${key}`;\n\t\tconst resultKey = `$debounce$result$${key}`;\n\n\t\treturn function (this: any, ...args: any[]) {\n\t\t\tif (!this[resultKey]) {\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}\n\n\t\t\tclearTimeout(this[timerKey]);\n\n\t\t\tif (reducer) {\n\t\t\t\tthis[resultKey] = reducer(this[resultKey], ...args);\n\t\t\t\targs = [this[resultKey]];\n\t\t\t}\n\n\t\t\tthis[timerKey] = setTimeout(() => {\n\t\t\t\tfn.apply(this, args);\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}, delay);\n\t\t};\n\t});\n}\n\nexport function throttle<T>(delay: number, reducer?: IDebounceReducer<T>, initialValueProvider?: () => T): Function {\n\treturn createDecorator((fn, key) => {\n\t\tconst timerKey = `$throttle$timer$${key}`;\n\t\tconst resultKey = `$throttle$result$${key}`;\n\t\tconst lastRunKey = `$throttle$lastRun$${key}`;\n\t\tconst pendingKey = `$throttle$pending$${key}`;\n\n\t\treturn function (this: any, ...args: any[]) {\n\t\t\tif (!this[resultKey]) {\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}\n\t\t\tif (this[lastRunKey] === null || this[lastRunKey] === undefined) {\n\t\t\t\tthis[lastRunKey] = -Number.MAX_VALUE;\n\t\t\t}\n\n\t\t\tif (reducer) {\n\t\t\t\tthis[resultKey] = reducer(this[resultKey], ...args);\n\t\t\t}\n\n\t\t\tif (this[pendingKey]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextTime = this[lastRunKey] + delay;\n\t\t\tif (nextTime <= Date.now()) {\n\t\t\t\tthis[lastRunKey] = Date.now();\n\t\t\t\tfn.apply(this, [this[resultKey]]);\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t} else {\n\t\t\t\tthis[pendingKey] = true;\n\t\t\t\tthis[timerKey] = setTimeout(() => {\n\t\t\t\t\tthis[pendingKey] = false;\n\t\t\t\t\tthis[lastRunKey] = Date.now();\n\t\t\t\t\tfn.apply(this, [this[resultKey]]);\n\t\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t\t}, nextTime - Date.now());\n\t\t\t}\n\t\t};\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n\treadonly noTelemetry: boolean;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): any;\n\tgetTypeName(): string;\n\tgetFunction(): string;\n\tgetFunctionName(): string;\n\tgetMethodName(): string;\n\tgetFileName(): string;\n\tgetLineNumber(): number;\n\tgetColumnNumber(): number;\n\tgetEvalOrigin(): string;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function disposed(what: string): Error {\n\tconst result = new Error(`${what} has been disposed`);\n\tresult.name = 'DISPOSED';\n\treturn result;\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class ExpectedError extends Error {\n\treadonly isExpected = true;\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'ErrorNoTelemetry';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'ErrorNoTelemetry';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// eslint-disable-next-line no-debugger\n\t\tdebugger;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { ISplice } from 'vs/base/common/sequence';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail<T>(array: ArrayLike<T>, n: number = 0): T {\n\treturn array[array.length - (1 + n)];\n}\n\nexport function tail2<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder<T>(array: T[], index: number) {\n\tconst last = array.length - 1;\n\tif (index < last) {\n\t\tarray[index] = array[last];\n\t}\n\tarray.pop();\n}\n\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\treturn binarySearch2(array.length, i => comparator(array[i], key));\n}\n\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length: number, compareToKey: (index: number) => number): number {\n\tlet low = 0,\n\t\thigh = length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = compareToKey(mid);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted<T>(array: ReadonlyArray<T>, p: (x: T) => boolean): number {\n\tlet low = 0, high = array.length;\n\tif (high === 0) {\n\t\treturn 0; // no children\n\t}\n\twhile (low < high) {\n\t\tconst mid = Math.floor((low + high) / 2);\n\t\tif (p(array[mid])) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn low;\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tconst pivotValue = data[Math.floor(data.length * Math.random())];\n\tconst lower: T[] = [];\n\tconst higher: T[] = [];\n\tconst pivots: T[] = [];\n\n\tfor (const value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[]; added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstInSorted(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn <T[]>array.filter(e => !!e);\n}\n\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): void {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn: (value: T) => any = value => value): T[] {\n\tconst seen = new Set<any>();\n\n\treturn array.filter(element => {\n\t\tconst key = keyFn!(element);\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T, R>(keyFn: (t: T) => R): (t: T) => boolean {\n\tconst seen = new Set<R>();\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(key);\n\t\treturn true;\n\t};\n}\n\nexport function findLast<T>(arr: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = lastIndex(arr, predicate);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn arr[idx];\n}\n\nexport function lastIndex<T>(array: ReadonlyArray<T>, fn: (item: T) => boolean): number {\n\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (fn(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue: NotFound): T | NotFound;\nexport function firstOrDefault<T>(array: ReadonlyArray<T>): T | undefined;\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue?: NotFound): T | NotFound | undefined {\n\treturn array.length > 0 ? array[0] : notFoundValue;\n}\n\nexport function lastOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue: NotFound): T | NotFound;\nexport function lastOrDefault<T>(array: ReadonlyArray<T>): T | undefined;\nexport function lastOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue?: NotFound): T | NotFound | undefined {\n\treturn array.length > 0 ? array[array.length - 1] : notFoundValue;\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\n/**\n * @deprecated Use `[].flat()`\n */\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn (<T[]>[]).concat(...arr);\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {\n\tfor (const item of items) {\n\t\tarr.push(item);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFind<T, R>(array: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of array) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto<T>(array: T[], start: number, newItems: T[]): void {\n\tconst startIdx = getActualStartIndex(array, start);\n\tconst originalLength = array.length;\n\tconst newItemsLength = newItems.length;\n\tarray.length = originalLength + newItemsLength;\n\t// Move the items after the start index, start from the end so that we don't overwrite any value.\n\tfor (let i = originalLength - 1; i >= startIdx; i--) {\n\t\tarray[i + newItemsLength] = array[i];\n\t}\n\n\tfor (let i = 0; i < newItemsLength; i++) {\n\t\tarray[i + startIdx] = newItems[i];\n\t}\n}\n\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start: number, deleteCount: number, newItems: T[]): T[] {\n\tconst index = getActualStartIndex(array, start);\n\tconst result = array.splice(index, deleteCount);\n\tinsertInto(array, index, newItems);\n\treturn result;\n}\n\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex<T>(array: T[], start: number): number {\n\treturn start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\n/**\n * When comparing two values,\n * a negative number indicates that the first value is less than the second,\n * a positive number indicates that the first value is greater than the second,\n * and zero indicates that neither is the case.\n*/\nexport type CompareResult = number;\n\nexport namespace CompareResult {\n\texport function isLessThan(result: CompareResult): boolean {\n\t\treturn result < 0;\n\t}\n\n\texport function isGreaterThan(result: CompareResult): boolean {\n\t\treturn result > 0;\n\t}\n\n\texport function isNeitherLessOrGreaterThan(result: CompareResult): boolean {\n\t\treturn result === 0;\n\t}\n\n\texport const greaterThan = 1;\n\texport const lessThan = -1;\n\texport const neitherLessOrGreaterThan = 0;\n}\n\n/**\n * A comparator `c` defines a total order `<=` on `T` as following:\n * `c(a, b) <= 0` iff `a` <= `b`.\n * We also have `c(a, b) == 0` iff `c(b, a) == 0`.\n*/\nexport type Comparator<T> = (a: T, b: T) => CompareResult;\n\nexport function compareBy<TItem, TCompareBy>(selector: (item: TItem) => TCompareBy, comparator: Comparator<TCompareBy>): Comparator<TItem> {\n\treturn (a, b) => comparator(selector(a), selector(b));\n}\n\nexport function tieBreakComparators<TItem>(...comparators: Comparator<TItem>[]): Comparator<TItem> {\n\treturn (item1, item2) => {\n\t\tfor (const comparator of comparators) {\n\t\t\tconst result = comparator(item1, item2);\n\t\t\tif (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn CompareResult.neitherLessOrGreaterThan;\n\t};\n}\n\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator: Comparator<number> = (a, b) => a - b;\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findMaxBy<T>(items: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (items.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = items[0];\n\tfor (let i = 1; i < items.length; i++) {\n\t\tconst item = items[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy<T>(items: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (items.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = items[0];\n\tfor (let i = 1; i < items.length; i++) {\n\t\tconst item = items[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findMinBy<T>(items: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findMaxBy(items, (a, b) => -comparator(a, b));\n}\n\nexport class ArrayQueue<T> {\n\tprivate firstIdx = 0;\n\tprivate lastIdx = this.items.length - 1;\n\n\t/**\n\t * Constructs a queue that is backed by the given array. Runtime is O(1).\n\t*/\n\tconstructor(private readonly items: readonly T[]) { }\n\n\tget length(): number {\n\t\treturn this.lastIdx - this.firstIdx + 1;\n\t}\n\n\t/**\n\t * Consumes elements from the beginning of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n\t*/\n\ttakeWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := k <= this.lastIdx && predicate(this.items[k])\n\t\t// Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n\n\t\tlet startIdx = this.firstIdx;\n\t\twhile (startIdx < this.items.length && predicate(this.items[startIdx])) {\n\t\t\tstartIdx++;\n\t\t}\n\t\tconst result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n\t\tthis.firstIdx = startIdx;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Consumes elements from the end of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned.\n\t * The result has the same order as the underlying array!\n\t*/\n\ttakeFromEndWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := this.firstIdx >= k && predicate(this.items[k])\n\t\t// Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n\n\t\tlet endIdx = this.lastIdx;\n\t\twhile (endIdx >= 0 && predicate(this.items[endIdx])) {\n\t\t\tendIdx--;\n\t\t}\n\t\tconst result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n\t\tthis.lastIdx = endIdx;\n\t\treturn result;\n\t}\n\n\tpeek(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.firstIdx];\n\t}\n\n\tpeekLast(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.lastIdx];\n\t}\n\n\tdequeue(): T | undefined {\n\t\tconst result = this.items[this.firstIdx];\n\t\tthis.firstIdx++;\n\t\treturn result;\n\t}\n\n\tremoveLast(): T | undefined {\n\t\tconst result = this.items[this.lastIdx];\n\t\tthis.lastIdx--;\n\t\treturn result;\n\t}\n\n\ttakeCount(count: number): T[] {\n\t\tconst result = this.items.slice(this.firstIdx, this.firstIdx + count);\n\t\tthis.firstIdx += count;\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function once<T extends Function>(this: unknown, fn: T): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: unknown;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tresult = fn.apply(_this, arguments);\n\n\t\treturn result;\n\t} as unknown as T;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace Iterable {\n\n\texport function is<T = any>(thing: any): thing is IterableIterator<T> {\n\t\treturn thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<any> = Object.freeze([]);\n\texport function empty<T = any>(): Iterable<T> {\n\t\treturn _empty;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable || _empty;\n\t}\n\n\texport function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean {\n\t\treturn !iterable || iterable[Symbol.iterator]().next().done === true;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T) => unknown): boolean {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\texport function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;\n\texport function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element, index++);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: Iterable<T>[]): Iterable<T> {\n\t\tfor (const iterable of iterables) {\n\t\t\tfor (const element of iterable) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* concatNested<T>(iterables: Iterable<Iterable<T>>): Iterable<T> {\n\t\tfor (const iterable of iterables) {\n\t\t\tfor (const element of iterable) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R {\n\t\tlet value = initialValue;\n\t\tfor (const element of iterable) {\n\t\t\tvalue = reducer(value, element);\n\t\t}\n\t\treturn value;\n\t}\n\n\texport function forEach<T>(iterable: Iterable<T>, fn: (t: T, index: number) => any): void {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tfn(element, index++);\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n\t */\n\texport function* slice<T>(arr: ReadonlyArray<T>, from: number, to = arr.length): Iterable<T> {\n\t\tif (from < 0) {\n\t\t\tfrom += arr.length;\n\t\t}\n\n\t\tif (to < 0) {\n\t\t\tto += arr.length;\n\t\t} else if (to > arr.length) {\n\t\t\tto = arr.length;\n\t\t}\n\n\t\tfor (; from < to; from++) {\n\t\t\tyield arr[from];\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function collect<T>(iterable: Iterable<T>): T[] {\n\t\treturn consume(iterable)[0];\n\t}\n\n\t/**\n\t * Returns whether the iterables are the same length and all items are\n\t * equal using the comparator function.\n\t */\n\texport function equals<T>(a: Iterable<T>, b: Iterable<T>, comparator = (at: T, bt: T) => at === bt) {\n\t\tconst ai = a[Symbol.iterator]();\n\t\tconst bi = b[Symbol.iterator]();\n\t\twhile (true) {\n\t\t\tconst an = ai.next();\n\t\t\tconst bn = bi.next();\n\n\t\t\tif (an.done !== bn.done) {\n\t\t\t\treturn false;\n\t\t\t} else if (an.done) {\n\t\t\t\treturn true;\n\t\t\t} else if (!comparator(an.value, bn.value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A value that is resolved synchronously when it is first needed.\n */\nexport interface Lazy<T> {\n\n\thasValue(): boolean;\n\n\n\tgetValue(): T;\n\n\n\tmap<R>(f: (x: T) => R): Lazy<R>;\n}\n\nexport class Lazy<T> {\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: Error | undefined;\n\n\tconstructor(\n\t\tprivate readonly executor: () => T,\n\t) { }\n\n\t/**\n\t * True if the lazy value has been resolved.\n\t */\n\thasValue() { return this._didRun; }\n\n\t/**\n\t * Get the wrapped value.\n\t *\n\t * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n\t * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n\t */\n\tgetValue(): T {\n\t\tif (!this._didRun) {\n\t\t\ttry {\n\t\t\t\tthis._value = this.executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\t/**\n\t * Get the wrapped value without forcing evaluation.\n\t */\n\tget rawValue(): T | undefined { return this._value; }\n\n\t/**\n\t * Create a new lazy value that is the result of applying `f` to the wrapped value.\n\t *\n\t * This does not force the evaluation of the current lazy value.\n\t */\n\tmap<R>(f: (x: T) => R): Lazy<R> {\n\t\treturn new Lazy<R>(() => f(this.getValue()));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { once } from 'vs/base/common/functional';\nimport { Iterable } from 'vs/base/common/iterator';\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nfunction trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nfunction markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\nexport class MultiDisposeError extends Error {\n\tconstructor(\n\t\tpublic readonly errors: any[]\n\t) {\n\t\tsuper(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n\t}\n}\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function isDisposable<E extends object>(thing: E): thing is E & IDisposable {\n\treturn typeof (<IDisposable>thing).dispose === 'function' && (<IDisposable>thing).dispose.length === 0;\n}\n\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends IterableIterator<T> = IterableIterator<T>>(disposables: IterableIterator<T>): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | IterableIterator<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new MultiDisposeError(errors);\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\n\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: once(() => {\n\t\t\tmarkAsDisposed(self);\n\t\t\tfn();\n\t\t})\n\t});\n\treturn self;\n}\n\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * Returns `true` if this object has been disposed\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\ttry {\n\t\t\tdispose(this._toDispose.values());\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\tclear() {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable implements IDisposable {\n\n\tdispose: () => void = () => { };\n\tunset: () => void = () => { };\n\tisset: () => boolean = () => false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tset(fn: Function) {\n\t\tlet callback: Function | undefined = fn;\n\t\tthis.unset = () => callback = undefined;\n\t\tthis.isset = () => callback !== undefined;\n\t\tthis.dispose = () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t\tcallback = undefined;\n\t\t\t\tmarkAsDisposed(this);\n\t\t\t}\n\t\t};\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = once(() => {\n\t\t\tif (--reference!.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference!.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<any>(undefined);\n\n\telement: E;\n\tnext: Node<E>;\n\tprev: Node<E>;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> = Node.Undefined;\n\tprivate _last: Node<E> = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tconst next = node.next;\n\t\t\tnode.prev = Node.Undefined;\n\t\t\tnode.next = Node.Undefined;\n\t\t\tnode = next;\n\t\t}\n\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last!;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last!.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first!.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string };\n\t_translationsConfigFile: string;\n}\n\nexport interface IProcessEnvironment {\n\t[key: string]: string | undefined;\n}\n\n/**\n * This interface is intentionally not identical to node.js\n * process because it also works in sandboxed environments\n * where the process object is implemented differently. We\n * define the properties here that we need for `platform`\n * to work and nothing else.\n */\nexport interface INodeProcess {\n\tplatform: string;\n\tarch: string;\n\tenv: IProcessEnvironment;\n\tversions?: {\n\t\telectron?: string;\n\t};\n\ttype?: string;\n\tcwd: () => string;\n}\n\ndeclare const process: INodeProcess;\ndeclare const global: unknown;\ndeclare const self: unknown;\n\nexport const globals: any = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\n\t// Native environment (sandboxed)\n\tnodeProcess = globals.vscode.process;\n} else if (typeof process !== 'undefined') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n}\n\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n\ninterface INavigator {\n\tuserAgent: string;\n\tmaxTouchPoints?: number;\n}\ndeclare const navigator: INavigator;\n\n// Web environment\nif (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isWeb = true;\n\n\t_locale = LANGUAGE_DEFAULT;\n\n\t_language = _locale;\n\tconst el = typeof document !== 'undefined' && document.getElementById('vscode-remote-nls-configuration');\n\tconst rawNlsConfig = el && el.getAttribute('data-settings');\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t\t_language = nlsConfig.availableLanguages['*'] || LANGUAGE_DEFAULT;\n\t\t} catch (error) { /* Oh well. */ }\n\t}\n}\n\n// Native environment\nelse if (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n\t_isElectron = isElectronProcess;\n\t_isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: NLSConfig = JSON.parse(rawNlsConfig);\n\t\t\tconst resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig._translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport function PlatformToString(platform: Platform) {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isLinuxSnap = _isLinuxSnap;\nexport const isNative = _isNative;\nexport const isElectron = _isElectron;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof globals.importScripts === 'function');\nexport const isIOS = _isIOS;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexport const isCI = _isCI;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * The translations that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const setTimeout0IsFaster = (typeof globals.postMessage === 'function' && !globals.importScripts);\n\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n\tif (setTimeout0IsFaster) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tconst pending: IQueueElement[] = [];\n\t\tglobals.addEventListener('message', (e: MessageEvent) => {\n\t\t\tif (e.data && e.data.vscodeScheduleAsyncWork) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeScheduleAsyncWork) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\tglobals.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n\t\t};\n\t}\n\treturn (callback: () => void) => setTimeout(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { globals, INodeProcess, isMacintosh, isWindows } from 'vs/base/common/platform';\n\nlet safeProcess: Omit<INodeProcess, 'arch'> & { arch: string | undefined };\ndeclare const process: INodeProcess;\n\n// Native sandbox environment\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\n\tconst sandboxProcess: INodeProcess = globals.vscode.process;\n\tsafeProcess = {\n\t\tget platform() { return sandboxProcess.platform; },\n\t\tget arch() { return sandboxProcess.arch; },\n\t\tget env() { return sandboxProcess.env; },\n\t\tcwd() { return sandboxProcess.cwd(); }\n\t};\n}\n\n// Native node.js environment\nelse if (typeof process !== 'undefined') {\n\tsafeProcess = {\n\t\tget platform() { return process.platform; },\n\t\tget arch() { return process.arch; },\n\t\tget env() { return process.env; },\n\t\tcwd() { return process.env['VSCODE_CWD'] || process.cwd(); }\n\t};\n}\n\n// Web environment\nelse {\n\tsafeProcess = {\n\n\t\t// Supported\n\t\tget platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n\t\tget arch() { return undefined; /* arch is undefined in web */ },\n\n\t\t// Unsupported\n\t\tget env() { return {}; },\n\t\tcwd() { return '/'; }\n\t};\n}\n\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n */\nexport const cwd = safeProcess.cwd;\n\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nexport const env = safeProcess.env;\n\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nexport const platform = safeProcess.platform;\n\n/**\n * Provides safe access to the `arch` method in node.js, sandboxed or web\n * environments.\n * Note: `arch` is `undefined` in web\n */\nexport const arch = safeProcess.arch;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v14.16.0/lib/path.js\n\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport * as process from 'vs/base/common/process';\n\nconst CHAR_UPPERCASE_A = 65;/* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\n\nclass ErrorInvalidArgType extends Error {\n\tcode: 'ERR_INVALID_ARG_TYPE';\n\tconstructor(name: string, expected: string, actual: unknown) {\n\t\t// determiner: 'must be' or 'must not be'\n\t\tlet determiner;\n\t\tif (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n\t\t\tdeterminer = 'must not be';\n\t\t\texpected = expected.replace(/^not /, '');\n\t\t} else {\n\t\t\tdeterminer = 'must be';\n\t\t}\n\n\t\tconst type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n\t\tlet msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n\n\t\tmsg += `. Received type ${typeof actual}`;\n\t\tsuper(msg);\n\n\t\tthis.code = 'ERR_INVALID_ARG_TYPE';\n\t}\n}\n\nfunction validateString(value: string, name: string) {\n\tif (typeof value !== 'string') {\n\t\tthrow new ErrorInvalidArgType(name, 'string', value);\n\t}\n}\n\nfunction isPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code: number | undefined) {\n\treturn code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code: number) {\n\treturn (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n\t\t(code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path: string, allowAboveRoot: boolean, separator: string, isPathSeparator: (code?: number) => boolean) {\n\tlet res = '';\n\tlet lastSegmentLength = 0;\n\tlet lastSlash = -1;\n\tlet dots = 0;\n\tlet code = 0;\n\tfor (let i = 0; i <= path.length; ++i) {\n\t\tif (i < path.length) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t}\n\t\telse if (isPathSeparator(code)) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tcode = CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\tif (isPathSeparator(code)) {\n\t\t\tif (lastSlash === i - 1 || dots === 1) {\n\t\t\t\t// NOOP\n\t\t\t} else if (dots === 2) {\n\t\t\t\tif (res.length < 2 || lastSegmentLength !== 2 ||\n\t\t\t\t\tres.charCodeAt(res.length - 1) !== CHAR_DOT ||\n\t\t\t\t\tres.charCodeAt(res.length - 2) !== CHAR_DOT) {\n\t\t\t\t\tif (res.length > 2) {\n\t\t\t\t\t\tconst lastSlashIndex = res.lastIndexOf(separator);\n\t\t\t\t\t\tif (lastSlashIndex === -1) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres = res.slice(0, lastSlashIndex);\n\t\t\t\t\t\t\tlastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (res.length !== 0) {\n\t\t\t\t\t\tres = '';\n\t\t\t\t\t\tlastSegmentLength = 0;\n\t\t\t\t\t\tlastSlash = i;\n\t\t\t\t\t\tdots = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allowAboveRoot) {\n\t\t\t\t\tres += res.length > 0 ? `${separator}..` : '..';\n\t\t\t\t\tlastSegmentLength = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (res.length > 0) {\n\t\t\t\t\tres += `${separator}${path.slice(lastSlash + 1, i)}`;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = path.slice(lastSlash + 1, i);\n\t\t\t\t}\n\t\t\t\tlastSegmentLength = i - lastSlash - 1;\n\t\t\t}\n\t\t\tlastSlash = i;\n\t\t\tdots = 0;\n\t\t} else if (code === CHAR_DOT && dots !== -1) {\n\t\t\t++dots;\n\t\t} else {\n\t\t\tdots = -1;\n\t\t}\n\t}\n\treturn res;\n}\n\nfunction _format(sep: string, pathObject: ParsedPath) {\n\tif (pathObject === null || typeof pathObject !== 'object') {\n\t\tthrow new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n\t}\n\tconst dir = pathObject.dir || pathObject.root;\n\tconst base = pathObject.base ||\n\t\t`${pathObject.name || ''}${pathObject.ext || ''}`;\n\tif (!dir) {\n\t\treturn base;\n\t}\n\treturn dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nexport interface ParsedPath {\n\troot: string;\n\tdir: string;\n\tbase: string;\n\text: string;\n\tname: string;\n}\n\nexport interface IPath {\n\tnormalize(path: string): string;\n\tisAbsolute(path: string): boolean;\n\tjoin(...paths: string[]): string;\n\tresolve(...pathSegments: string[]): string;\n\trelative(from: string, to: string): string;\n\tdirname(path: string): string;\n\tbasename(path: string, ext?: string): string;\n\textname(path: string): string;\n\tformat(pathObject: ParsedPath): string;\n\tparse(path: string): ParsedPath;\n\ttoNamespacedPath(path: string): string;\n\tsep: '\\\\' | '/';\n\tdelimiter: string;\n\twin32: IPath | null;\n\tposix: IPath | null;\n}\n\nexport const win32: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedDevice = '';\n\t\tlet resolvedTail = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1; i--) {\n\t\t\tlet path;\n\t\t\tif (i >= 0) {\n\t\t\t\tpath = pathSegments[i];\n\t\t\t\tvalidateString(path, 'path');\n\n\t\t\t\t// Skip empty entries\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (resolvedDevice.length === 0) {\n\t\t\t\tpath = process.cwd();\n\t\t\t} else {\n\t\t\t\t// Windows has the concept of drive-specific current working\n\t\t\t\t// directories. If we've resolved a drive letter but not yet an\n\t\t\t\t// absolute path, get cwd for that drive, or the process cwd if\n\t\t\t\t// the drive cwd is not available. We're sure the device is not\n\t\t\t\t// a UNC path at this points, because UNC paths are always absolute.\n\t\t\t\tpath = process.env[`=${resolvedDevice}`] || process.cwd();\n\n\t\t\t\t// Verify that a cwd was found and that it actually points\n\t\t\t\t// to our drive. If not, default to the drive's root.\n\t\t\t\tif (path === undefined ||\n\t\t\t\t\t(path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n\t\t\t\t\t\tpath.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n\t\t\t\t\tpath = `${resolvedDevice}\\\\`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst len = path.length;\n\t\t\tlet rootEnd = 0;\n\t\t\tlet device = '';\n\t\t\tlet isAbsolute = false;\n\t\t\tconst code = path.charCodeAt(0);\n\n\t\t\t// Try to match a root\n\t\t\tif (len === 1) {\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// `path` contains just a path separator\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t}\n\t\t\t} else if (isPathSeparator(code)) {\n\t\t\t\t// Possible UNC root\n\n\t\t\t\t// If we started with a separator, we know we at least have an\n\t\t\t\t// absolute path of some kind (UNC or otherwise)\n\t\t\t\tisAbsolute = true;\n\n\t\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t\t// Matched double path separator at beginning\n\t\t\t\t\tlet j = 2;\n\t\t\t\t\tlet last = j;\n\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j === len || j !== last) {\n\t\t\t\t\t\t\t\t// We matched a UNC root\n\t\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trootEnd = 1;\n\t\t\t\t}\n\t\t\t} else if (isWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\t\t// Possible device root\n\t\t\t\tdevice = path.slice(0, 2);\n\t\t\t\trootEnd = 2;\n\t\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t\t// indicator\n\t\t\t\t\tisAbsolute = true;\n\t\t\t\t\trootEnd = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (device.length > 0) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tif (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n\t\t\t\t\t\t// This path points to another device so it is not applicable\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolvedDevice = device;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolvedAbsolute) {\n\t\t\t\tif (resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n\t\t\t\tresolvedAbsolute = isAbsolute;\n\t\t\t\tif (isAbsolute && resolvedDevice.length > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path,\n\t\t// but handle relative paths to be safe (might happen when process.cwd()\n\t\t// fails)\n\n\t\t// Normalize the tail path\n\t\tresolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\',\n\t\t\tisPathSeparator);\n\n\t\treturn resolvedAbsolute ?\n\t\t\t`${resolvedDevice}\\\\${resolvedTail}` :\n\t\t\t`${resolvedDevice}${resolvedTail}` || '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = 0;\n\t\tlet device;\n\t\tlet isAbsolute = false;\n\t\tconst code = path.charCodeAt(0);\n\n\t\t// Try to match a root\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a single char, exit early to avoid\n\t\t\t// unnecessary work\n\t\t\treturn isPosixPathSeparator(code) ? '\\\\' : path;\n\t\t}\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\t// If we started with a separator, we know we at least have an absolute\n\t\t\t// path of some kind (UNC or otherwise)\n\t\t\tisAbsolute = true;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\tconst firstPart = path.slice(last, j);\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\t// Return the normalized version of the UNC root since there\n\t\t\t\t\t\t\t// is nothing left to process\n\t\t\t\t\t\t\treturn `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\tdevice = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trootEnd = 1;\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tdevice = path.slice(0, 2);\n\t\t\trootEnd = 2;\n\t\t\tif (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// Treat separator following drive name as an absolute path\n\t\t\t\t// indicator\n\t\t\t\tisAbsolute = true;\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\n\t\tlet tail = rootEnd < len ?\n\t\t\tnormalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n\t\t\t'';\n\t\tif (tail.length === 0 && !isAbsolute) {\n\t\t\ttail = '.';\n\t\t}\n\t\tif (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n\t\t\ttail += '\\\\';\n\t\t}\n\t\tif (device === undefined) {\n\t\t\treturn isAbsolute ? `\\\\${tail}` : tail;\n\t\t}\n\t\treturn isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst code = path.charCodeAt(0);\n\t\treturn isPathSeparator(code) ||\n\t\t\t// Possible device root\n\t\t\t(len > 2 &&\n\t\t\t\tisWindowsDeviceRoot(code) &&\n\t\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\t\tisPathSeparator(path.charCodeAt(2)));\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tlet joined;\n\t\tlet firstPart: string | undefined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = firstPart = arg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjoined += `\\\\${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\n\t\t// Make sure that the joined path doesn't start with two slashes, because\n\t\t// normalize() will mistake it for a UNC path then.\n\t\t//\n\t\t// This step is skipped when it is very clear that the user actually\n\t\t// intended to point at a UNC path. This is assumed when the first\n\t\t// non-empty string arguments starts with exactly two slashes followed by\n\t\t// at least one more non-slash character.\n\t\t//\n\t\t// Note that for normalize() to treat a path as a UNC path it needs to\n\t\t// have at least 2 components, so we don't filter for that here.\n\t\t// This means that the user can use join to construct UNC paths from\n\t\t// a server name and a share name; for example:\n\t\t//   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\t\tlet needsReplace = true;\n\t\tlet slashCount = 0;\n\t\tif (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n\t\t\t++slashCount;\n\t\t\tconst firstLen = firstPart.length;\n\t\t\tif (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n\t\t\t\t++slashCount;\n\t\t\t\tif (firstLen > 2) {\n\t\t\t\t\tif (isPathSeparator(firstPart.charCodeAt(2))) {\n\t\t\t\t\t\t++slashCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We matched a UNC path in the first part\n\t\t\t\t\t\tneedsReplace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (needsReplace) {\n\t\t\t// Find any more consecutive slashes we need to replace\n\t\t\twhile (slashCount < joined.length &&\n\t\t\t\tisPathSeparator(joined.charCodeAt(slashCount))) {\n\t\t\t\tslashCount++;\n\t\t\t}\n\n\t\t\t// Replace the slashes if needed\n\t\t\tif (slashCount >= 2) {\n\t\t\t\tjoined = `\\\\${joined.slice(slashCount)}`;\n\t\t\t}\n\t\t}\n\n\t\treturn win32.normalize(joined);\n\t},\n\n\n\t// It will solve the relative path from `from` to `to`, for instance:\n\t//  from = 'C:\\\\orandea\\\\test\\\\aaa'\n\t//  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n\t// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromOrig = win32.resolve(from);\n\t\tconst toOrig = win32.resolve(to);\n\n\t\tif (fromOrig === toOrig) {\n\t\t\treturn '';\n\t\t}\n\n\t\tfrom = fromOrig.toLowerCase();\n\t\tto = toOrig.toLowerCase();\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim any leading backslashes\n\t\tlet fromStart = 0;\n\t\twhile (fromStart < from.length &&\n\t\t\tfrom.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet fromEnd = from.length;\n\t\twhile (fromEnd - 1 > fromStart &&\n\t\t\tfrom.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\tfromEnd--;\n\t\t}\n\t\tconst fromLen = fromEnd - fromStart;\n\n\t\t// Trim any leading backslashes\n\t\tlet toStart = 0;\n\t\twhile (toStart < to.length &&\n\t\t\tto.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoStart++;\n\t\t}\n\t\t// Trim trailing backslashes (applicable to UNC paths only)\n\t\tlet toEnd = to.length;\n\t\twhile (toEnd - 1 > toStart &&\n\t\t\tto.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n\t\t\ttoEnd--;\n\t\t}\n\t\tconst toLen = toEnd - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = fromLen < toLen ? fromLen : toLen;\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_BACKWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\n\t\t// We found a mismatch before the first common path separator was seen, so\n\t\t// return the original `to`.\n\t\tif (i !== length) {\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\treturn toOrig;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n\t\t\t\t\treturn toOrig.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 2) {\n\t\t\t\t\t// We get here if `from` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\'; to='C:\\\\foo'\n\t\t\t\t\treturn toOrig.slice(toStart + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t// We get here if `to` is the device root.\n\t\t\t\t\t// For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n\t\t\t\t\tlastCommonSep = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastCommonSep === -1) {\n\t\t\t\tlastCommonSep = 0;\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to` and\n\t\t// `from`\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '\\\\..';\n\t\t\t}\n\t\t}\n\n\t\ttoStart += lastCommonSep;\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts\n\t\tif (out.length > 0) {\n\t\t\treturn `${out}${toOrig.slice(toStart, toEnd)}`;\n\t\t}\n\n\t\tif (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n\t\t\t++toStart;\n\t\t}\n\n\t\treturn toOrig.slice(toStart, toEnd);\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Note: this will *probably* throw somewhere.\n\t\tif (typeof path !== 'string') {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (path.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst resolvedPath = win32.resolve(path);\n\n\t\tif (resolvedPath.length <= 2) {\n\t\t\treturn path;\n\t\t}\n\n\t\tif (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Possible UNC root\n\t\t\tif (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n\t\t\t\tconst code = resolvedPath.charCodeAt(2);\n\t\t\t\tif (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n\t\t\t\t\t// Matched non-long UNC root, convert the path to a long UNC path\n\t\t\t\t\treturn `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n\t\t\tresolvedPath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tresolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n\t\t\t// Matched device root, convert the path to a long UNC path\n\t\t\treturn `\\\\\\\\?\\\\${resolvedPath}`;\n\t\t}\n\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tconst len = path.length;\n\t\tif (len === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet rootEnd = -1;\n\t\tlet offset = 0;\n\t\tconst code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t// unnecessary work or a dot.\n\t\t\treturn isPathSeparator(code) ? path : '.';\n\t\t}\n\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = offset = 1;\n\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\n\t\t\t\t\t\t\t// Offset by 1 to include the separator after the UNC root to\n\t\t\t\t\t\t\t// treat it as a \"normal root\" on top of a (UNC) root\n\t\t\t\t\t\t\trootEnd = offset = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possible device root\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\trootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n\t\t\toffset = rootEnd;\n\t\t}\n\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = len - 1; i >= offset; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\tif (rootEnd === -1) {\n\t\t\t\treturn '.';\n\t\t\t}\n\n\t\t\tend = rootEnd;\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\t\tif (path.length >= 2 &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0)) &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON) {\n\t\t\tstart = 2;\n\t\t}\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= start; --i) {\n\t\t\tif (isPathSeparator(path.charCodeAt(i))) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet start = 0;\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Check for a drive letter prefix so as not to mistake the following\n\t\t// path separator as an extra separator at the end of the path that can be\n\t\t// disregarded\n\n\t\tif (path.length >= 2 &&\n\t\t\tpath.charCodeAt(1) === CHAR_COLON &&\n\t\t\tisWindowsDeviceRoot(path.charCodeAt(0))) {\n\t\t\tstart = startPart = 2;\n\t\t}\n\n\t\tfor (let i = path.length - 1; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '\\\\'),\n\n\tparse(path) {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst len = path.length;\n\t\tlet rootEnd = 0;\n\t\tlet code = path.charCodeAt(0);\n\n\t\tif (len === 1) {\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// `path` contains just a path separator, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.base = ret.name = path;\n\t\t\treturn ret;\n\t\t}\n\t\t// Try to match a root\n\t\tif (isPathSeparator(code)) {\n\t\t\t// Possible UNC root\n\n\t\t\trootEnd = 1;\n\t\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t\t// Matched double path separator at beginning\n\t\t\t\tlet j = 2;\n\t\t\t\tlet last = j;\n\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t// Matched!\n\t\t\t\t\tlast = j;\n\t\t\t\t\t// Match 1 or more path separators\n\t\t\t\t\twhile (j < len && isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (j < len && j !== last) {\n\t\t\t\t\t\t// Matched!\n\t\t\t\t\t\tlast = j;\n\t\t\t\t\t\t// Match 1 or more non-path separators\n\t\t\t\t\t\twhile (j < len && !isPathSeparator(path.charCodeAt(j))) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j === len) {\n\t\t\t\t\t\t\t// We matched a UNC root only\n\t\t\t\t\t\t\trootEnd = j;\n\t\t\t\t\t\t} else if (j !== last) {\n\t\t\t\t\t\t\t// We matched a UNC root with leftovers\n\t\t\t\t\t\t\trootEnd = j + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n\t\t\t// Possible device root\n\t\t\tif (len <= 2) {\n\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t// unnecessary work\n\t\t\t\tret.root = ret.dir = path;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\trootEnd = 2;\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tif (len === 3) {\n\t\t\t\t\t// `path` contains just a drive root, exit early to avoid\n\t\t\t\t\t// unnecessary work\n\t\t\t\t\tret.root = ret.dir = path;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\trootEnd = 3;\n\t\t\t}\n\t\t}\n\t\tif (rootEnd > 0) {\n\t\t\tret.root = path.slice(0, rootEnd);\n\t\t}\n\n\t\tlet startDot = -1;\n\t\tlet startPart = rootEnd;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= rootEnd; --i) {\n\t\t\tcode = path.charCodeAt(i);\n\t\t\tif (isPathSeparator(code)) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(startPart, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(startPart, startDot);\n\t\t\t\tret.base = path.slice(startPart, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\t// If the directory is the root, use the entire root as the `dir` including\n\t\t// the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n\t\t// trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\t\tif (startPart > 0 && startPart !== rootEnd) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else {\n\t\t\tret.dir = ret.root;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '\\\\',\n\tdelimiter: ';',\n\twin32: null,\n\tposix: null\n};\n\nexport const posix: IPath = {\n\t// path.resolve([from ...], to)\n\tresolve(...pathSegments: string[]): string {\n\t\tlet resolvedPath = '';\n\t\tlet resolvedAbsolute = false;\n\n\t\tfor (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t\t\tconst path = i >= 0 ? pathSegments[i] : process.cwd();\n\n\t\t\tvalidateString(path, 'path');\n\n\t\t\t// Skip empty entries\n\t\t\tif (path.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresolvedPath = `${path}/${resolvedPath}`;\n\t\t\tresolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\t}\n\n\t\t// At this point the path should be resolved to a full absolute path, but\n\t\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\n\t\t// Normalize the path\n\t\tresolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',\n\t\t\tisPosixPathSeparator);\n\n\t\tif (resolvedAbsolute) {\n\t\t\treturn `/${resolvedPath}`;\n\t\t}\n\t\treturn resolvedPath.length > 0 ? resolvedPath : '.';\n\t},\n\n\tnormalize(path: string): string {\n\t\tvalidateString(path, 'path');\n\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tconst trailingSeparator =\n\t\t\tpath.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n\n\t\t// Normalize the path\n\t\tpath = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n\t\tif (path.length === 0) {\n\t\t\tif (isAbsolute) {\n\t\t\t\treturn '/';\n\t\t\t}\n\t\t\treturn trailingSeparator ? './' : '.';\n\t\t}\n\t\tif (trailingSeparator) {\n\t\t\tpath += '/';\n\t\t}\n\n\t\treturn isAbsolute ? `/${path}` : path;\n\t},\n\n\tisAbsolute(path: string): boolean {\n\t\tvalidateString(path, 'path');\n\t\treturn path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t},\n\n\tjoin(...paths: string[]): string {\n\t\tif (paths.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tlet joined;\n\t\tfor (let i = 0; i < paths.length; ++i) {\n\t\t\tconst arg = paths[i];\n\t\t\tvalidateString(arg, 'path');\n\t\t\tif (arg.length > 0) {\n\t\t\t\tif (joined === undefined) {\n\t\t\t\t\tjoined = arg;\n\t\t\t\t} else {\n\t\t\t\t\tjoined += `/${arg}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (joined === undefined) {\n\t\t\treturn '.';\n\t\t}\n\t\treturn posix.normalize(joined);\n\t},\n\n\trelative(from: string, to: string): string {\n\t\tvalidateString(from, 'from');\n\t\tvalidateString(to, 'to');\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Trim leading forward slashes.\n\t\tfrom = posix.resolve(from);\n\t\tto = posix.resolve(to);\n\n\t\tif (from === to) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromStart = 1;\n\t\tconst fromEnd = from.length;\n\t\tconst fromLen = fromEnd - fromStart;\n\t\tconst toStart = 1;\n\t\tconst toLen = to.length - toStart;\n\n\t\t// Compare paths to find the longest common path from root\n\t\tconst length = (fromLen < toLen ? fromLen : toLen);\n\t\tlet lastCommonSep = -1;\n\t\tlet i = 0;\n\t\tfor (; i < length; i++) {\n\t\t\tconst fromCode = from.charCodeAt(fromStart + i);\n\t\t\tif (fromCode !== to.charCodeAt(toStart + i)) {\n\t\t\t\tbreak;\n\t\t\t} else if (fromCode === CHAR_FORWARD_SLASH) {\n\t\t\t\tlastCommonSep = i;\n\t\t\t}\n\t\t}\n\t\tif (i === length) {\n\t\t\tif (toLen > length) {\n\t\t\t\tif (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `from` is the exact base path for `to`.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/foo/bar/baz'\n\t\t\t\t\treturn to.slice(toStart + i + 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// We get here if `from` is the root\n\t\t\t\t\t// For example: from='/'; to='/foo'\n\t\t\t\t\treturn to.slice(toStart + i);\n\t\t\t\t}\n\t\t\t} else if (fromLen > length) {\n\t\t\t\tif (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// We get here if `to` is the exact base path for `from`.\n\t\t\t\t\t// For example: from='/foo/bar/baz'; to='/foo/bar'\n\t\t\t\t\tlastCommonSep = i;\n\t\t\t\t} else if (i === 0) {\n\t\t\t\t\t// We get here if `to` is the root.\n\t\t\t\t\t// For example: from='/foo/bar'; to='/'\n\t\t\t\t\tlastCommonSep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet out = '';\n\t\t// Generate the relative path based on the path difference between `to`\n\t\t// and `from`.\n\t\tfor (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n\t\t\tif (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tout += out.length === 0 ? '..' : '/..';\n\t\t\t}\n\t\t}\n\n\t\t// Lastly, append the rest of the destination (`to`) path that comes after\n\t\t// the common path parts.\n\t\treturn `${out}${to.slice(toStart + lastCommonSep)}`;\n\t},\n\n\ttoNamespacedPath(path: string): string {\n\t\t// Non-op on posix systems\n\t\treturn path;\n\t},\n\n\tdirname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tif (path.length === 0) {\n\t\t\treturn '.';\n\t\t}\n\t\tconst hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tfor (let i = path.length - 1; i >= 1; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tend = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We saw the first non-path separator\n\t\t\t\tmatchedSlash = false;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn hasRoot ? '/' : '.';\n\t\t}\n\t\tif (hasRoot && end === 1) {\n\t\t\treturn '//';\n\t\t}\n\t\treturn path.slice(0, end);\n\t},\n\n\tbasename(path: string, ext?: string): string {\n\t\tif (ext !== undefined) {\n\t\t\tvalidateString(ext, 'ext');\n\t\t}\n\t\tvalidateString(path, 'path');\n\n\t\tlet start = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i;\n\n\t\tif (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n\t\t\tif (ext === path) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet extIdx = ext.length - 1;\n\t\t\tlet firstNonSlashEnd = -1;\n\t\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\t\tconst code = path.charCodeAt(i);\n\t\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (firstNonSlashEnd === -1) {\n\t\t\t\t\t\t// We saw the first non-path separator, remember this index in case\n\t\t\t\t\t\t// we need it if the extension ends up not matching\n\t\t\t\t\t\tmatchedSlash = false;\n\t\t\t\t\t\tfirstNonSlashEnd = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (extIdx >= 0) {\n\t\t\t\t\t\t// Try to match the explicit extension\n\t\t\t\t\t\tif (code === ext.charCodeAt(extIdx)) {\n\t\t\t\t\t\t\tif (--extIdx === -1) {\n\t\t\t\t\t\t\t\t// We matched the extension, so mark this as the end of our path\n\t\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\t\tend = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extension does not match, so our result is the entire path\n\t\t\t\t\t\t\t// component\n\t\t\t\t\t\t\textIdx = -1;\n\t\t\t\t\t\t\tend = firstNonSlashEnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (start === end) {\n\t\t\t\tend = firstNonSlashEnd;\n\t\t\t} else if (end === -1) {\n\t\t\t\tend = path.length;\n\t\t\t}\n\t\t\treturn path.slice(start, end);\n\t\t}\n\t\tfor (i = path.length - 1; i >= 0; --i) {\n\t\t\tif (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// path component\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (end === -1) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(start, end);\n\t},\n\n\textname(path: string): string {\n\t\tvalidateString(path, 'path');\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\t\tfor (let i = path.length - 1; i >= 0; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t}\n\t\t\t\telse if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (startDot === -1 ||\n\t\t\tend === -1 ||\n\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\tpreDotState === 0 ||\n\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t(preDotState === 1 &&\n\t\t\t\tstartDot === end - 1 &&\n\t\t\t\tstartDot === startPart + 1)) {\n\t\t\treturn '';\n\t\t}\n\t\treturn path.slice(startDot, end);\n\t},\n\n\tformat: _format.bind(null, '/'),\n\n\tparse(path: string): ParsedPath {\n\t\tvalidateString(path, 'path');\n\n\t\tconst ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\t\tif (path.length === 0) {\n\t\t\treturn ret;\n\t\t}\n\t\tconst isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n\t\tlet start;\n\t\tif (isAbsolute) {\n\t\t\tret.root = '/';\n\t\t\tstart = 1;\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\t\tlet startDot = -1;\n\t\tlet startPart = 0;\n\t\tlet end = -1;\n\t\tlet matchedSlash = true;\n\t\tlet i = path.length - 1;\n\n\t\t// Track the state of characters (if any) we see before our first dot and\n\t\t// after any path separator we find\n\t\tlet preDotState = 0;\n\n\t\t// Get non-dir info\n\t\tfor (; i >= start; --i) {\n\t\t\tconst code = path.charCodeAt(i);\n\t\t\tif (code === CHAR_FORWARD_SLASH) {\n\t\t\t\t// If we reached a path separator that was not part of a set of path\n\t\t\t\t// separators at the end of the string, stop now\n\t\t\t\tif (!matchedSlash) {\n\t\t\t\t\tstartPart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (end === -1) {\n\t\t\t\t// We saw the first non-path separator, mark this as the end of our\n\t\t\t\t// extension\n\t\t\t\tmatchedSlash = false;\n\t\t\t\tend = i + 1;\n\t\t\t}\n\t\t\tif (code === CHAR_DOT) {\n\t\t\t\t// If this is our first dot, mark it as the start of our extension\n\t\t\t\tif (startDot === -1) {\n\t\t\t\t\tstartDot = i;\n\t\t\t\t} else if (preDotState !== 1) {\n\t\t\t\t\tpreDotState = 1;\n\t\t\t\t}\n\t\t\t} else if (startDot !== -1) {\n\t\t\t\t// We saw a non-dot and non-path separator before our dot, so we should\n\t\t\t\t// have a good chance at having a non-empty extension\n\t\t\t\tpreDotState = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (end !== -1) {\n\t\t\tconst start = startPart === 0 && isAbsolute ? 1 : startPart;\n\t\t\tif (startDot === -1 ||\n\t\t\t\t// We saw a non-dot character immediately before the dot\n\t\t\t\tpreDotState === 0 ||\n\t\t\t\t// The (right-most) trimmed path component is exactly '..'\n\t\t\t\t(preDotState === 1 &&\n\t\t\t\t\tstartDot === end - 1 &&\n\t\t\t\t\tstartDot === startPart + 1)) {\n\t\t\t\tret.base = ret.name = path.slice(start, end);\n\t\t\t} else {\n\t\t\t\tret.name = path.slice(start, startDot);\n\t\t\t\tret.base = path.slice(start, end);\n\t\t\t\tret.ext = path.slice(startDot, end);\n\t\t\t}\n\t\t}\n\n\t\tif (startPart > 0) {\n\t\t\tret.dir = path.slice(0, startPart - 1);\n\t\t} else if (isAbsolute) {\n\t\t\tret.dir = '/';\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tsep: '/',\n\tdelimiter: ':',\n\twin32: null,\n\tposix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\nexport const isAbsolute = (process.platform === 'win32' ? win32.isAbsolute : posix.isAbsolute);\nexport const join = (process.platform === 'win32' ? win32.join : posix.join);\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\nexport const format = (process.platform === 'win32' ? win32.format : posix.format);\nexport const parse = (process.platform === 'win32' ? win32.parse : posix.parse);\nexport const toNamespacedPath = (process.platform === 'win32' ? win32.toNamespacedPath : posix.toNamespacedPath);\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\nexport const delimiter = (process.platform === 'win32' ? win32.delimiter : posix.delimiter);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IProcessEnvironment, isLinux, isMacintosh } from 'vs/base/common/platform';\n\n/**\n * Options to be passed to the external program or shell.\n */\nexport interface CommandOptions {\n\t/**\n\t * The current working directory of the executed program or shell.\n\t * If omitted VSCode's current workspace root is used.\n\t */\n\tcwd?: string;\n\n\t/**\n\t * The environment of the executed program or shell. If omitted\n\t * the parent process' environment is used.\n\t */\n\tenv?: { [key: string]: string };\n}\n\nexport interface Executable {\n\t/**\n\t * The command to be executed. Can be an external program or a shell\n\t * command.\n\t */\n\tcommand: string;\n\n\t/**\n\t * Specifies whether the command is a shell command and therefore must\n\t * be executed in a shell interpreter (e.g. cmd.exe, bash, ...).\n\t */\n\tisShellCommand: boolean;\n\n\t/**\n\t * The arguments passed to the command.\n\t */\n\targs: string[];\n\n\t/**\n\t * The command options used when the command is executed. Can be omitted.\n\t */\n\toptions?: CommandOptions;\n}\n\nexport interface ForkOptions extends CommandOptions {\n\texecArgv?: string[];\n}\n\nexport const enum Source {\n\tstdout,\n\tstderr\n}\n\n/**\n * The data send via a success callback\n */\nexport interface SuccessData {\n\terror?: Error;\n\tcmdCode?: number;\n\tterminated?: boolean;\n}\n\n/**\n * The data send via a error callback\n */\nexport interface ErrorData {\n\terror?: Error;\n\tterminated?: boolean;\n\tstdout?: string;\n\tstderr?: string;\n}\n\nexport interface TerminateResponse {\n\tsuccess: boolean;\n\tcode?: TerminateResponseCode;\n\terror?: any;\n}\n\nexport const enum TerminateResponseCode {\n\tSuccess = 0,\n\tUnknown = 1,\n\tAccessDenied = 2,\n\tProcessNotFound = 3,\n}\n\nexport interface ProcessItem {\n\tname: string;\n\tcmd: string;\n\tpid: number;\n\tppid: number;\n\tload: number;\n\tmem: number;\n\n\tchildren?: ProcessItem[];\n}\n\n/**\n * Sanitizes a VS Code process environment by removing all Electron/VS Code-related values.\n */\nexport function sanitizeProcessEnvironment(env: IProcessEnvironment, ...preserve: string[]): void {\n\tconst set = preserve.reduce((set, key) => {\n\t\tset[key] = true;\n\t\treturn set;\n\t}, {} as Record<string, boolean>);\n\tconst keysToRemove = [\n\t\t/^ELECTRON_.+$/,\n\t\t/^VSCODE_(?!SHELL_LOGIN).+$/,\n\t\t/^SNAP(|_.*)$/,\n\t\t/^GDK_PIXBUF_.+$/,\n\t\t/^CODE_SERVER_.+$/,\n\t\t/^CS_.+$/,\n\t];\n\tconst envKeys = Object.keys(env);\n\tenvKeys\n\t\t.filter(key => !set[key])\n\t\t.forEach(envKey => {\n\t\t\tfor (let i = 0; i < keysToRemove.length; i++) {\n\t\t\t\tif (envKey.search(keysToRemove[i]) !== -1) {\n\t\t\t\t\tdelete env[envKey];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n}\n\n/**\n * Remove dangerous environment variables that have caused crashes\n * in forked processes (i.e. in ELECTRON_RUN_AS_NODE processes)\n *\n * @param env The env object to change\n */\nexport function removeDangerousEnvVariables(env: IProcessEnvironment | undefined): void {\n\tif (!env) {\n\t\treturn;\n\t}\n\n\t// Unset `DEBUG`, as an invalid value might lead to process crashes\n\t// See https://github.com/microsoft/vscode/issues/130072\n\tdelete env['DEBUG'];\n\n\tif (isMacintosh) {\n\t\t// Unset `DYLD_LIBRARY_PATH`, as it leads to process crashes\n\t\t// See https://github.com/microsoft/vscode/issues/104525\n\t\t// See https://github.com/microsoft/vscode/issues/105848\n\t\tdelete env['DYLD_LIBRARY_PATH'];\n\t}\n\n\tif (isLinux) {\n\t\t// Unset `LD_PRELOAD`, as it might lead to process crashes\n\t\t// See https://github.com/microsoft/vscode/issues/134177\n\t\tdelete env['LD_PRELOAD'];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { globals } from 'vs/base/common/platform';\n\nconst hasPerformanceNow = (globals.performance && typeof globals.performance.now === 'function');\n\nexport class StopWatch {\n\n\tprivate _highResolution: boolean;\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tpublic static create(highResolution: boolean = true): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution: boolean) {\n\t\tthis._highResolution = hasPerformanceNow && highResolution;\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n\n\tprivate _now(): number {\n\t\treturn this._highResolution ? globals.performance.now() : Date.now();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { once as onceFn } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, DisposableStore, IDisposable, SafeDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { IObservable, IObserver } from 'vs/base/common/observable';\nimport { StopWatch } from 'vs/base/common/stopwatch';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\n// _enableSnapshotPotentialLeakWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onListenerDidAdd: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onListenerDidAdd = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits\n\t * whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number, leading?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number = 100, leading = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\thandle = setTimeout(() => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t}, delay);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove() {\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = []): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonFirstListenerDidAdd() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonLastListenerRemove() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\texport interface IChainableEvent<T> extends IDisposable {\n\n\t\tevent: Event<T>;\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O>;\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;\n\t\tlatch(): IChainableEvent<T>;\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\ton(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n\t\tonce(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n\t}\n\n\tclass ChainableEvent<T> implements IChainableEvent<T> {\n\n\t\tprivate readonly disposables = new DisposableStore();\n\n\t\tconstructor(readonly event: Event<T>) { }\n\n\t\tmap<O>(fn: (i: T) => O): IChainableEvent<O> {\n\t\t\treturn new ChainableEvent(map(this.event, fn, this.disposables));\n\t\t}\n\n\t\tforEach(fn: (i: T) => void): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(forEach(this.event, fn, this.disposables));\n\t\t}\n\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T>;\n\t\tfilter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(filter(this.event, fn, this.disposables));\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(reduce(this.event, merge, initial, this.disposables));\n\t\t}\n\n\t\tlatch(): IChainableEvent<T> {\n\t\t\treturn new ChainableEvent(latch(this.event, undefined, this.disposables));\n\t\t}\n\n\t\tdebounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;\n\t\tdebounce<R>(merge: (last: R | undefined, event: T) => R, delay: number = 100, leading = false, leakWarningThreshold?: number): IChainableEvent<R> {\n\t\t\treturn new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold, this.disposables));\n\t\t}\n\n\t\ton(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[] | DisposableStore) {\n\t\t\treturn this.event(listener, thisArgs, disposables);\n\t\t}\n\n\t\tonce(listener: (e: T) => any, thisArgs: any, disposables: IDisposable[]) {\n\t\t\treturn once(this.event)(listener, thisArgs, disposables);\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.disposables.dispose();\n\t\t}\n\t}\n\n\texport function chain<T>(event: Event<T>): IChainableEvent<T> {\n\t\treturn new ChainableEvent(event);\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onFirstListenerAdd, onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(resolve => once(event)(resolve));\n\t}\n\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable {\n\t\thandler(undefined);\n\t\treturn event(e => handler(e));\n\t}\n\n\texport function runAndSubscribeWithStore<T>(event: Event<T>, handler: (e: T | undefined, disposableStore: DisposableStore) => any): IDisposable {\n\t\tlet store: DisposableStore | null = null;\n\n\t\tfunction run(e: T | undefined) {\n\t\t\tstore?.dispose();\n\t\t\tstore = new DisposableStore();\n\t\t\thandler(e, store);\n\t\t}\n\n\t\trun(undefined);\n\t\tconst disposable = event(e => run(e));\n\t\treturn toDisposable(() => {\n\t\t\tdisposable.dispose();\n\t\t\tstore?.dispose();\n\t\t});\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly obs: IObservable<T, any>, store: DisposableStore | undefined) {\n\t\t\tconst options = {\n\t\t\t\tonFirstListenerAdd: () => {\n\t\t\t\t\tobs.addObserver(this);\n\t\t\t\t},\n\t\t\t\tonLastListenerRemove: () => {\n\t\t\t\t\tobs.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// console.assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservable<T, TChange>, _change: TChange): void {\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\tif (--this._counter === 0) {\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this.obs.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\texport function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n}\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonFirstListenerDidAdd?: Function;\n\tonListenerDidAdd?: Function;\n\tonLastListenerRemove?: Function;\n\tleakWarningThreshold?: number;\n\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nclass EventProfiling {\n\n\tprivate static _idPool = 0;\n\n\tprivate _name: string;\n\tprivate _stopWatch?: StopWatch;\n\tprivate _listenerCount: number = 0;\n\tprivate _invocationCount = 0;\n\tprivate _elapsedOverall = 0;\n\n\tconstructor(name: string) {\n\t\tthis._name = `${name}_${EventProfiling._idPool++}`;\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch(true);\n\t\tthis._listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis._elapsedOverall += elapsed;\n\t\t\tthis._invocationCount += 1;\n\n\t\t\tconsole.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\treadonly customThreshold?: number,\n\t\treadonly name: string = Math.random().toString(18).slice(2, 5),\n\t) { }\n\n\tdispose(): void {\n\t\tif (this._stacks) {\n\t\t\tthis._stacks.clear();\n\t\t}\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tlet threshold = _globalLeakWarningThreshold;\n\t\tif (typeof this.customThreshold === 'number') {\n\t\t\tthreshold = this.customThreshold;\n\t\t}\n\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\t// find most frequent listener and print warning\n\t\t\tlet topStack: string | undefined;\n\t\t\tlet topCount: number = 0;\n\t\t\tfor (const [stack, count] of this._stacks) {\n\t\t\t\tif (!topStack || topCount < count) {\n\t\t\t\t\ttopStack = stack;\n\t\t\t\t\ttopCount = count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n\t\t\tconsole.warn(topStack!);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\treturn new Stacktrace(new Error().stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\nclass Listener<T> {\n\n\treadonly subscription = new SafeDisposable();\n\n\tconstructor(\n\t\treadonly callback: (e: T) => void,\n\t\treadonly callbackThis: any | undefined,\n\t\treadonly stack: Stacktrace | undefined\n\t) { }\n\n\tinvoke(e: T) {\n\t\tthis.callback.call(this.callbackThis, e);\n\t}\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed: boolean = false;\n\tprivate _event?: Event<T>;\n\tprivate _deliveryQueue?: EventDeliveryQueue;\n\tprotected _listeners?: LinkedList<Listener<T>>;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = Array.from(this._listeners);\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\t\tif (listener.subscription.isset()) {\n\t\t\t\t\t\t\t\tlistener.subscription.unset();\n\t\t\t\t\t\t\t\tlistener.stack?.print();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners.clear();\n\t\t\t}\n\t\t\tthis._deliveryQueue?.clear(this);\n\t\t\tthis._options?.onLastListenerRemove?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (callback: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\t\tif (!this._listeners) {\n\t\t\t\t\tthis._listeners = new LinkedList();\n\t\t\t\t}\n\n\t\t\t\tconst firstListener = this._listeners.isEmpty();\n\n\t\t\t\tif (firstListener && this._options?.onFirstListenerAdd) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\n\t\t\t\tlet removeMonitor: Function | undefined;\n\t\t\t\tlet stack: Stacktrace | undefined;\n\t\t\t\tif (this._leakageMon && this._listeners.size >= 30) {\n\t\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\t\tstack = Stacktrace.create();\n\t\t\t\t\tremoveMonitor = this._leakageMon.check(stack, this._listeners.size + 1);\n\t\t\t\t}\n\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tstack = stack ?? Stacktrace.create();\n\t\t\t\t}\n\n\t\t\t\tconst listener = new Listener(callback, thisArgs, stack);\n\t\t\t\tconst removeListener = this._listeners.push(listener);\n\n\t\t\t\tif (firstListener && this._options?.onFirstListenerDidAdd) {\n\t\t\t\t\tthis._options.onFirstListenerDidAdd(this);\n\t\t\t\t}\n\n\t\t\t\tif (this._options?.onListenerDidAdd) {\n\t\t\t\t\tthis._options.onListenerDidAdd(this, callback, thisArgs);\n\t\t\t\t}\n\n\t\t\t\tconst result = listener.subscription.set(() => {\n\t\t\t\t\tremoveMonitor?.();\n\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\tremoveListener();\n\t\t\t\t\t\tif (this._options && this._options.onLastListenerRemove) {\n\t\t\t\t\t\t\tconst hasListeners = (this._listeners && !this._listeners.isEmpty());\n\t\t\t\t\t\t\tif (!hasListeners) {\n\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\t\tdisposables.add(result);\n\t\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\t// put all [listener,event]-pairs into delivery queue\n\t\t\t// then emit all event. an inner/nested event might be\n\t\t\t// the driver of this\n\n\t\t\tif (!this._deliveryQueue) {\n\t\t\t\tthis._deliveryQueue = new PrivateEventDeliveryQueue();\n\t\t\t}\n\n\t\t\tfor (const listener of this._listeners) {\n\t\t\t\tthis._deliveryQueue.push(this, listener, event);\n\t\t\t}\n\n\t\t\t// start/stop performance insight collection\n\t\t\tthis._perfMon?.start(this._deliveryQueue.size);\n\n\t\t\tthis._deliveryQueue.deliver();\n\n\t\t\tthis._perfMon?.stop();\n\t\t}\n\t}\n\n\thasListeners(): boolean {\n\t\tif (!this._listeners) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (!this._listeners.isEmpty());\n\t}\n}\n\nexport class EventDeliveryQueue {\n\tprotected _queue = new LinkedList<EventDeliveryQueueElement>();\n\n\tget size(): number {\n\t\treturn this._queue.size;\n\t}\n\n\tpush<T>(emitter: Emitter<T>, listener: Listener<T>, event: T): void {\n\t\tthis._queue.push(new EventDeliveryQueueElement(emitter, listener, event));\n\t}\n\n\tclear<T>(emitter: Emitter<T>): void {\n\t\tconst newQueue = new LinkedList<EventDeliveryQueueElement>();\n\t\tfor (const element of this._queue) {\n\t\t\tif (element.emitter !== emitter) {\n\t\t\t\tnewQueue.push(element);\n\t\t\t}\n\t\t}\n\t\tthis._queue = newQueue;\n\t}\n\n\tdeliver(): void {\n\t\twhile (this._queue.size > 0) {\n\t\t\tconst element = this._queue.shift()!;\n\t\t\ttry {\n\t\t\t\telement.listener.invoke(element.event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * An `EventDeliveryQueue` that is guaranteed to be used by a single `Emitter`.\n */\nclass PrivateEventDeliveryQueue extends EventDeliveryQueue {\n\toverride clear<T>(emitter: Emitter<T>): void {\n\t\t// Here we can just clear the entire linked list because\n\t\t// all elements are guaranteed to belong to this emitter\n\t\tthis._queue.clear();\n\t}\n}\n\nclass EventDeliveryQueueElement<T = any> {\n\tconstructor(\n\t\treadonly emitter: Emitter<T>,\n\t\treadonly listener: Listener<T>,\n\t\treadonly event: T\n\t) { }\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[Listener<T>, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tfor (const listener of this._listeners) {\n\t\t\tthis._asyncDeliveryQueue.push([listener, data]);\n\t\t}\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener.callback);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener.invoke(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\tthis._eventQueue.clear();\n\t\t\t\tsuper.fire(this._mergeFn(events));\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._listeners) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: any | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => this.onFirstListenerAdd(),\n\t\t\tonLastListenerRemove: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(onceFn(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\tif (e.listener) {\n\t\t\te.listener.dispose();\n\t\t}\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst buffer: Array<() => R> = [];\n\t\tthis.buffers.push(buffer);\n\t\tconst r = fn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonFirstListenerDidAdd: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonLastListenerRemove: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<any> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tif (this._parentListener) {\n\t\t\tthis._parentListener.dispose();\n\t\t}\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CacheResult<T> extends IDisposable {\n\tpromise: Promise<T>;\n}\n\nexport class Cache<T> {\n\n\tprivate result: CacheResult<T> | null = null;\n\tconstructor(private task: (ct: CancellationToken) => Promise<T>) { }\n\n\tget(): CacheResult<T> {\n\t\tif (this.result) {\n\t\t\treturn this.result;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource();\n\t\tconst promise = this.task(cts.token);\n\n\t\tthis.result = {\n\t\t\tpromise,\n\t\t\tdispose: () => {\n\t\t\t\tthis.result = null;\n\t\t\t\tcts.cancel();\n\t\t\t\tcts.dispose();\n\t\t\t}\n\t\t};\n\n\t\treturn this.result;\n\t}\n}\n\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last value.\n * The key must be JSON serializable.\n*/\nexport class LRUCachedFunction<TArg, TComputed> {\n\tprivate lastCache: TComputed | undefined = undefined;\n\tprivate lastArgKey: string | undefined = undefined;\n\n\tconstructor(private readonly fn: (arg: TArg) => TComputed) {\n\t}\n\n\tpublic get(arg: TArg): TComputed {\n\t\tconst key = JSON.stringify(arg);\n\t\tif (this.lastArgKey !== key) {\n\t\t\tthis.lastArgKey = key;\n\t\t\tthis.lastCache = this.fn(arg);\n\t\t}\n\t\treturn this.lastCache!;\n\t}\n}\n\n/**\n * Uses an unbounded cache (referential equality) to memoize the results of the given function.\n*/\nexport class CachedFunction<TArg, TValue> {\n\tprivate readonly _map = new Map<TArg, TValue>();\n\tpublic get cachedValues(): ReadonlyMap<TArg, TValue> {\n\t\treturn this._map;\n\t}\n\n\tconstructor(private readonly fn: (arg: TArg) => TValue) { }\n\n\tpublic get(arg: TArg): TValue {\n\t\tif (this._map.has(arg)) {\n\t\t\treturn this._map.get(arg)!;\n\t\t}\n\t\tconst value = this.fn(arg);\n\t\tthis._map.set(arg, value);\n\t\treturn value;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>): IDisposable {\n\tlet destroyed = false;\n\n\tstream.on('error', error => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!destroyed) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n\n\treturn toDisposable(() => destroyed = true);\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCachedFunction } from 'vs/base/common/cache';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Lazy } from 'vs/base/common/lazy';\nimport { Constants } from 'vs/base/common/uint';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\nconst _format2Regexp = /{([^}]+)}/g;\n\n/**\n * Helper to create a string from a template and a string record.\n * Similar to `format` but with objects instead of positional arguments.\n */\nexport function format2(template: string, values: Record<string, unknown>): string {\n\treturn template.replace(_format2Regexp, (match, group) => (values[group] ?? match) as string);\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `character` occurs inside `value`.\n */\nexport function count(value: string, character: string): number {\n\tlet result = 0;\n\tconst ch = character.charCodeAt(0);\n\tfor (let i = value.length - 1; i >= 0; i--) {\n\t\tif (value.charCodeAt(i) === ch) {\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\n\nexport function truncate(value: string, maxLength: number, suffix = '…'): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\treturn `${value.substr(0, maxLength)}${suffix}`;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function regExpContainsBackreference(regexpValue: string): boolean {\n\treturn !!regexpValue.match(/([^\\\\]|^)(\\\\\\\\)*\\\\\\d+/);\n}\n\nexport function regExpFlags(regexp: RegExp): string {\n\treturn (regexp.global ? 'g' : '')\n\t\t+ (regexp.ignoreCase ? 'i' : '')\n\t\t+ (regexp.multiline ? 'm' : '')\n\t\t+ ((regexp as any /* standalone editor compilation */).unicode ? 'u' : '');\n}\n\nexport function splitLines(str: string): string[] {\n\treturn str.split(/\\r\\n|\\r|\\n/);\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Function that works identically to String.prototype.replace, except, the\n * replace function is allowed to be async and return a Promise.\n */\nexport function replaceAsync(str: string, search: RegExp, replacer: (match: string, ...args: any[]) => Promise<string>): Promise<string> {\n\tconst parts: (string | Promise<string>)[] = [];\n\n\tlet last = 0;\n\tfor (const match of str.matchAll(search)) {\n\t\tparts.push(str.slice(last, match.index));\n\t\tif (match.index === undefined) {\n\t\t\tthrow new Error('match.index should be defined');\n\t\t}\n\n\t\tlast = match.index + match[0].length;\n\t\tparts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));\n\t}\n\n\tparts.push(str.slice(last));\n\n\treturn Promise.all(parts).then(p => p.join(''));\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tconst codeA = a.charCodeAt(aStart);\n\t\tconst codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codeA >= 128 || codeB >= 128) {\n\t\t\t// not ASCII letters -> fallback to lower-casing strings\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\n\t\t// mapper lower-case ascii letter onto upper-case varinats\n\t\t// [97-122] (lower ascii) --> [65-90] (upper ascii)\n\t\tif (isLowerAsciiLetter(codeA)) {\n\t\t\tcodeA -= 32;\n\t\t}\n\t\tif (isLowerAsciiLetter(codeB)) {\n\t\t\tcodeB -= 32;\n\t\t}\n\n\t\t// compare both code points\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isAsciiDigit(code: number): boolean {\n\treturn code >= CharCode.Digit0 && code <= CharCode.Digit9;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport class CodePointIterator {\n\n\tprivate readonly _str: string;\n\tprivate readonly _len: number;\n\tprivate _offset: number;\n\n\tpublic get offset(): number {\n\t\treturn this._offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._str = str;\n\t\tthis._len = str.length;\n\t\tthis._offset = offset;\n\t}\n\n\tpublic setOffset(offset: number): void {\n\t\tthis._offset = offset;\n\t}\n\n\tpublic prevCodePoint(): number {\n\t\tconst codePoint = getPrevCodePoint(this._str, this._offset);\n\t\tthis._offset -= (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic nextCodePoint(): number {\n\t\tconst codePoint = getNextCodePoint(this._str, this._len, this._offset);\n\t\tthis._offset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn (this._offset >= this._len);\n\t}\n}\n\nexport class GraphemeIterator {\n\n\tprivate readonly _iterator: CodePointIterator;\n\n\tpublic get offset(): number {\n\t\treturn this._iterator.offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._iterator = new CodePointIterator(str, offset);\n\t}\n\n\tpublic nextGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\twhile (!iterator.eol()) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = nextGraphemeBreakType;\n\t\t}\n\t\treturn (iterator.offset - initialOffset);\n\t}\n\n\tpublic prevGraphemeLength(): number {\n\t\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\t\tconst iterator = this._iterator;\n\t\tconst initialOffset = iterator.offset;\n\n\t\tlet graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\twhile (iterator.offset > 0) {\n\t\t\tconst offset = iterator.offset;\n\t\t\tconst prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n\t\t\tif (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n\t\t\t\t// move iterator back\n\t\t\t\titerator.setOffset(offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgraphemeBreakType = prevGraphemeBreakType;\n\t\t}\n\t\treturn (initialOffset - iterator.offset);\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn this._iterator.eol();\n\t}\n}\n\nexport function nextCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.nextGraphemeLength();\n}\n\nexport function prevCharLength(str: string, initialOffset: number): number {\n\tconst iterator = new GraphemeIterator(str, initialOffset);\n\treturn iterator.prevGraphemeLength();\n}\n\nexport function getCharContainingOffset(str: string, offset: number): [number, number] {\n\tif (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n\t\toffset--;\n\t}\n\tconst endOffset = offset + nextCharLength(str, offset);\n\tconst startOffset = endOffset - prevCharLength(str, endOffset);\n\treturn [startOffset, endOffset];\n}\n\n/**\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str: string): boolean {\n\treturn CONTAINS_RTL.test(str);\n}\n\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str: string): boolean {\n\treturn IS_BASIC_ASCII.test(str);\n}\n\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str: string): boolean {\n\treturn UNUSUAL_LINE_TERMINATORS.test(str);\n}\n\nexport function isFullWidthCharacter(charCode: number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 - 2EFF   CJK Radicals Supplement\n\t//          2F00 - 2FDF   Kangxi Radicals\n\t//          2FF0 - 2FFF   Ideographic Description Characters\n\t//          3000 - 303F   CJK Symbols and Punctuation\n\t//          3040 - 309F   Hiragana\n\t//          30A0 - 30FF   Katakana\n\t//          3100 - 312F   Bopomofo\n\t//          3130 - 318F   Hangul Compatibility Jamo\n\t//          3190 - 319F   Kanbun\n\t//          31A0 - 31BF   Bopomofo Extended\n\t//          31F0 - 31FF   Katakana Phonetic Extensions\n\t//          3200 - 32FF   Enclosed CJK Letters and Months\n\t//          3300 - 33FF   CJK Compatibility\n\t//          3400 - 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 - 4DFF   Yijing Hexagram Symbols\n\t//          4E00 - 9FFF   CJK Unified Ideographs\n\t//          A000 - A48F   Yi Syllables\n\t//          A490 - A4CF   Yi Radicals\n\t//          AC00 - D7AF   Hangul Syllables\n\t// [IGNORE] D800 - DB7F   High Surrogates\n\t// [IGNORE] DB80 - DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 - DFFF   Low Surrogates\n\t// [IGNORE] E000 - F8FF   Private Use Area\n\t//          F900 - FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 - FE0F   Variation Selectors\n\t// [IGNORE] FE20 - FE2F   Combining Half Marks\n\t// [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 - FE6F   Small Form Variants\n\t// [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n\t//          FF00 - FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 - FFFF   Specials\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n\treturn (\n\t\t(x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n\t\t|| (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n\t\t|| (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n\t\t|| (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n\t\t|| (x >= 129648 && x <= 129782)\n\t);\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number) {\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tconst re = /\\b/g;\n\tlet i = 0;\n\twhile (re.test(text)) {\n\t\tif (text.length - re.lastIndex < n) {\n\t\t\tbreak;\n\t\t}\n\n\t\ti = re.lastIndex;\n\t\tre.lastIndex += 1;\n\t}\n\n\treturn text.substring(i).replace(/^\\s/, '');\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\n// -- UTF-8 BOM\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(CharCode.UTF8_BOM);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn !!(str && str.length > 0 && str.charCodeAt(0) === CharCode.UTF8_BOM);\n}\n\nexport function stripUTF8BOM(str: string): string {\n\treturn startsWithUTF8BOM(str) ? str.substr(1) : str;\n}\n\n/**\n * Checks if the characters of the provided query string are included in the\n * target string. The characters do not have to be contiguous within the string.\n */\nexport function fuzzyContains(target: string, query: string): boolean {\n\tif (!target || !query) {\n\t\treturn false; // return early if target or query are undefined\n\t}\n\n\tif (target.length < query.length) {\n\t\treturn false; // impossible for query to be contained in target\n\t}\n\n\tconst queryLen = query.length;\n\tconst targetLower = target.toLowerCase();\n\n\tlet index = 0;\n\tlet lastIndexOf = -1;\n\twhile (index < queryLen) {\n\t\tconst indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);\n\t\tif (indexOf < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlastIndexOf = indexOf;\n\n\t\tindex++;\n\t}\n\n\treturn true;\n}\n\nexport function containsUppercaseCharacter(target: string, ignoreEscapedChars = false): boolean {\n\tif (!target) {\n\t\treturn false;\n\t}\n\n\tif (ignoreEscapedChars) {\n\t\ttarget = target.replace(/\\\\./g, '');\n\t}\n\n\treturn target.toLowerCase() !== target;\n}\n\nexport function uppercaseFirstLetter(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function getNLines(str: string, n = 1): string {\n\tif (n === 0) {\n\t\treturn '';\n\t}\n\n\tlet idx = -1;\n\tdo {\n\t\tidx = str.indexOf('\\n', idx + 1);\n\t\tn--;\n\t} while (n > 0 && idx >= 0);\n\n\tif (idx === -1) {\n\t\treturn str;\n\t}\n\n\tif (str[idx - 1] === '\\r') {\n\t\tidx--;\n\t}\n\n\treturn str.substr(0, idx);\n}\n\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n: number): string {\n\tconst LETTERS_CNT = (CharCode.Z - CharCode.A + 1);\n\n\tn = n % (2 * LETTERS_CNT);\n\n\tif (n < LETTERS_CNT) {\n\t\treturn String.fromCharCode(CharCode.a + n);\n\t}\n\n\treturn String.fromCharCode(CharCode.A + n - LETTERS_CNT);\n}\n\n//#region Unicode Grapheme Break\n\nexport function getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\tconst graphemeBreakTree = GraphemeBreakTree.getInstance();\n\treturn graphemeBreakTree.getGraphemeBreakType(codePoint);\n}\n\nfunction breakBetweenGraphemeBreakType(breakTypeA: GraphemeBreakType, breakTypeB: GraphemeBreakType): boolean {\n\t// http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n\n\t// !!! Let's make the common case a bit faster\n\tif (breakTypeA === GraphemeBreakType.Other) {\n\t\t// see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n\t\treturn (breakTypeB !== GraphemeBreakType.Extend && breakTypeB !== GraphemeBreakType.SpacingMark);\n\t}\n\n\t// Do not break between a CR and LF. Otherwise, break before and after controls.\n\t// GB3                                        CR × LF\n\t// GB4                       (Control | CR | LF) ÷\n\t// GB5                                           ÷ (Control | CR | LF)\n\tif (breakTypeA === GraphemeBreakType.CR) {\n\t\tif (breakTypeB === GraphemeBreakType.LF) {\n\t\t\treturn false; // GB3\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.Control || breakTypeA === GraphemeBreakType.CR || breakTypeA === GraphemeBreakType.LF) {\n\t\treturn true; // GB4\n\t}\n\tif (breakTypeB === GraphemeBreakType.Control || breakTypeB === GraphemeBreakType.CR || breakTypeB === GraphemeBreakType.LF) {\n\t\treturn true; // GB5\n\t}\n\n\t// Do not break Hangul syllable sequences.\n\t// GB6                                         L × (L | V | LV | LVT)\n\t// GB7                                  (LV | V) × (V | T)\n\t// GB8                                 (LVT | T) × T\n\tif (breakTypeA === GraphemeBreakType.L) {\n\t\tif (breakTypeB === GraphemeBreakType.L || breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.LV || breakTypeB === GraphemeBreakType.LVT) {\n\t\t\treturn false; // GB6\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LV || breakTypeA === GraphemeBreakType.V) {\n\t\tif (breakTypeB === GraphemeBreakType.V || breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB7\n\t\t}\n\t}\n\tif (breakTypeA === GraphemeBreakType.LVT || breakTypeA === GraphemeBreakType.T) {\n\t\tif (breakTypeB === GraphemeBreakType.T) {\n\t\t\treturn false; // GB8\n\t\t}\n\t}\n\n\t// Do not break before extending characters or ZWJ.\n\t// GB9                                           × (Extend | ZWJ)\n\tif (breakTypeB === GraphemeBreakType.Extend || breakTypeB === GraphemeBreakType.ZWJ) {\n\t\treturn false; // GB9\n\t}\n\n\t// The GB9a and GB9b rules only apply to extended grapheme clusters:\n\t// Do not break before SpacingMarks, or after Prepend characters.\n\t// GB9a                                          × SpacingMark\n\t// GB9b                                  Prepend ×\n\tif (breakTypeB === GraphemeBreakType.SpacingMark) {\n\t\treturn false; // GB9a\n\t}\n\tif (breakTypeA === GraphemeBreakType.Prepend) {\n\t\treturn false; // GB9b\n\t}\n\n\t// Do not break within emoji modifier sequences or emoji zwj sequences.\n\t// GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n\tif (breakTypeA === GraphemeBreakType.ZWJ && breakTypeB === GraphemeBreakType.Extended_Pictographic) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB11\n\t}\n\n\t// GB12                          sot (RI RI)* RI × RI\n\t// GB13                        [^RI] (RI RI)* RI × RI\n\tif (breakTypeA === GraphemeBreakType.Regional_Indicator && breakTypeB === GraphemeBreakType.Regional_Indicator) {\n\t\t// Note: we are not implementing the rule entirely here to avoid introducing states\n\t\treturn false; // GB12 & GB13\n\t}\n\n\t// GB999                                     Any ÷ Any\n\treturn true;\n}\n\nexport const enum GraphemeBreakType {\n\tOther = 0,\n\tPrepend = 1,\n\tCR = 2,\n\tLF = 3,\n\tControl = 4,\n\tExtend = 5,\n\tRegional_Indicator = 6,\n\tSpacingMark = 7,\n\tL = 8,\n\tV = 9,\n\tT = 10,\n\tLV = 11,\n\tLVT = 12,\n\tZWJ = 13,\n\tExtended_Pictographic = 14\n}\n\nclass GraphemeBreakTree {\n\n\tprivate static _INSTANCE: GraphemeBreakTree | null = null;\n\tpublic static getInstance(): GraphemeBreakTree {\n\t\tif (!GraphemeBreakTree._INSTANCE) {\n\t\t\tGraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n\t\t}\n\t\treturn GraphemeBreakTree._INSTANCE;\n\t}\n\n\tprivate readonly _data: number[];\n\n\tconstructor() {\n\t\tthis._data = getGraphemeBreakRawData();\n\t}\n\n\tpublic getGraphemeBreakType(codePoint: number): GraphemeBreakType {\n\t\t// !!! Let's make 7bit ASCII a bit faster: 0..31\n\t\tif (codePoint < 32) {\n\t\t\tif (codePoint === CharCode.LineFeed) {\n\t\t\t\treturn GraphemeBreakType.LF;\n\t\t\t}\n\t\t\tif (codePoint === CharCode.CarriageReturn) {\n\t\t\t\treturn GraphemeBreakType.CR;\n\t\t\t}\n\t\t\treturn GraphemeBreakType.Control;\n\t\t}\n\t\t// !!! Let's make 7bit ASCII a bit faster: 32..126\n\t\tif (codePoint < 127) {\n\t\t\treturn GraphemeBreakType.Other;\n\t\t}\n\n\t\tconst data = this._data;\n\t\tconst nodeCount = data.length / 3;\n\t\tlet nodeIndex = 1;\n\t\twhile (nodeIndex <= nodeCount) {\n\t\t\tif (codePoint < data[3 * nodeIndex]) {\n\t\t\t\t// go left\n\t\t\t\tnodeIndex = 2 * nodeIndex;\n\t\t\t} else if (codePoint > data[3 * nodeIndex + 1]) {\n\t\t\t\t// go right\n\t\t\t\tnodeIndex = 2 * nodeIndex + 1;\n\t\t\t} else {\n\t\t\t\t// hit\n\t\t\t\treturn data[3 * nodeIndex + 2];\n\t\t\t}\n\t\t}\n\n\t\treturn GraphemeBreakType.Other;\n\t}\n}\n\nfunction getGraphemeBreakRawData(): number[] {\n\t// generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n\treturn JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n\n//#endregion\n\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nexport function getLeftDeleteOffset(offset: number, str: string): number {\n\tif (offset === 0) {\n\t\treturn 0;\n\t}\n\n\t// Try to delete emoji part.\n\tconst emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n\tif (emojiOffset !== undefined) {\n\t\treturn emojiOffset;\n\t}\n\n\t// Otherwise, just skip a single code point.\n\tconst iterator = new CodePointIterator(str, offset);\n\titerator.prevCodePoint();\n\treturn iterator.offset;\n}\n\nfunction getOffsetBeforeLastEmojiComponent(initialOffset: number, str: string): number | undefined {\n\t// See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n\t// structure of emojis.\n\tconst iterator = new CodePointIterator(str, initialOffset);\n\tlet codePoint = iterator.prevCodePoint();\n\n\t// Skip modifiers\n\twhile ((isEmojiModifier(codePoint) || codePoint === CodePoint.emojiVariantSelector || codePoint === CodePoint.enclosingKeyCap)) {\n\t\tif (iterator.offset === 0) {\n\t\t\t// Cannot skip modifier, no preceding emoji base.\n\t\t\treturn undefined;\n\t\t}\n\t\tcodePoint = iterator.prevCodePoint();\n\t}\n\n\t// Expect base emoji\n\tif (!isEmojiImprecise(codePoint)) {\n\t\t// Unexpected code point, not a valid emoji.\n\t\treturn undefined;\n\t}\n\n\tlet resultOffset = iterator.offset;\n\n\tif (resultOffset > 0) {\n\t\t// Skip optional ZWJ code points that combine multiple emojis.\n\t\t// In theory, we should check if that ZWJ actually combines multiple emojis\n\t\t// to prevent deleting ZWJs in situations we didn't account for.\n\t\tconst optionalZwjCodePoint = iterator.prevCodePoint();\n\t\tif (optionalZwjCodePoint === CodePoint.zwj) {\n\t\t\tresultOffset = iterator.offset;\n\t\t}\n\t}\n\n\treturn resultOffset;\n}\n\nfunction isEmojiModifier(codePoint: number): boolean {\n\treturn 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\n\nconst enum CodePoint {\n\tzwj = 0x200D,\n\n\t/**\n\t * Variation Selector-16 (VS16)\n\t*/\n\temojiVariantSelector = 0xFE0F,\n\n\t/**\n\t * Combining Enclosing Keycap\n\t */\n\tenclosingKeyCap = 0x20E3,\n}\n\nexport const noBreakWhitespace = '\\xa0';\n\nexport class AmbiguousCharacters {\n\tprivate static readonly ambiguousCharacterData = new Lazy<\n\t\tRecord<\n\t\t\tstring | '_common' | '_default',\n\t\t\t/* code point -> ascii code point */ number[]\n\t\t>\n\t>(() => {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\t// Stored as key1, value1, key2, value2, ...\n\t\treturn JSON.parse(\n\t\t\t'{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],\\\"_default\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"cs\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"fr\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ja\\\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\\\"ko\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ru\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"zh-hans\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\\\"zh-hant\\\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'\n\t\t);\n\t});\n\n\tprivate static readonly cache = new LRUCachedFunction<\n\t\tstring[],\n\t\tAmbiguousCharacters\n\t>((locales) => {\n\t\tfunction arrayToMap(arr: number[]): Map<number, number> {\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (let i = 0; i < arr.length; i += 2) {\n\t\t\t\tresult.set(arr[i], arr[i + 1]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction mergeMaps(\n\t\t\tmap1: Map<number, number>,\n\t\t\tmap2: Map<number, number>\n\t\t): Map<number, number> {\n\t\t\tconst result = new Map<number, number>(map1);\n\t\t\tfor (const [key, value] of map2) {\n\t\t\t\tresult.set(key, value);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction intersectMaps(\n\t\t\tmap1: Map<number, number> | undefined,\n\t\t\tmap2: Map<number, number>\n\t\t) {\n\t\t\tif (!map1) {\n\t\t\t\treturn map2;\n\t\t\t}\n\t\t\tconst result = new Map<number, number>();\n\t\t\tfor (const [key, value] of map1) {\n\t\t\t\tif (map2.has(key)) {\n\t\t\t\t\tresult.set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tconst data = this.ambiguousCharacterData.getValue();\n\n\t\tlet filteredLocales = locales.filter(\n\t\t\t(l) => !l.startsWith('_') && l in data\n\t\t);\n\t\tif (filteredLocales.length === 0) {\n\t\t\tfilteredLocales = ['_default'];\n\t\t}\n\n\t\tlet languageSpecificMap: Map<number, number> | undefined = undefined;\n\t\tfor (const locale of filteredLocales) {\n\t\t\tconst map = arrayToMap(data[locale]);\n\t\t\tlanguageSpecificMap = intersectMaps(languageSpecificMap, map);\n\t\t}\n\n\t\tconst commonMap = arrayToMap(data['_common']);\n\t\tconst map = mergeMaps(commonMap, languageSpecificMap!);\n\n\t\treturn new AmbiguousCharacters(map);\n\t});\n\n\tpublic static getInstance(locales: Set<string>): AmbiguousCharacters {\n\t\treturn AmbiguousCharacters.cache.get(Array.from(locales));\n\t}\n\n\tprivate static _locales = new Lazy<string[]>(() =>\n\t\tObject.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter(\n\t\t\t(k) => !k.startsWith('_')\n\t\t)\n\t);\n\tpublic static getLocales(): string[] {\n\t\treturn AmbiguousCharacters._locales.getValue();\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly confusableDictionary: Map<number, number>\n\t) { }\n\n\tpublic isAmbiguous(codePoint: number): boolean {\n\t\treturn this.confusableDictionary.has(codePoint);\n\t}\n\n\t/**\n\t * Returns the non basic ASCII code point that the given code point can be confused,\n\t * or undefined if such code point does note exist.\n\t */\n\tpublic getPrimaryConfusable(codePoint: number): number | undefined {\n\t\treturn this.confusableDictionary.get(codePoint);\n\t}\n\n\tpublic getConfusableCodePoints(): ReadonlySet<number> {\n\t\treturn new Set(this.confusableDictionary.keys());\n\t}\n}\n\nexport class InvisibleCharacters {\n\tprivate static getRawData(): number[] {\n\t\t// Generated using https://github.com/hediet/vscode-unicode-data\n\t\treturn JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');\n\t}\n\n\tprivate static _data: Set<number> | undefined = undefined;\n\n\tprivate static getData() {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Set(InvisibleCharacters.getRawData());\n\t\t}\n\t\treturn this._data;\n\t}\n\n\tpublic static isInvisibleCharacter(codePoint: number): boolean {\n\t\treturn InvisibleCharacters.getData().has(codePoint);\n\t}\n\n\tpublic static get codePoints(): ReadonlySet<number> {\n\t\treturn InvisibleCharacters.getData();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { shuffle } from 'vs/base/common/arrays';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compare, compareIgnoreCase, compareSubstring, compareSubstringIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport interface IKeyIterator<K> {\n\treset(key: K): this;\n\tnext(): this;\n\n\thasNext(): boolean;\n\tcmp(a: string): number;\n\tvalue(): string;\n}\n\nexport class StringIterator implements IKeyIterator<string> {\n\n\tprivate _value: string = '';\n\tprivate _pos: number = 0;\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._pos = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tthis._pos += 1;\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._pos < this._value.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tconst aCode = a.charCodeAt(0);\n\t\tconst thisCode = this._value.charCodeAt(this._pos);\n\t\treturn aCode - thisCode;\n\t}\n\n\tvalue(): string {\n\t\treturn this._value[this._pos];\n\t}\n}\n\nexport class ConfigKeysIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._value = key;\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._value.length;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._value.length; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Period) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n\tprivate _value!: string;\n\tprivate _valueLen!: number;\n\tprivate _from!: number;\n\tprivate _to!: number;\n\n\tconstructor(\n\t\tprivate readonly _splitOnBackslash: boolean = true,\n\t\tprivate readonly _caseSensitive: boolean = true\n\t) { }\n\n\treset(key: string): this {\n\t\tthis._from = 0;\n\t\tthis._to = 0;\n\t\tthis._value = key;\n\t\tthis._valueLen = key.length;\n\t\tfor (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {\n\t\t\tconst ch = this._value.charCodeAt(pos);\n\t\t\tif (!(ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this.next();\n\t}\n\n\thasNext(): boolean {\n\t\treturn this._to < this._valueLen;\n\t}\n\n\tnext(): this {\n\t\t// this._data = key.split(/[\\\\/]/).filter(s => !!s);\n\t\tthis._from = this._to;\n\t\tlet justSeps = true;\n\t\tfor (; this._to < this._valueLen; this._to++) {\n\t\t\tconst ch = this._value.charCodeAt(this._to);\n\t\t\tif (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n\t\t\t\tif (justSeps) {\n\t\t\t\t\tthis._from++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjustSeps = false;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tcmp(a: string): number {\n\t\treturn this._caseSensitive\n\t\t\t? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n\t\t\t: compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n\t}\n\n\tvalue(): string {\n\t\treturn this._value.substring(this._from, this._to);\n\t}\n}\n\nconst enum UriIteratorState {\n\tScheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n\tprivate _pathIterator!: PathIterator;\n\tprivate _value!: URI;\n\tprivate _states: UriIteratorState[] = [];\n\tprivate _stateIdx: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _ignorePathCasing: (uri: URI) => boolean,\n\t\tprivate readonly _ignoreQueryAndFragment: (uri: URI) => boolean) { }\n\n\treset(key: URI): this {\n\t\tthis._value = key;\n\t\tthis._states = [];\n\t\tif (this._value.scheme) {\n\t\t\tthis._states.push(UriIteratorState.Scheme);\n\t\t}\n\t\tif (this._value.authority) {\n\t\t\tthis._states.push(UriIteratorState.Authority);\n\t\t}\n\t\tif (this._value.path) {\n\t\t\tthis._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n\t\t\tthis._pathIterator.reset(key.path);\n\t\t\tif (this._pathIterator.value()) {\n\t\t\t\tthis._states.push(UriIteratorState.Path);\n\t\t\t}\n\t\t}\n\t\tif (!this._ignoreQueryAndFragment(key)) {\n\t\t\tif (this._value.query) {\n\t\t\t\tthis._states.push(UriIteratorState.Query);\n\t\t\t}\n\t\t\tif (this._value.fragment) {\n\t\t\t\tthis._states.push(UriIteratorState.Fragment);\n\t\t\t}\n\t\t}\n\t\tthis._stateIdx = 0;\n\t\treturn this;\n\t}\n\n\tnext(): this {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n\t\t\tthis._pathIterator.next();\n\t\t} else {\n\t\t\tthis._stateIdx += 1;\n\t\t}\n\t\treturn this;\n\t}\n\n\thasNext(): boolean {\n\t\treturn (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n\t\t\t|| this._stateIdx < this._states.length - 1;\n\t}\n\n\tcmp(a: string): number {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn compareIgnoreCase(a, this._value.scheme);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn compareIgnoreCase(a, this._value.authority);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.cmp(a);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn compare(a, this._value.query);\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn compare(a, this._value.fragment);\n\t\t}\n\t\tthrow new Error();\n\t}\n\n\tvalue(): string {\n\t\tif (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n\t\t\treturn this._value.scheme;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n\t\t\treturn this._value.authority;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n\t\t\treturn this._pathIterator.value();\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n\t\t\treturn this._value.query;\n\t\t} else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n\t\t\treturn this._value.fragment;\n\t\t}\n\t\tthrow new Error();\n\t}\n}\n\nclass TernarySearchTreeNode<K, V> {\n\theight: number = 1;\n\tsegment!: string;\n\tvalue: V | undefined;\n\tkey: K | undefined;\n\tleft: TernarySearchTreeNode<K, V> | undefined;\n\tmid: TernarySearchTreeNode<K, V> | undefined;\n\tright: TernarySearchTreeNode<K, V> | undefined;\n\n\tisEmpty(): boolean {\n\t\treturn !this.left && !this.mid && !this.right && !this.value;\n\t}\n\n\trotateLeft() {\n\t\tconst tmp = this.right!;\n\t\tthis.right = tmp.left;\n\t\ttmp.left = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\trotateRight() {\n\t\tconst tmp = this.left!;\n\t\tthis.left = tmp.right;\n\t\ttmp.right = this;\n\t\tthis.updateHeight();\n\t\ttmp.updateHeight();\n\t\treturn tmp;\n\t}\n\n\tupdateHeight() {\n\t\tthis.height = 1 + Math.max(this.heightLeft, this.heightRight);\n\t}\n\n\tbalanceFactor() {\n\t\treturn this.heightRight - this.heightLeft;\n\t}\n\n\tget heightLeft() {\n\t\treturn this.left?.height ?? 0;\n\t}\n\n\tget heightRight() {\n\t\treturn this.right?.height ?? 0;\n\t}\n}\n\nconst enum Dir {\n\tLeft = -1,\n\tMid = 0,\n\tRight = 1,\n}\n\nexport class TernarySearchTree<K, V> {\n\n\tstatic forUris<E>(ignorePathCasing: (key: URI) => boolean = () => false, ignoreQueryAndFragment: (key: URI) => boolean = () => false): TernarySearchTree<URI, E> {\n\t\treturn new TernarySearchTree<URI, E>(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));\n\t}\n\n\tstatic forPaths<E>(ignorePathCasing = false): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new PathIterator(undefined, !ignorePathCasing));\n\t}\n\n\tstatic forStrings<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new StringIterator());\n\t}\n\n\tstatic forConfigKeys<E>(): TernarySearchTree<string, E> {\n\t\treturn new TernarySearchTree<string, E>(new ConfigKeysIterator());\n\t}\n\n\tprivate _iter: IKeyIterator<K>;\n\tprivate _root: TernarySearchTreeNode<K, V> | undefined;\n\n\tconstructor(segments: IKeyIterator<K>) {\n\t\tthis._iter = segments;\n\t}\n\n\tclear(): void {\n\t\tthis._root = undefined;\n\t}\n\n\t/**\n\t * Fill the tree with the same value of the given keys\n\t */\n\tfill(element: V, keys: readonly K[]): void;\n\t/**\n\t * Fill the tree with given [key,value]-tuples\n\t */\n\tfill(values: readonly [K, V][]): void;\n\tfill(values: readonly [K, V][] | V, keys?: readonly K[]): void {\n\t\tif (keys) {\n\t\t\tconst arr = keys.slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const k of arr) {\n\t\t\t\tthis.set(k, (<V>values));\n\t\t\t}\n\t\t} else {\n\t\t\tconst arr = (<[K, V][]>values).slice(0);\n\t\t\tshuffle(arr);\n\t\t\tfor (const entry of arr) {\n\t\t\t\tthis.set(entry[0], entry[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key: K, element: V): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node: TernarySearchTreeNode<K, V>;\n\n\t\tif (!this._root) {\n\t\t\tthis._root = new TernarySearchTreeNode<K, V>();\n\t\t\tthis._root.segment = iter.value();\n\t\t}\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\n\t\t// find insert_node\n\t\tnode = this._root;\n\t\twhile (true) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tif (!node.left) {\n\t\t\t\t\tnode.left = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.left.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tif (!node.right) {\n\t\t\t\t\tnode.right = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.right.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\tnode.mid = new TernarySearchTreeNode<K, V>();\n\t\t\t\t\tnode.mid.segment = iter.value();\n\t\t\t\t}\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// set value\n\t\tconst oldElement = node.value;\n\t\tnode.value = element;\n\t\tnode.key = key;\n\n\t\t// balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\t// needs rotate\n\t\t\t\tconst d1 = stack[i][0];\n\t\t\t\tconst d2 = stack[i + 1][0];\n\n\t\t\t\tif (d1 === Dir.Right && d2 === Dir.Right) {\n\t\t\t\t\t//right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Left) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else if (d1 === Dir.Right && d2 === Dir.Left) {\n\t\t\t\t\t// right, left -> double rotate right, left\n\t\t\t\t\tnode.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\n\t\t\t\t} else if (d1 === Dir.Left && d2 === Dir.Right) {\n\t\t\t\t\t// left, right -> double rotate left, right\n\t\t\t\t\tnode.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\n\t\t\t\t// patch path to parent\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = stack[0][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn oldElement;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._getNode(key)?.value;\n\t}\n\n\tprivate _getNode(key: K) {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\thas(key: K): boolean {\n\t\tconst node = this._getNode(key);\n\t\treturn !(node?.value === undefined && node?.mid === undefined);\n\t}\n\n\tdelete(key: K): void {\n\t\treturn this._delete(key, false);\n\t}\n\n\tdeleteSuperstr(key: K): void {\n\t\treturn this._delete(key, true);\n\t}\n\n\tprivate _delete(key: K, superStr: boolean): void {\n\t\tconst iter = this._iter.reset(key);\n\t\tconst stack: [Dir, TernarySearchTreeNode<K, V>][] = [];\n\t\tlet node = this._root;\n\n\t\t// find node\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tstack.push([Dir.Left, node]);\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tstack.push([Dir.Right, node]);\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tstack.push([Dir.Mid, node]);\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!node) {\n\t\t\t// node not found\n\t\t\treturn;\n\t\t}\n\n\t\tif (superStr) {\n\t\t\t// removing children, reset height\n\t\t\tnode.left = undefined;\n\t\t\tnode.mid = undefined;\n\t\t\tnode.right = undefined;\n\t\t\tnode.height = 1;\n\t\t} else {\n\t\t\t// removing element\n\t\t\tnode.key = undefined;\n\t\t\tnode.value = undefined;\n\t\t}\n\n\t\t// BST node removal\n\t\tif (!node.mid && !node.value) {\n\t\t\tif (node.left && node.right) {\n\t\t\t\t// full node\n\t\t\t\tconst min = this._min(node.right);\n\t\t\t\tconst { key, value, segment } = min;\n\t\t\t\tthis._delete(min.key!, false);\n\t\t\t\tnode.key = key;\n\t\t\t\tnode.value = value;\n\t\t\t\tnode.segment = segment;\n\n\t\t\t} else {\n\t\t\t\t// empty or half empty\n\t\t\t\tconst newChild = node.left ?? node.right;\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tconst [dir, parent] = stack[stack.length - 1];\n\t\t\t\t\tswitch (dir) {\n\t\t\t\t\t\tcase Dir.Left: parent.left = newChild; break;\n\t\t\t\t\t\tcase Dir.Mid: parent.mid = newChild; break;\n\t\t\t\t\t\tcase Dir.Right: parent.right = newChild; break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._root = newChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// AVL balance\n\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\tconst node = stack[i][1];\n\n\t\t\tnode.updateHeight();\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf > 1) {\n\t\t\t\t// right heavy\n\t\t\t\tif (node.right!.balanceFactor() >= 0) {\n\t\t\t\t\t// right, right -> rotate left\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t} else {\n\t\t\t\t\t// right, left -> double rotate\n\t\t\t\t\tnode.right = node.right!.rotateRight();\n\t\t\t\t\tstack[i][1] = node.rotateLeft();\n\t\t\t\t}\n\n\t\t\t} else if (bf < -1) {\n\t\t\t\t// left heavy\n\t\t\t\tif (node.left!.balanceFactor() <= 0) {\n\t\t\t\t\t// left, left -> rotate right\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t} else {\n\t\t\t\t\t// left, right -> double rotate\n\t\t\t\t\tnode.left = node.left!.rotateLeft();\n\t\t\t\t\tstack[i][1] = node.rotateRight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch path to parent\n\t\t\tif (i > 0) {\n\t\t\t\tswitch (stack[i - 1][0]) {\n\t\t\t\t\tcase Dir.Left:\n\t\t\t\t\t\tstack[i - 1][1].left = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Right:\n\t\t\t\t\t\tstack[i - 1][1].right = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Dir.Mid:\n\t\t\t\t\t\tstack[i - 1][1].mid = stack[i][1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._root = stack[0][1];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _min(node: TernarySearchTreeNode<K, V>): TernarySearchTreeNode<K, V> {\n\t\twhile (node.left) {\n\t\t\tnode = node.left;\n\t\t}\n\t\treturn node;\n\t}\n\n\tfindSubstr(key: K): V | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\tlet candidate: V | undefined = undefined;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tcandidate = node.value || candidate;\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn node && node.value || candidate;\n\t}\n\n\tfindSuperstr(key: K): IterableIterator<[K, V]> | undefined {\n\t\tconst iter = this._iter.reset(key);\n\t\tlet node = this._root;\n\t\twhile (node) {\n\t\t\tconst val = iter.cmp(node.segment);\n\t\t\tif (val > 0) {\n\t\t\t\t// left\n\t\t\t\tnode = node.left;\n\t\t\t} else if (val < 0) {\n\t\t\t\t// right\n\t\t\t\tnode = node.right;\n\t\t\t} else if (iter.hasNext()) {\n\t\t\t\t// mid\n\t\t\t\titer.next();\n\t\t\t\tnode = node.mid;\n\t\t\t} else {\n\t\t\t\t// collect\n\t\t\t\tif (!node.mid) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\treturn this._entries(node.mid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tforEach(callback: (value: V, index: K) => any): void {\n\t\tfor (const [key, value] of this) {\n\t\t\tcallback(value, key);\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\tyield* this._entries(this._root);\n\t}\n\n\tprivate _entries(node: TernarySearchTreeNode<K, V> | undefined): IterableIterator<[K, V]> {\n\t\tconst result: [K, V][] = [];\n\t\tthis._dfsEntries(node, result);\n\t\treturn result[Symbol.iterator]();\n\t}\n\n\tprivate _dfsEntries(node: TernarySearchTreeNode<K, V> | undefined, bucket: [K, V][]) {\n\t\t// DFS\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tif (node.left) {\n\t\t\tthis._dfsEntries(node.left, bucket);\n\t\t}\n\t\tif (node.value) {\n\t\t\tbucket.push([node.key!, node.value]);\n\t\t}\n\t\tif (node.mid) {\n\t\t\tthis._dfsEntries(node.mid, bucket);\n\t\t}\n\t\tif (node.right) {\n\t\t\tthis._dfsEntries(node.right, bucket);\n\t\t}\n\t}\n\n\t// for debug/testing\n\t_isBalanced(): boolean {\n\t\tconst nodeIsBalanced = (node: TernarySearchTreeNode<any, any> | undefined): boolean => {\n\t\t\tif (!node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst bf = node.balanceFactor();\n\t\t\tif (bf < -1 || bf > 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn nodeIsBalanced(node.left) && nodeIsBalanced(node.right);\n\t\t};\n\t\treturn nodeIsBalanced(this._root);\n\t}\n}\n\ninterface ResourceMapKeyFn {\n\t(resource: URI): string;\n}\n\nclass ResourceMapEntry<T> {\n\tconstructor(readonly uri: URI, readonly value: T) { }\n}\n\nexport class ResourceMap<T> implements Map<URI, T> {\n\n\tprivate static readonly defaultToKey = (resource: URI) => resource.toString();\n\n\treadonly [Symbol.toStringTag] = 'ResourceMap';\n\n\tprivate readonly map: Map<string, ResourceMapEntry<T>>;\n\tprivate readonly toKey: ResourceMapKeyFn;\n\n\t/**\n\t *\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(toKey?: ResourceMapKeyFn);\n\n\t/**\n\t *\n\t * @param other Another resource which this maps is created from\n\t * @param toKey Custom uri identity function, e.g use an existing `IExtUri#getComparison`-util\n\t */\n\tconstructor(other?: ResourceMap<T>, toKey?: ResourceMapKeyFn);\n\n\tconstructor(mapOrKeyFn?: ResourceMap<T> | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (mapOrKeyFn instanceof ResourceMap) {\n\t\t\tthis.map = new Map(mapOrKeyFn.map);\n\t\t\tthis.toKey = toKey ?? ResourceMap.defaultToKey;\n\t\t} else {\n\t\t\tthis.map = new Map();\n\t\t\tthis.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;\n\t\t}\n\t}\n\n\tset(resource: URI, value: T): this {\n\t\tthis.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n\t\treturn this;\n\t}\n\n\tget(resource: URI): T | undefined {\n\t\treturn this.map.get(this.toKey(resource))?.value;\n\t}\n\n\thas(resource: URI): boolean {\n\t\treturn this.map.has(this.toKey(resource));\n\t}\n\n\tget size(): number {\n\t\treturn this.map.size;\n\t}\n\n\tclear(): void {\n\t\tthis.map.clear();\n\t}\n\n\tdelete(resource: URI): boolean {\n\t\treturn this.map.delete(this.toKey(resource));\n\t}\n\n\tforEach(clb: (value: T, key: URI, map: Map<URI, T>) => void, thisArg?: any): void {\n\t\tif (typeof thisArg !== 'undefined') {\n\t\t\tclb = clb.bind(thisArg);\n\t\t}\n\t\tfor (const [_, entry] of this.map) {\n\t\t\tclb(entry.value, entry.uri, <any>this);\n\t\t}\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.value;\n\t\t}\n\t}\n\n\t*keys(): IterableIterator<URI> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield entry.uri;\n\t\t}\n\t}\n\n\t*entries(): IterableIterator<[URI, T]> {\n\t\tfor (const entry of this.map.values()) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n\n\t*[Symbol.iterator](): IterableIterator<[URI, T]> {\n\t\tfor (const [, entry] of this.map) {\n\t\t\tyield [entry.uri, entry.value];\n\t\t}\n\t}\n}\n\nexport class ResourceSet implements Set<URI> {\n\n\treadonly [Symbol.toStringTag]: string = 'ResourceSet';\n\n\tprivate readonly _map: ResourceMap<URI>;\n\n\tconstructor(toKey?: ResourceMapKeyFn);\n\tconstructor(entries: readonly URI[], toKey?: ResourceMapKeyFn);\n\tconstructor(entriesOrKey?: readonly URI[] | ResourceMapKeyFn, toKey?: ResourceMapKeyFn) {\n\t\tif (!entriesOrKey || typeof entriesOrKey === 'function') {\n\t\t\tthis._map = new ResourceMap(entriesOrKey);\n\t\t} else {\n\t\t\tthis._map = new ResourceMap(toKey);\n\t\t\tentriesOrKey.forEach(this.add, this);\n\t\t}\n\t}\n\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: URI): this {\n\t\tthis._map.set(value, value);\n\t\treturn this;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tdelete(value: URI): boolean {\n\t\treturn this._map.delete(value);\n\t}\n\n\tforEach(callbackfn: (value: URI, value2: URI, set: Set<URI>) => void, thisArg?: any): void {\n\t\tthis._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n\t}\n\n\thas(value: URI): boolean {\n\t\treturn this._map.has(value);\n\t}\n\n\tentries(): IterableIterator<[URI, URI]> {\n\t\treturn this._map.entries();\n\t}\n\n\tkeys(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\tvalues(): IterableIterator<URI> {\n\t\treturn this._map.keys();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<URI> {\n\t\treturn this.keys();\n\t}\n}\n\n\ninterface Item<K, V> {\n\tprevious: Item<K, V> | undefined;\n\tnext: Item<K, V> | undefined;\n\tkey: K;\n\tvalue: V;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class LinkedMap<K, V> implements Map<K, V> {\n\n\treadonly [Symbol.toStringTag] = 'LinkedMap';\n\n\tprivate _map: Map<K, Item<K, V>>;\n\tprivate _head: Item<K, V> | undefined;\n\tprivate _tail: Item<K, V> | undefined;\n\tprivate _size: number;\n\n\tprivate _state: number;\n\n\tconstructor() {\n\t\tthis._map = new Map<K, Item<K, V>>();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state = 0;\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t\tthis._state++;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn !this._head && !this._tail;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tget first(): V | undefined {\n\t\treturn this._head?.value;\n\t}\n\n\tget last(): V | undefined {\n\t\treturn this._tail?.value;\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._map.has(key);\n\t}\n\n\tget(key: K, touch: Touch = Touch.None): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (touch !== Touch.None) {\n\t\t\tthis.touch(item, touch);\n\t\t}\n\t\treturn item.value;\n\t}\n\n\tset(key: K, value: V, touch: Touch = Touch.None): this {\n\t\tlet item = this._map.get(key);\n\t\tif (item) {\n\t\t\titem.value = value;\n\t\t\tif (touch !== Touch.None) {\n\t\t\t\tthis.touch(item, touch);\n\t\t\t}\n\t\t} else {\n\t\t\titem = { key, value, next: undefined, previous: undefined };\n\t\t\tswitch (touch) {\n\t\t\t\tcase Touch.None:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsOld:\n\t\t\t\t\tthis.addItemFirst(item);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Touch.AsNew:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addItemLast(item);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._map.set(key, item);\n\t\t\tthis._size++;\n\t\t}\n\t\treturn this;\n\t}\n\n\tdelete(key: K): boolean {\n\t\treturn !!this.remove(key);\n\t}\n\n\tremove(key: K): V | undefined {\n\t\tconst item = this._map.get(key);\n\t\tif (!item) {\n\t\t\treturn undefined;\n\t\t}\n\t\tthis._map.delete(key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tshift(): V | undefined {\n\t\tif (!this._head && !this._tail) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tconst item = this._head;\n\t\tthis._map.delete(item.key);\n\t\tthis.removeItem(item);\n\t\tthis._size--;\n\t\treturn item.value;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: LinkedMap<K, V>) => void, thisArg?: any): void {\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\twhile (current) {\n\t\t\tif (thisArg) {\n\t\t\t\tcallbackfn.bind(thisArg)(current.value, current.key, this);\n\t\t\t} else {\n\t\t\t\tcallbackfn(current.value, current.key, this);\n\t\t\t}\n\t\t\tif (this._state !== state) {\n\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<K> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<K> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.key, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<V> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<V> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result = { value: current.value, done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\tconst map = this;\n\t\tconst state = this._state;\n\t\tlet current = this._head;\n\t\tconst iterator: IterableIterator<[K, V]> = {\n\t\t\t[Symbol.iterator]() {\n\t\t\t\treturn iterator;\n\t\t\t},\n\t\t\tnext(): IteratorResult<[K, V]> {\n\t\t\t\tif (map._state !== state) {\n\t\t\t\t\tthrow new Error(`LinkedMap got modified during iteration.`);\n\t\t\t\t}\n\t\t\t\tif (current) {\n\t\t\t\t\tconst result: IteratorResult<[K, V]> = { value: [current.key, current.value], done: false };\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true };\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn iterator;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.entries();\n\t}\n\n\tprotected trimOld(newSize: number) {\n\t\tif (newSize >= this.size) {\n\t\t\treturn;\n\t\t}\n\t\tif (newSize === 0) {\n\t\t\tthis.clear();\n\t\t\treturn;\n\t\t}\n\t\tlet current = this._head;\n\t\tlet currentSize = this.size;\n\t\twhile (current && currentSize > newSize) {\n\t\t\tthis._map.delete(current.key);\n\t\t\tcurrent = current.next;\n\t\t\tcurrentSize--;\n\t\t}\n\t\tthis._head = current;\n\t\tthis._size = currentSize;\n\t\tif (current) {\n\t\t\tcurrent.previous = undefined;\n\t\t}\n\t\tthis._state++;\n\t}\n\n\tprivate addItemFirst(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._tail = item;\n\t\t} else if (!this._head) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t}\n\t\tthis._head = item;\n\t\tthis._state++;\n\t}\n\n\tprivate addItemLast(item: Item<K, V>): void {\n\t\t// First time Insert\n\t\tif (!this._head && !this._tail) {\n\t\t\tthis._head = item;\n\t\t} else if (!this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t} else {\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t}\n\t\tthis._tail = item;\n\t\tthis._state++;\n\t}\n\n\tprivate removeItem(item: Item<K, V>): void {\n\t\tif (item === this._head && item === this._tail) {\n\t\t\tthis._head = undefined;\n\t\t\tthis._tail = undefined;\n\t\t}\n\t\telse if (item === this._head) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.next) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.next.previous = undefined;\n\t\t\tthis._head = item.next;\n\t\t}\n\t\telse if (item === this._tail) {\n\t\t\t// This can only happen if size === 1 which is handled\n\t\t\t// by the case above.\n\t\t\tif (!item.previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\titem.previous.next = undefined;\n\t\t\tthis._tail = item.previous;\n\t\t}\n\t\telse {\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\t\t\tif (!next || !previous) {\n\t\t\t\tthrow new Error('Invalid list');\n\t\t\t}\n\t\t\tnext.previous = previous;\n\t\t\tprevious.next = next;\n\t\t}\n\t\titem.next = undefined;\n\t\titem.previous = undefined;\n\t\tthis._state++;\n\t}\n\n\tprivate touch(item: Item<K, V>, touch: Touch): void {\n\t\tif (!this._head || !this._tail) {\n\t\t\tthrow new Error('Invalid list');\n\t\t}\n\t\tif ((touch !== Touch.AsOld && touch !== Touch.AsNew)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (touch === Touch.AsOld) {\n\t\t\tif (item === this._head) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item\n\t\t\tif (item === this._tail) {\n\t\t\t\t// previous must be defined since item was not head but is tail\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tprevious!.next = undefined;\n\t\t\t\tthis._tail = previous;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\n\t\t\t// Insert the node at head\n\t\t\titem.previous = undefined;\n\t\t\titem.next = this._head;\n\t\t\tthis._head.previous = item;\n\t\t\tthis._head = item;\n\t\t\tthis._state++;\n\t\t} else if (touch === Touch.AsNew) {\n\t\t\tif (item === this._tail) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = item.next;\n\t\t\tconst previous = item.previous;\n\n\t\t\t// Unlink the item.\n\t\t\tif (item === this._head) {\n\t\t\t\t// next must be defined since item was not tail but is head\n\t\t\t\t// So there are more than on item in the map\n\t\t\t\tnext!.previous = undefined;\n\t\t\t\tthis._head = next;\n\t\t\t} else {\n\t\t\t\t// Both next and previous are not undefined since item was neither head nor tail.\n\t\t\t\tnext!.previous = previous;\n\t\t\t\tprevious!.next = next;\n\t\t\t}\n\t\t\titem.next = undefined;\n\t\t\titem.previous = this._tail;\n\t\t\tthis._tail.next = item;\n\t\t\tthis._tail = item;\n\t\t\tthis._state++;\n\t\t}\n\t}\n\n\ttoJSON(): [K, V][] {\n\t\tconst data: [K, V][] = [];\n\n\t\tthis.forEach((value, key) => {\n\t\t\tdata.push([key, value]);\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tfromJSON(data: [K, V][]): void {\n\t\tthis.clear();\n\n\t\tfor (const [key, value] of data) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t}\n}\n\nexport class LRUCache<K, V> extends LinkedMap<K, V> {\n\n\tprivate _limit: number;\n\tprivate _ratio: number;\n\n\tconstructor(limit: number, ratio: number = 1) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t}\n\n\tget limit(): number {\n\t\treturn this._limit;\n\t}\n\n\tset limit(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis.checkTrim();\n\t}\n\n\tget ratio(): number {\n\t\treturn this._ratio;\n\t}\n\n\tset ratio(ratio: number) {\n\t\tthis._ratio = Math.min(Math.max(0, ratio), 1);\n\t\tthis.checkTrim();\n\t}\n\n\toverride get(key: K, touch: Touch = Touch.AsNew): V | undefined {\n\t\treturn super.get(key, touch);\n\t}\n\n\tpeek(key: K): V | undefined {\n\t\treturn super.get(key, Touch.None);\n\t}\n\n\toverride set(key: K, value: V): this {\n\t\tsuper.set(key, value, Touch.AsNew);\n\t\tthis.checkTrim();\n\t\treturn this;\n\t}\n\n\tprivate checkTrim() {\n\t\tif (this.size > this._limit) {\n\t\t\tthis.trimOld(Math.round(this._limit * this._ratio));\n\t\t}\n\t}\n}\n\n/**\n * Wraps the map in type that only implements readonly properties. Useful\n * in the extension host to prevent the consumer from making any mutations.\n */\nexport class ReadonlyMapView<K, V> implements ReadonlyMap<K, V>{\n\treadonly #source: ReadonlyMap<K, V>;\n\n\tpublic get size() {\n\t\treturn this.#source.size;\n\t}\n\n\tconstructor(source: ReadonlyMap<K, V>) {\n\t\tthis.#source = source;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void, thisArg?: any): void {\n\t\tthis.#source.forEach(callbackfn, thisArg);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this.#source.get(key);\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this.#source.has(key);\n\t}\n\n\tentries(): IterableIterator<[K, V]> {\n\t\treturn this.#source.entries();\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this.#source.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this.#source.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this.#source.entries();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LRUCache } from 'vs/base/common/map';\n\nconst nfcCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\treturn normalize(str, 'NFC', nfcCache);\n}\n\nconst nfdCache = new LRUCache<string, string>(10000); // bounded to 10000 elements\nexport function normalizeNFD(str: string): string {\n\treturn normalize(str, 'NFD', nfdCache);\n}\n\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nfunction normalize(str: string, form: string, normalizedCache: LRUCache<string, string>): string {\n\tif (!str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = str.normalize(form);\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n\nexport const removeAccents: (str: string) => string = (function () {\n\t// transform into NFD form and remove accents\n\t// see: https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript/37511463#37511463\n\tconst regex = /[\\u0300-\\u036f]/g;\n\treturn function (str: string) {\n\t\treturn normalizeNFD(str).replace(regex, '');\n\t};\n})();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray(array: any): array is any[] {\n\treturn Array.isArray(array);\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: unknown): str is string {\n\treturn (typeof str === 'string');\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: unknown): value is string[] {\n\treturn Array.isArray(value) && (<unknown[]>value).every(elem => isString(elem));\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: unknown): obj is Object {\n\t// The method can't do a type cast since there are type (like strings) which\n\t// are subclasses of any put not positvely matched by the function. Hence type\n\t// narrowing results in wrong results.\n\treturn typeof obj === 'object'\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nexport function isTypedArray(obj: unknown): obj is Object {\n\tconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\treturn typeof obj === 'object'\n\t\t&& obj instanceof TypedArray;\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: unknown): obj is number {\n\treturn (typeof obj === 'number' && !isNaN(obj));\n}\n\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nexport function isIterable<T>(obj: unknown): obj is Iterable<T> {\n\treturn !!obj && typeof (obj as any)[Symbol.iterator] === 'function';\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: unknown): obj is boolean {\n\treturn (obj === true || obj === false);\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: unknown): obj is undefined {\n\treturn (typeof obj === 'undefined');\n}\n\n/**\n * @returns whether the provided parameter is defined.\n */\nexport function isDefined<T>(arg: T | null | undefined): arg is T {\n\treturn !isUndefinedOrNull(arg);\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: unknown): obj is undefined | null {\n\treturn (isUndefined(obj) || obj === null);\n}\n\n\nexport function assertType(condition: unknown, type?: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n\t}\n}\n\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nexport function assertIsDefined<T>(arg: T | null | undefined): T {\n\tif (isUndefinedOrNull(arg)) {\n\t\tthrow new Error('Assertion Failed: argument is undefined or null');\n\t}\n\n\treturn arg;\n}\n\n/**\n * Asserts that each argument passed in is neither undefined nor null.\n */\nexport function assertAllDefined<T1, T2>(t1: T1 | null | undefined, t2: T2 | null | undefined): [T1, T2];\nexport function assertAllDefined<T1, T2, T3>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined): [T1, T2, T3];\nexport function assertAllDefined<T1, T2, T3, T4>(t1: T1 | null | undefined, t2: T2 | null | undefined, t3: T3 | null | undefined, t4: T4 | null | undefined): [T1, T2, T3, T4];\nexport function assertAllDefined(...args: (unknown | null | undefined)[]): unknown[] {\n\tconst result = [];\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\n\t\tif (isUndefinedOrNull(arg)) {\n\t\t\tthrow new Error(`Assertion Failed: argument at index ${i} is undefined or null`);\n\t\t}\n\n\t\tresult.push(arg);\n\t}\n\n\treturn result;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: unknown): obj is object {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (const key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: unknown): obj is Function {\n\treturn (typeof obj === 'function');\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: unknown[]): boolean {\n\treturn objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: unknown[], constraints: Array<TypeConstraint | undefined>): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: unknown, constraint: TypeConstraint | undefined): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\ttry {\n\t\t\tif (arg instanceof constraint) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t\tif (!isUndefinedOrNull(arg) && (arg as any).constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\nexport function getAllPropertyNames(obj: object): string[] {\n\tlet res: string[] = [];\n\tlet proto = Object.getPrototypeOf(obj);\n\twhile (Object.prototype !== proto) {\n\t\tres = res.concat(Object.getOwnPropertyNames(proto));\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\treturn res;\n}\n\nexport function getAllMethodNames(obj: object): string[] {\n\tconst methods: string[] = [];\n\tfor (const prop of getAllPropertyNames(obj)) {\n\t\tif (typeof (obj as any)[prop] === 'function') {\n\t\t\tmethods.push(prop);\n\t\t}\n\t}\n\treturn methods;\n}\n\nexport function createProxyObject<T extends object>(methodNames: string[], invoke: (method: string, args: unknown[]) => unknown): T {\n\tconst createProxyMethod = (method: string): () => unknown => {\n\t\treturn function () {\n\t\t\tconst args = Array.prototype.slice.call(arguments, 0);\n\t\t\treturn invoke(method, args);\n\t\t};\n\t};\n\n\tconst result = {} as T;\n\tfor (const methodName of methodNames) {\n\t\t(<any>result)[methodName] = createProxyMethod(methodName);\n\t}\n\treturn result;\n}\n\n/**\n * Converts null to undefined, passes all other values through.\n */\nexport function withNullAsUndefined<T>(x: T | null): T | undefined {\n\treturn x === null ? undefined : x;\n}\n\n/**\n * Converts undefined to null, passes all other values through.\n */\nexport function withUndefinedAsNull<T>(x: T | undefined): T | null {\n\treturn typeof x === 'undefined' ? null : x;\n}\n\ntype AddFirstParameterToFunction<T, TargetFunctionsReturnType, FirstParameter> = T extends (...args: any[]) => TargetFunctionsReturnType ?\n\t// Function: add param to function\n\t(firstArg: FirstParameter, ...args: Parameters<T>) => ReturnType<T> :\n\n\t// Else: just leave as is\n\tT;\n\n/**\n * Allows to add a first parameter to functions of a type.\n */\nexport type AddFirstParameterToFunctions<Target, TargetFunctionsReturnType, FirstParameter> = {\n\t// For every property\n\t[K in keyof Target]: AddFirstParameterToFunction<Target[K], TargetFunctionsReturnType, FirstParameter>;\n};\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n\nexport function assertNever(value: never, message = 'Unreachable'): never {\n\tthrow new Error(message);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string): string | undefined {\n\treturn hasDriveLetter(path) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tsuffix += pathChars.charAt(Math.floor(Math.random() * pathChars.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isArray, isTypedArray, isObject, isUndefinedOrNull } from 'vs/base/common/types';\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\t// See https://github.com/microsoft/TypeScript/issues/10990\n\t\treturn obj as any;\n\t}\n\tconst result: any = Array.isArray(obj) ? [] : {};\n\tObject.keys(<any>obj).forEach((key: string) => {\n\t\tif ((<any>obj)[key] && typeof (<any>obj)[key] === 'object') {\n\t\t\tresult[key] = deepClone((<any>obj)[key]);\n\t\t} else {\n\t\t\tresult[key] = (<any>obj)[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tconst stack: any[] = [obj];\n\twhile (stack.length > 0) {\n\t\tconst obj = stack.shift();\n\t\tObject.freeze(obj);\n\t\tfor (const key in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, key)) {\n\t\t\t\tconst prop = obj[key];\n\t\t\t\tif (typeof prop === 'object' && !Object.isFrozen(prop) && !isTypedArray(prop)) {\n\t\t\t\t\tstack.push(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn obj;\n}\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, new Set());\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, seen: Set<any>): any {\n\tif (isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tconst changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (isArray(obj)) {\n\t\tconst r1: any[] = [];\n\t\tfor (const e of obj) {\n\t\t\tr1.push(_cloneAndChange(e, changer, seen));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (isObject(obj)) {\n\t\tif (seen.has(obj)) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tseen.add(obj);\n\t\tconst r2 = {};\n\t\tfor (const i2 in obj) {\n\t\t\tif (_hasOwnProperty.call(obj, i2)) {\n\t\t\t\t(r2 as any)[i2] = _cloneAndChange(obj[i2], changer, seen);\n\t\t\t}\n\t\t}\n\t\tseen.delete(obj);\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (isObject(source)) {\n\t\tObject.keys(source).forEach(key => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (isObject(destination[key]) && isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tlet i: number;\n\tlet key: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst oneKeys: string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tconst otherKeys: string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Calls `JSON.Stringify` with a replacer to break apart any circular references.\n * This prevents `JSON`.stringify` from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tconst seen = new Set<any>();\n\treturn JSON.stringify(obj, (key, value) => {\n\t\tif (isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.has(value)) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.add(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\ntype obj = { [key: string]: any };\n/**\n * Returns an object that has keys for each value that is different in the base object. Keys\n * that do not exist in the target but in the base object are not considered.\n *\n * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting\n * object if they differ.\n *\n * @param base the object to diff against\n * @param obj the object to use for diffing\n */\nexport function distinct(base: obj, target: obj): obj {\n\tconst result = Object.create(null);\n\n\tif (!base || !target) {\n\t\treturn result;\n\t}\n\n\tconst targetKeys = Object.keys(target);\n\ttargetKeys.forEach(k => {\n\t\tconst baseValue = base[k];\n\t\tconst targetValue = target[k];\n\n\t\tif (!equals(baseValue, targetValue)) {\n\t\t\tresult[k] = targetValue;\n\t\t}\n\t});\n\n\treturn result;\n}\n\nexport function getCaseInsensitive(target: obj, key: string): any {\n\tconst lowercaseKey = key.toLowerCase();\n\tconst equivalentKey = Object.keys(target).find(k => k.toLowerCase() === lowercaseKey);\n\treturn equivalentKey ? target[equivalentKey] : target[key];\n}\n\nexport function filter(obj: obj, predicate: (key: string, value: any) => boolean): obj {\n\tconst result = Object.create(null);\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tif (predicate(key, value)) {\n\t\t\tresult[key] = value;\n\t\t}\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { MarshalledId } from 'vs/base/common/marshallingIds';\nimport * as paths from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\tstatic from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t\t_validateUri(result, true);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param uri The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tstatic joinPath(uri: URI, ...pathFragment: string[]): URI {\n\t\tif (!uri.path) {\n\t\t\tthrow new Error(`[UriError]: cannot call joinPath on URI without path`);\n\t\t}\n\t\tlet newPath: string;\n\t\tif (isWindows && uri.scheme === 'file') {\n\t\t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n\t\t} else {\n\t\t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n\t\t}\n\t\treturn uri.with({ path: newPath });\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: MarshalledId.Uri;\n\texternal: string;\n\tfsPath: string;\n\t_sep: 1 | undefined;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: MarshalledId.Uri\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IRemoteConsoleLog {\n\ttype: string;\n\tseverity: string;\n\targuments: string;\n}\n\nexport interface IStackArgument {\n\t__$stack: string;\n}\n\nexport interface IStackFrame {\n\turi: URI;\n\tline: number;\n\tcolumn: number;\n}\n\nexport function isRemoteConsoleLog(obj: any): obj is IRemoteConsoleLog {\n\tconst entry = obj as IRemoteConsoleLog;\n\n\treturn entry && typeof entry.type === 'string' && typeof entry.severity === 'string';\n}\n\nexport function parse(entry: IRemoteConsoleLog): { args: any[]; stack?: string } {\n\tconst args: any[] = [];\n\tlet stack: string | undefined;\n\n\t// Parse Entry\n\ttry {\n\t\tconst parsedArguments: any[] = JSON.parse(entry.arguments);\n\n\t\t// Check for special stack entry as last entry\n\t\tconst stackArgument = parsedArguments[parsedArguments.length - 1] as IStackArgument;\n\t\tif (stackArgument && stackArgument.__$stack) {\n\t\t\tparsedArguments.pop(); // stack is handled specially\n\t\t\tstack = stackArgument.__$stack;\n\t\t}\n\n\t\targs.push(...parsedArguments);\n\t} catch (error) {\n\t\targs.push('Unable to log remote console arguments', entry.arguments);\n\t}\n\n\treturn { args, stack };\n}\n\nexport function getFirstFrame(entry: IRemoteConsoleLog): IStackFrame | undefined;\nexport function getFirstFrame(stack: string | undefined): IStackFrame | undefined;\nexport function getFirstFrame(arg0: IRemoteConsoleLog | string | undefined): IStackFrame | undefined {\n\tif (typeof arg0 !== 'string') {\n\t\treturn getFirstFrame(parse(arg0!).stack);\n\t}\n\n\t// Parse a source information out of the stack if we have one. Format can be:\n\t// at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)\n\t// or\n\t// at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17\n\t// or\n\t// at c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17\n\t// or\n\t// at e.$executeContributedCommand(c:\\Users\\someone\\Desktop\\end-js\\extension.js:19:17)\n\tconst stack = arg0;\n\tif (stack) {\n\t\tconst topFrame = findFirstFrame(stack);\n\n\t\t// at [^\\/]* => line starts with \"at\" followed by any character except '/' (to not capture unix paths too late)\n\t\t// (?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\) => windows drive letter OR unix root OR unc root\n\t\t// (?:.+) => simple pattern for the path, only works because of the line/col pattern after\n\t\t// :(?:\\d+):(?:\\d+) => :line:column data\n\t\tconst matches = /at [^\\/]*((?:(?:[a-zA-Z]+:)|(?:[\\/])|(?:\\\\\\\\))(?:.+)):(\\d+):(\\d+)/.exec(topFrame || '');\n\t\tif (matches && matches.length === 4) {\n\t\t\treturn {\n\t\t\t\turi: URI.file(matches[1]),\n\t\t\t\tline: Number(matches[2]),\n\t\t\t\tcolumn: Number(matches[3])\n\t\t\t};\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nfunction findFirstFrame(stack: string | undefined): string | undefined {\n\tif (!stack) {\n\t\treturn stack;\n\t}\n\n\tconst newlineIndex = stack.indexOf('\\n');\n\tif (newlineIndex === -1) {\n\t\treturn stack;\n\t}\n\n\treturn stack.substring(0, newlineIndex);\n}\n\nexport function log(entry: IRemoteConsoleLog, label: string): void {\n\tconst { args, stack } = parse(entry);\n\n\tconst isOneStringArg = typeof args[0] === 'string' && args.length === 1;\n\n\tlet topFrame = findFirstFrame(stack);\n\tif (topFrame) {\n\t\ttopFrame = `(${topFrame.trim()})`;\n\t}\n\n\tlet consoleArgs: string[] = [];\n\n\t// First arg is a string\n\tif (typeof args[0] === 'string') {\n\t\tif (topFrame && isOneStringArg) {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color(''), color('grey')];\n\t\t} else {\n\t\t\tconsoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color(''), ...args.slice(1)];\n\t\t}\n\t}\n\n\t// First arg is something else, just apply all\n\telse {\n\t\tconsoleArgs = [`%c[${label}]%`, color('blue'), ...args];\n\t}\n\n\t// Stack: add to args unless already aded\n\tif (topFrame && !isOneStringArg) {\n\t\tconsoleArgs.push(topFrame);\n\t}\n\n\t// Log it\n\tif (typeof (console as any)[entry.severity] !== 'function') {\n\t\tthrow new Error('Unknown console method');\n\t}\n\t(console as any)[entry.severity].apply(console, consoleArgs);\n}\n\nfunction color(color: string): string {\n\treturn `color: ${color}`;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { regExpFlags } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { MarshalledId } from './marshallingIds';\n\nexport function stringify(obj: any): string {\n\treturn JSON.stringify(obj, replacer);\n}\n\nexport function parse(text: string): any {\n\tlet data = JSON.parse(text);\n\tdata = revive(data);\n\treturn data;\n}\n\nexport interface MarshalledObject {\n\t$mid: MarshalledId;\n}\n\nfunction replacer(key: string, value: any): any {\n\t// URI is done via toJSON-member\n\tif (value instanceof RegExp) {\n\t\treturn {\n\t\t\t$mid: MarshalledId.Regexp,\n\t\t\tsource: value.source,\n\t\t\tflags: regExpFlags(value),\n\t\t};\n\t}\n\treturn value;\n}\n\n\ntype Deserialize<T> = T extends UriComponents ? URI\n\t: T extends VSBuffer ? VSBuffer\n\t: T extends object\n\t? Revived<T>\n\t: T;\n\nexport type Revived<T> = { [K in keyof T]: Deserialize<T[K]> };\n\nexport function revive<T = any>(obj: any, depth = 0): Revived<T> {\n\tif (!obj || depth > 200) {\n\t\treturn obj;\n\t}\n\n\tif (typeof obj === 'object') {\n\n\t\tswitch ((<MarshalledObject>obj).$mid) {\n\t\t\tcase MarshalledId.Uri: return <any>URI.revive(obj);\n\t\t\tcase MarshalledId.Regexp: return <any>new RegExp(obj.source, obj.flags);\n\t\t\tcase MarshalledId.Date: return <any>new Date(obj.source);\n\t\t}\n\n\t\tif (\n\t\t\tobj instanceof VSBuffer\n\t\t\t|| obj instanceof Uint8Array\n\t\t) {\n\t\t\treturn <any>obj;\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tfor (let i = 0; i < obj.length; ++i) {\n\t\t\t\tobj[i] = revive(obj[i], depth + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// walk object\n\t\t\tfor (const key in obj) {\n\t\t\t\tif (Object.hasOwnProperty.call(obj, key)) {\n\t\t\t\t\tobj[key] = revive(obj[key], depth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebook = 'vscode-notebook';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractive = 'vscode-interactive';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate(uri);\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(uri: URI): URI;\n\tasBrowserUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasBrowserUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(uri: URI): URI;\n\tasFileUri(moduleId: string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI;\n\tasFileUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tconst uri = this.toUri(uriOrModule, moduleIdToUrl);\n\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl?: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl!.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises is resolved and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\tconst result = await Promise.race(promises);\n\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\tif (index !== resolvedPromiseIndex) {\n\t\t\tcancellablePromise.cancel();\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/** Can be passed into the Delayed to defer using a microtask */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\nexport function disposableTimeout(handler: () => void, timeout = 0): IDisposable {\n\tconst timer = setTimeout(handler, timeout);\n\treturn toDisposable(() => clearTimeout(timer));\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tEvent.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\t\t\t});\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tthis.pendingWork.push(...units);\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IPendingTask {\n\ttaskId: number;\n\tcancel: () => void;\n\tpromise: Promise<void>;\n}\n\ninterface ISequentialTask {\n\tpromise: Promise<void>;\n\tpromiseResolve: () => void;\n\tpromiseReject: (error: Error) => void;\n\trun: () => Promise<void>;\n}\n\nexport interface ITaskSequentializerWithPendingTask {\n\treadonly pending: Promise<void>;\n}\n\nexport class TaskSequentializer {\n\tprivate _pending?: IPendingTask;\n\tprivate _next?: ISequentialTask;\n\n\thasPending(taskId?: number): this is ITaskSequentializerWithPendingTask {\n\t\tif (!this._pending) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._pending.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._pending;\n\t}\n\n\tget pending(): Promise<void> | undefined {\n\t\treturn this._pending ? this._pending.promise : undefined;\n\t}\n\n\tcancelPending(): void {\n\t\tthis._pending?.cancel();\n\t}\n\n\tsetPending(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._pending = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.donePending(taskId), () => this.donePending(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate donePending(taskId: number): void {\n\t\tif (this._pending && taskId === this._pending.taskId) {\n\n\t\t\t// only set pending to done if the promise finished that is associated with that taskId\n\t\t\tthis._pending = undefined;\n\n\t\t\t// schedule the next task now that we are free if we have any\n\t\t\tthis.triggerNext();\n\t\t}\n\t}\n\n\tprivate triggerNext(): void {\n\t\tif (this._next) {\n\t\t\tconst next = this._next;\n\t\t\tthis._next = undefined;\n\n\t\t\t// Run next task and complete on the associated promise\n\t\t\tnext.run().then(next.promiseResolve, next.promiseReject);\n\t\t}\n\t}\n\n\tsetNext(run: () => Promise<void>): Promise<void> {\n\n\t\t// this is our first next task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._next) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._next = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous next task, just overwrite it\n\t\telse {\n\t\t\tthis._next.run = run;\n\t\t}\n\n\t\treturn this._next.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate rejected = false;\n\tprivate resolved = false;\n\n\tpublic get isRejected() {\n\t\treturn this.rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn this.rejected || this.resolved;\n\t}\n\n\tpublic p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.resolved = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\tnew Promise<void>(resolve => {\n\t\t\tthis.errorCallback(new CancellationError());\n\t\t\tthis.rejected = true;\n\t\t\tresolve();\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\treturn parsedPattern(path.substr(arg2.base.length + 1), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as sd from 'string_decoder';\nimport { CharCode } from 'vs/base/common/charCode';\n\n/**\n * Convenient way to iterate over output line by line. This helper accommodates for the fact that\n * a buffer might not end with new lines all the way.\n *\n * To use:\n * - call the write method\n * - forEach() over the result to get the lines\n */\nexport class LineDecoder {\n\tprivate stringDecoder: sd.StringDecoder;\n\tprivate remaining: string | null;\n\n\tconstructor(encoding: BufferEncoding = 'utf8') {\n\t\tthis.stringDecoder = new sd.StringDecoder(encoding);\n\t\tthis.remaining = null;\n\t}\n\n\twrite(buffer: Buffer): string[] {\n\t\tconst result: string[] = [];\n\t\tconst value = this.remaining\n\t\t\t? this.remaining + this.stringDecoder.write(buffer)\n\t\t\t: this.stringDecoder.write(buffer);\n\n\t\tif (value.length < 1) {\n\t\t\treturn result;\n\t\t}\n\t\tlet start = 0;\n\t\tlet ch: number;\n\t\tlet idx = start;\n\t\twhile (idx < value.length) {\n\t\t\tch = value.charCodeAt(idx);\n\t\t\tif (ch === CharCode.CarriageReturn || ch === CharCode.LineFeed) {\n\t\t\t\tresult.push(value.substring(start, idx));\n\t\t\t\tidx++;\n\t\t\t\tif (idx < value.length) {\n\t\t\t\t\tconst lastChar = ch;\n\t\t\t\t\tch = value.charCodeAt(idx);\n\t\t\t\t\tif ((lastChar === CharCode.CarriageReturn && ch === CharCode.LineFeed) || (lastChar === CharCode.LineFeed && ch === CharCode.CarriageReturn)) {\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstart = idx;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tthis.remaining = start < value.length ? value.substr(start) : null;\n\t\treturn result;\n\t}\n\n\tend(): string | null {\n\t\treturn this.remaining;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { tmpdir } from 'os';\nimport { promisify } from 'util';\nimport { ResourceQueue } from 'vs/base/common/async';\nimport { isEqualOrParent, isRootOrDriveLetter, randomPath } from 'vs/base/common/extpath';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { join } from 'vs/base/common/path';\nimport { isLinux, isMacintosh, isWindows } from 'vs/base/common/platform';\nimport { extUriBiasedIgnorePathCase } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\n\n//#region rimraf\n\nexport enum RimRafMode {\n\n\t/**\n\t * Slow version that unlinks each file and folder.\n\t */\n\tUNLINK,\n\n\t/**\n\t * Fast version that first moves the file/folder\n\t * into a temp directory and then deletes that\n\t * without waiting for it.\n\t */\n\tMOVE\n}\n\n/**\n * Allows to delete the provided path (either file or folder) recursively\n * with the options:\n * - `UNLINK`: direct removal from disk\n * - `MOVE`: faster variant that first moves the target to temp dir and then\n *           deletes it in the background without waiting for that to finish.\n */\nasync function rimraf(path: string, mode = RimRafMode.UNLINK): Promise<void> {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\t// delete: via rm\n\tif (mode === RimRafMode.UNLINK) {\n\t\treturn rimrafUnlink(path);\n\t}\n\n\t// delete: via move\n\treturn rimrafMove(path);\n}\n\nasync function rimrafMove(path: string): Promise<void> {\n\ttry {\n\t\tconst pathInTemp = randomPath(tmpdir());\n\t\ttry {\n\t\t\t// Intentionally using `fs.promises` here to skip\n\t\t\t// the patched graceful-fs method that can result\n\t\t\t// in very long running `rename` calls when the\n\t\t\t// folder is locked by a file watcher. We do not\n\t\t\t// really want to slow down this operation more\n\t\t\t// than necessary and we have a fallback to delete\n\t\t\t// via unlink.\n\t\t\t// https://github.com/microsoft/vscode/issues/139908\n\t\t\tawait fs.promises.rename(path, pathInTemp);\n\t\t} catch (error) {\n\t\t\treturn rimrafUnlink(path); // if rename fails, delete without tmp dir\n\t\t}\n\n\t\t// Delete but do not return as promise\n\t\trimrafUnlink(pathInTemp).catch(error => {/* ignore */ });\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function rimrafUnlink(path: string): Promise<void> {\n\treturn promisify(fs.rm)(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\nexport function rimrafSync(path: string): void {\n\tif (isRootOrDriveLetter(path)) {\n\t\tthrow new Error('rimraf - will refuse to recursively delete root');\n\t}\n\n\tfs.rmSync(path, { recursive: true, force: true, maxRetries: 3 });\n}\n\n//#endregion\n\n//#region readdir with NFC support (macos)\n\nexport interface IDirent {\n\tname: string;\n\n\tisFile(): boolean;\n\tisDirectory(): boolean;\n\tisSymbolicLink(): boolean;\n}\n\n/**\n * Drop-in replacement of `fs.readdir` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nasync function readdir(path: string): Promise<string[]>;\nasync function readdir(path: string, options: { withFileTypes: true }): Promise<IDirent[]>;\nasync function readdir(path: string, options?: { withFileTypes: true }): Promise<(string | IDirent)[]> {\n\treturn handleDirectoryChildren(await (options ? safeReaddirWithFileTypes(path) : promisify(fs.readdir)(path)));\n}\n\nasync function safeReaddirWithFileTypes(path: string): Promise<IDirent[]> {\n\ttry {\n\t\treturn await promisify(fs.readdir)(path, { withFileTypes: true });\n\t} catch (error) {\n\t\tconsole.warn('[node.js fs] readdir with filetypes failed with error: ', error);\n\t}\n\n\t// Fallback to manually reading and resolving each\n\t// children of the folder in case we hit an error\n\t// previously.\n\t// This can only really happen on exotic file systems\n\t// such as explained in #115645 where we get entries\n\t// from `readdir` that we can later not `lstat`.\n\tconst result: IDirent[] = [];\n\tconst children = await readdir(path);\n\tfor (const child of children) {\n\t\tlet isFile = false;\n\t\tlet isDirectory = false;\n\t\tlet isSymbolicLink = false;\n\n\t\ttry {\n\t\t\tconst lstat = await Promises.lstat(join(path, child));\n\n\t\t\tisFile = lstat.isFile();\n\t\t\tisDirectory = lstat.isDirectory();\n\t\t\tisSymbolicLink = lstat.isSymbolicLink();\n\t\t} catch (error) {\n\t\t\tconsole.warn('[node.js fs] unexpected error from lstat after readdir: ', error);\n\t\t}\n\n\t\tresult.push({\n\t\t\tname: child,\n\t\t\tisFile: () => isFile,\n\t\t\tisDirectory: () => isDirectory,\n\t\t\tisSymbolicLink: () => isSymbolicLink\n\t\t});\n\t}\n\n\treturn result;\n}\n\n/**\n * Drop-in replacement of `fs.readdirSync` with support\n * for converting from macOS NFD unicon form to NFC\n * (https://github.com/nodejs/node/issues/2165)\n */\nexport function readdirSync(path: string): string[] {\n\treturn handleDirectoryChildren(fs.readdirSync(path));\n}\n\nfunction handleDirectoryChildren(children: string[]): string[];\nfunction handleDirectoryChildren(children: IDirent[]): IDirent[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[];\nfunction handleDirectoryChildren(children: (string | IDirent)[]): (string | IDirent)[] {\n\treturn children.map(child => {\n\n\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t// See also https://github.com/nodejs/node/issues/2165\n\n\t\tif (typeof child === 'string') {\n\t\t\treturn isMacintosh ? normalizeNFC(child) : child;\n\t\t}\n\n\t\tchild.name = isMacintosh ? normalizeNFC(child.name) : child.name;\n\n\t\treturn child;\n\t});\n}\n\n/**\n * A convenience method to read all children of a path that\n * are directories.\n */\nasync function readDirsInDir(dirPath: string): Promise<string[]> {\n\tconst children = await readdir(dirPath);\n\tconst directories: string[] = [];\n\n\tfor (const child of children) {\n\t\tif (await SymlinkSupport.existsDirectory(join(dirPath, child))) {\n\t\t\tdirectories.push(child);\n\t\t}\n\t}\n\n\treturn directories;\n}\n\n//#endregion\n\n//#region whenDeleted()\n\n/**\n * A `Promise` that resolves when the provided `path`\n * is deleted from disk.\n */\nexport function whenDeleted(path: string, intervalMs = 1000): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tlet running = false;\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!running) {\n\t\t\t\trunning = true;\n\t\t\t\tfs.access(path, err => {\n\t\t\t\t\trunning = false;\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tclearInterval(interval);\n\t\t\t\t\t\tresolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, intervalMs);\n\t});\n}\n\n//#endregion\n\n//#region Methods with symbolic links support\n\nexport namespace SymlinkSupport {\n\n\texport interface IStats {\n\n\t\t// The stats of the file. If the file is a symbolic\n\t\t// link, the stats will be of that target file and\n\t\t// not the link itself.\n\t\t// If the file is a symbolic link pointing to a non\n\t\t// existing file, the stat will be of the link and\n\t\t// the `dangling` flag will indicate this.\n\t\tstat: fs.Stats;\n\n\t\t// Will be provided if the resource is a symbolic link\n\t\t// on disk. Use the `dangling` flag to find out if it\n\t\t// points to a resource that does not exist on disk.\n\t\tsymbolicLink?: { dangling: boolean };\n\t}\n\n\t/**\n\t * Resolves the `fs.Stats` of the provided path. If the path is a\n\t * symbolic link, the `fs.Stats` will be from the target it points\n\t * to. If the target does not exist, `dangling: true` will be returned\n\t * as `symbolicLink` value.\n\t */\n\texport async function stat(path: string): Promise<IStats> {\n\n\t\t// First stat the link\n\t\tlet lstats: fs.Stats | undefined;\n\t\ttry {\n\t\t\tlstats = await Promises.lstat(path);\n\n\t\t\t// Return early if the stat is not a symbolic link at all\n\t\t\tif (!lstats.isSymbolicLink()) {\n\t\t\t\treturn { stat: lstats };\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t/* ignore - use stat() instead */\n\t\t}\n\n\t\t// If the stat is a symbolic link or failed to stat, use fs.stat()\n\t\t// which for symbolic links will stat the target they point to\n\t\ttry {\n\t\t\tconst stats = await Promises.stat(path);\n\n\t\t\treturn { stat: stats, symbolicLink: lstats?.isSymbolicLink() ? { dangling: false } : undefined };\n\t\t} catch (error) {\n\n\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t// to return it as result while setting dangling: true flag\n\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t}\n\n\t\t\t// Windows: workaround a node.js bug where reparse points\n\t\t\t// are not supported (https://github.com/nodejs/node/issues/36790)\n\t\t\tif (isWindows && error.code === 'EACCES') {\n\t\t\t\ttry {\n\t\t\t\t\tconst stats = await Promises.stat(await Promises.readlink(path));\n\n\t\t\t\t\treturn { stat: stats, symbolicLink: { dangling: false } };\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t// If the link points to a nonexistent file we still want\n\t\t\t\t\t// to return it as result while setting dangling: true flag\n\t\t\t\t\tif (error.code === 'ENOENT' && lstats) {\n\t\t\t\t\t\treturn { stat: lstats, symbolicLink: { dangling: true } };\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a file with support\n\t * for symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsFile(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isFile() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Figures out if the `path` exists and is a directory with support for\n\t * symlinks.\n\t *\n\t * Note: this will return `false` for a symlink that exists on\n\t * disk but is dangling (pointing to a nonexistent path).\n\t *\n\t * Use `exists` if you only care about the path existing on disk\n\t * or not without support for symbolic links.\n\t */\n\texport async function existsDirectory(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tconst { stat, symbolicLink } = await SymlinkSupport.stat(path);\n\n\t\t\treturn stat.isDirectory() && symbolicLink?.dangling !== true;\n\t\t} catch (error) {\n\t\t\t// Ignore, path might not exist\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n//#endregion\n\n//#region Write File\n\n// According to node.js docs (https://nodejs.org/docs/v14.16.0/api/fs.html#fs_fs_writefile_file_data_options_callback)\n// it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.\n// Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.\nconst writeQueues = new ResourceQueue();\n\n/**\n * Same as `fs.writeFile` but with an additional call to\n * `fs.fdatasync` after writing to ensure changes are\n * flushed to disk.\n *\n * In addition, multiple writes to the same path are queued.\n */\nfunction writeFile(path: string, data: string, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Buffer, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void>;\nfunction writeFile(path: string, data: string | Buffer | Uint8Array, options?: IWriteFileOptions): Promise<void> {\n\treturn writeQueues.queueFor(URI.file(path), extUriBiasedIgnorePathCase).queue(() => {\n\t\tconst ensuredOptions = ensureWriteOptions(options);\n\n\t\treturn new Promise((resolve, reject) => doWriteFileAndFlush(path, data, ensuredOptions, error => error ? reject(error) : resolve()));\n\t});\n}\n\ninterface IWriteFileOptions {\n\tmode?: number;\n\tflag?: string;\n}\n\ninterface IEnsuredWriteFileOptions extends IWriteFileOptions {\n\tmode: number;\n\tflag: string;\n}\n\nlet canFlush = true;\nexport function configureFlushOnWrite(enabled: boolean): void {\n\tcanFlush = enabled;\n}\n\n// Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk\n// We do this in cases where we want to make sure the data is really on disk and\n// not in some cache.\n//\n// See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194\nfunction doWriteFileAndFlush(path: string, data: string | Buffer | Uint8Array, options: IEnsuredWriteFileOptions, callback: (error: Error | null) => void): void {\n\tif (!canFlush) {\n\t\treturn fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tfs.open(path, options.flag, options.mode, (openError, fd) => {\n\t\tif (openError) {\n\t\t\treturn callback(openError);\n\t\t}\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFile(fd, data, writeError => {\n\t\t\tif (writeError) {\n\t\t\t\treturn fs.close(fd, () => callback(writeError)); // still need to close the handle on error!\n\t\t\t}\n\n\t\t\t// Flush contents (not metadata) of the file to disk\n\t\t\t// https://github.com/microsoft/vscode/issues/9589\n\t\t\tfs.fdatasync(fd, (syncError: Error | null) => {\n\n\t\t\t\t// In some exotic setups it is well possible that node fails to sync\n\t\t\t\t// In that case we disable flushing and warn to the console\n\t\t\t\tif (syncError) {\n\t\t\t\t\tconsole.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);\n\t\t\t\t\tconfigureFlushOnWrite(false);\n\t\t\t\t}\n\n\t\t\t\treturn fs.close(fd, closeError => callback(closeError));\n\t\t\t});\n\t\t});\n\t});\n}\n\n/**\n * Same as `fs.writeFileSync` but with an additional call to\n * `fs.fdatasyncSync` after writing to ensure changes are\n * flushed to disk.\n */\nexport function writeFileSync(path: string, data: string | Buffer, options?: IWriteFileOptions): void {\n\tconst ensuredOptions = ensureWriteOptions(options);\n\n\tif (!canFlush) {\n\t\treturn fs.writeFileSync(path, data, { mode: ensuredOptions.mode, flag: ensuredOptions.flag });\n\t}\n\n\t// Open the file with same flags and mode as fs.writeFile()\n\tconst fd = fs.openSync(path, ensuredOptions.flag, ensuredOptions.mode);\n\n\ttry {\n\n\t\t// It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!\n\t\tfs.writeFileSync(fd, data);\n\n\t\t// Flush contents (not metadata) of the file to disk\n\t\ttry {\n\t\t\tfs.fdatasyncSync(fd); // https://github.com/microsoft/vscode/issues/9589\n\t\t} catch (syncError) {\n\t\t\tconsole.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);\n\t\t\tconfigureFlushOnWrite(false);\n\t\t}\n\t} finally {\n\t\tfs.closeSync(fd);\n\t}\n}\n\nfunction ensureWriteOptions(options?: IWriteFileOptions): IEnsuredWriteFileOptions {\n\tif (!options) {\n\t\treturn { mode: 0o666 /* default node.js mode for files */, flag: 'w' };\n\t}\n\n\treturn {\n\t\tmode: typeof options.mode === 'number' ? options.mode : 0o666 /* default node.js mode for files */,\n\t\tflag: typeof options.flag === 'string' ? options.flag : 'w'\n\t};\n}\n\n//#endregion\n\n//#region Move / Copy\n\n/**\n * A drop-in replacement for `fs.rename` that:\n * - allows to move across multiple disks\n */\nasync function move(source: string, target: string): Promise<void> {\n\tif (source === target) {\n\t\treturn;  // simulate node.js behaviour here and do a no-op if paths match\n\t}\n\n\ttry {\n\t\tawait Promises.rename(source, target);\n\t} catch (error) {\n\n\t\t// In two cases we fallback to classic copy and delete:\n\t\t//\n\t\t// 1.) The EXDEV error indicates that source and target are on different devices\n\t\t// In this case, fallback to using a copy() operation as there is no way to\n\t\t// rename() between different devices.\n\t\t//\n\t\t// 2.) The user tries to rename a file/folder that ends with a dot. This is not\n\t\t// really possible to move then, at least on UNC devices.\n\t\tif (source.toLowerCase() !== target.toLowerCase() && error.code === 'EXDEV' || source.endsWith('.')) {\n\t\t\tawait copy(source, target, { preserveSymlinks: false /* copying to another device */ });\n\t\t\tawait rimraf(source, RimRafMode.MOVE);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\ninterface ICopyPayload {\n\treadonly root: { source: string; target: string };\n\treadonly options: { preserveSymlinks: boolean };\n\treadonly handledSourcePaths: Set<string>;\n}\n\n/**\n * Recursively copies all of `source` to `target`.\n *\n * The options `preserveSymlinks` configures how symbolic\n * links should be handled when encountered. Set to\n * `false` to not preserve them and `true` otherwise.\n */\nasync function copy(source: string, target: string, options: { preserveSymlinks: boolean }): Promise<void> {\n\treturn doCopy(source, target, { root: { source, target }, options, handledSourcePaths: new Set<string>() });\n}\n\n// When copying a file or folder, we want to preserve the mode\n// it had and as such provide it when creating. However, modes\n// can go beyond what we expect (see link below), so we mask it.\n// (https://github.com/nodejs/node-v0.x-archive/issues/3045#issuecomment-4862588)\nconst COPY_MODE_MASK = 0o777;\n\nasync function doCopy(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Keep track of paths already copied to prevent\n\t// cycles from symbolic links to cause issues\n\tif (payload.handledSourcePaths.has(source)) {\n\t\treturn;\n\t} else {\n\t\tpayload.handledSourcePaths.add(source);\n\t}\n\n\tconst { stat, symbolicLink } = await SymlinkSupport.stat(source);\n\n\t// Symlink\n\tif (symbolicLink) {\n\n\t\t// Try to re-create the symlink unless `preserveSymlinks: false`\n\t\tif (payload.options.preserveSymlinks) {\n\t\t\ttry {\n\t\t\t\treturn await doCopySymlink(source, target, payload);\n\t\t\t} catch (error) {\n\t\t\t\t// in any case of an error fallback to normal copy via dereferencing\n\t\t\t\tconsole.warn('[node.js fs] copy of symlink failed: ', error);\n\t\t\t}\n\t\t}\n\n\t\tif (symbolicLink.dangling) {\n\t\t\treturn; // skip dangling symbolic links from here on (https://github.com/microsoft/vscode/issues/111621)\n\t\t}\n\t}\n\n\t// Folder\n\tif (stat.isDirectory()) {\n\t\treturn doCopyDirectory(source, target, stat.mode & COPY_MODE_MASK, payload);\n\t}\n\n\t// File or file-like\n\telse {\n\t\treturn doCopyFile(source, target, stat.mode & COPY_MODE_MASK);\n\t}\n}\n\nasync function doCopyDirectory(source: string, target: string, mode: number, payload: ICopyPayload): Promise<void> {\n\n\t// Create folder\n\tawait Promises.mkdir(target, { recursive: true, mode });\n\n\t// Copy each file recursively\n\tconst files = await readdir(source);\n\tfor (const file of files) {\n\t\tawait doCopy(join(source, file), join(target, file), payload);\n\t}\n}\n\nasync function doCopyFile(source: string, target: string, mode: number): Promise<void> {\n\n\t// Copy file\n\tawait Promises.copyFile(source, target);\n\n\t// restore mode (https://github.com/nodejs/node/issues/1104)\n\tawait Promises.chmod(target, mode);\n}\n\nasync function doCopySymlink(source: string, target: string, payload: ICopyPayload): Promise<void> {\n\n\t// Figure out link target\n\tlet linkTarget = await Promises.readlink(source);\n\n\t// Special case: the symlink points to a target that is\n\t// actually within the path that is being copied. In that\n\t// case we want the symlink to point to the target and\n\t// not the source\n\tif (isEqualOrParent(linkTarget, payload.root.source, !isLinux)) {\n\t\tlinkTarget = join(payload.root.target, linkTarget.substr(payload.root.source.length + 1));\n\t}\n\n\t// Create symlink\n\tawait Promises.symlink(linkTarget, target);\n}\n\n//#endregion\n\n//#region Promise based fs methods\n\n/**\n * Prefer this helper class over the `fs.promises` API to\n * enable `graceful-fs` to function properly. Given issue\n * https://github.com/isaacs/node-graceful-fs/issues/160 it\n * is evident that the module only takes care of the non-promise\n * based fs methods.\n *\n * Another reason is `realpath` being entirely different in\n * the promise based implementation compared to the other\n * one (https://github.com/microsoft/vscode/issues/118562)\n *\n * Note: using getters for a reason, since `graceful-fs`\n * patching might kick in later after modules have been\n * loaded we need to defer access to fs methods.\n * (https://github.com/microsoft/vscode/issues/124176)\n */\nexport const Promises = new class {\n\n\t//#region Implemented by node.js\n\n\tget access() { return promisify(fs.access); }\n\n\tget stat() { return promisify(fs.stat); }\n\tget lstat() { return promisify(fs.lstat); }\n\tget utimes() { return promisify(fs.utimes); }\n\n\tget read() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes read, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number, length: number, position: number | null) => {\n\t\t\treturn new Promise<{ bytesRead: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesRead, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\tget readFile() { return promisify(fs.readFile); }\n\n\tget write() {\n\n\t\t// Not using `promisify` here for a reason: the return\n\t\t// type is not an object as indicated by TypeScript but\n\t\t// just the bytes written, so we create our own wrapper.\n\n\t\treturn (fd: number, buffer: Uint8Array, offset: number | undefined | null, length: number | undefined | null, position: number | undefined | null) => {\n\t\t\treturn new Promise<{ bytesWritten: number; buffer: Uint8Array }>((resolve, reject) => {\n\t\t\t\tfs.write(fd, buffer, offset, length, position, (err, bytesWritten, buffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve({ bytesWritten, buffer });\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t}\n\n\tget appendFile() { return promisify(fs.appendFile); }\n\n\tget fdatasync() { return promisify(fs.fdatasync); }\n\tget truncate() { return promisify(fs.truncate); }\n\n\tget rename() { return promisify(fs.rename); }\n\tget copyFile() { return promisify(fs.copyFile); }\n\n\tget open() { return promisify(fs.open); }\n\tget close() { return promisify(fs.close); }\n\n\tget symlink() { return promisify(fs.symlink); }\n\tget readlink() { return promisify(fs.readlink); }\n\n\tget chmod() { return promisify(fs.chmod); }\n\n\tget mkdir() { return promisify(fs.mkdir); }\n\n\tget unlink() { return promisify(fs.unlink); }\n\tget rmdir() { return promisify(fs.rmdir); }\n\n\tget realpath() { return promisify(fs.realpath); }\n\n\t//#endregion\n\n\t//#region Implemented by us\n\n\tasync exists(path: string): Promise<boolean> {\n\t\ttry {\n\t\t\tawait Promises.access(path);\n\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tget readdir() { return readdir; }\n\tget readDirsInDir() { return readDirsInDir; }\n\n\tget writeFile() { return writeFile; }\n\n\tget rm() { return rimraf; }\n\n\tget move() { return move; }\n\tget copy() { return copy; }\n\n\t//#endregion\n};\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport { basename, dirname, join, normalize, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { rtrim } from 'vs/base/common/strings';\nimport { Promises, readdirSync } from 'vs/base/node/pfs';\n\n/**\n * Copied from: https://github.com/microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83\n *\n * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.\n * On a case insensitive file system, the returned path might differ from the original path by character casing.\n * On a case sensitive file system, the returned path will always be identical to the original path.\n * In case of errors, null is returned. But you cannot use this function to verify that a path exists.\n * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.\n */\nexport function realcaseSync(path: string): string | null {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = readdirSync(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = realcaseSync(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport async function realcase(path: string): Promise<string | null> {\n\tif (isLinux) {\n\t\t// This method is unsupported on OS that have case sensitive\n\t\t// file system where the same path can exist in different forms\n\t\t// (see also https://github.com/microsoft/vscode/issues/139709)\n\t\treturn path;\n\t}\n\n\tconst dir = dirname(path);\n\tif (path === dir) {\t// end recursion\n\t\treturn path;\n\t}\n\n\tconst name = (basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();\n\ttry {\n\t\tconst entries = await Promises.readdir(dir);\n\t\tconst found = entries.filter(e => e.toLowerCase() === name);\t// use a case insensitive search\n\t\tif (found.length === 1) {\n\t\t\t// on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition\n\t\t\tconst prefix = await realcase(dir);   // recurse\n\t\t\tif (prefix) {\n\t\t\t\treturn join(prefix, found[0]);\n\t\t\t}\n\t\t} else if (found.length > 1) {\n\t\t\t// must be a case sensitive $filesystem\n\t\t\tconst ix = found.indexOf(name);\n\t\t\tif (ix >= 0) {\t// case sensitive\n\t\t\t\tconst prefix = await realcase(dir);   // recurse\n\t\t\t\tif (prefix) {\n\t\t\t\t\treturn join(prefix, found[ix]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// silently ignore error\n\t}\n\n\treturn null;\n}\n\nexport async function realpath(path: string): Promise<string> {\n\ttry {\n\t\t// DO NOT USE `fs.promises.realpath` here as it internally\n\t\t// calls `fs.native.realpath` which will result in subst\n\t\t// drives to be resolved to their target on Windows\n\t\t// https://github.com/microsoft/vscode/issues/118562\n\t\treturn await Promises.realpath(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tawait Promises.access(normalizedPath, fs.constants.R_OK);\n\n\t\treturn normalizedPath;\n\t}\n}\n\nexport function realpathSync(path: string): string {\n\ttry {\n\t\treturn fs.realpathSync(path);\n\t} catch (error) {\n\n\t\t// We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization\n\t\t// we now do a similar normalization and then try again if we can access the path with read\n\t\t// permissions at least. If that succeeds, we return that path.\n\t\t// fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is\n\t\t// to not resolve links but to simply see if the path is read accessible or not.\n\t\tconst normalizedPath = normalizePath(path);\n\n\t\tfs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error\n\n\t\treturn normalizedPath;\n\t}\n}\n\nfunction normalizePath(path: string): string {\n\treturn rtrim(normalize(path), sep);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getRandomElement } from 'vs/base/common/arrays';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { memoize } from 'vs/base/common/decorators';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event, EventMultiplexer, Relay } from 'vs/base/common/event';\nimport { combinedDisposable, DisposableStore, dispose, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { revive } from 'vs/base/common/marshalling';\nimport * as strings from 'vs/base/common/strings';\nimport { isFunction, isUndefinedOrNull } from 'vs/base/common/types';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the counter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\nfunction requestTypeToStr(type: RequestType): string {\n\tswitch (type) {\n\t\tcase RequestType.Promise:\n\t\t\treturn 'req';\n\t\tcase RequestType.PromiseCancel:\n\t\t\treturn 'cancel';\n\t\tcase RequestType.EventListen:\n\t\t\treturn 'subscribe';\n\t\tcase RequestType.EventDispose:\n\t\t\treturn 'unsubscribe';\n\t}\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel; id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose; id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\nfunction responseTypeToStr(type: ResponseType): string {\n\tswitch (type) {\n\t\tcase ResponseType.Initialize:\n\t\t\treturn `init`;\n\t\tcase ResponseType.PromiseSuccess:\n\t\t\treturn `reply:`;\n\t\tcase ResponseType.PromiseError:\n\t\tcase ResponseType.PromiseErrorObj:\n\t\t\treturn `replyErr:`;\n\t\tcase ResponseType.EventFire:\n\t\t\treturn `event:`;\n\t}\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string; name: string; stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n\t/**\n\t * Wait for the write buffer (if applicable) to become empty.\n\t */\n\tdrain?(): Promise<void>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidAddConnection: Event<Connection<TContext>>;\n\treadonly onDidRemoveConnection: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router?: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5\n}\n\nfunction createSizeBuffer(size: number): VSBuffer {\n\tconst result = VSBuffer.alloc(4);\n\tresult.writeUInt32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUInt32BE(0);\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUInt8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n};\n\ndeclare const Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriter.write(createSizeBuffer(data.byteLength));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUInt8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\ninterface PendingRequest {\n\trequest: IRawPromiseRequest | IRawEventListenRequest;\n\ttimeoutTimer: any;\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\t// Requests might come in for channels which are not yet registered.\n\t// They will timeout after `timeoutDelay`.\n\tprivate pendingRequests = new Map<string, PendingRequest[]>();\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext, private logger: IIPCLogger | null = null, private timeoutDelay: number = 1000) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\t// https://github.com/microsoft/vscode/issues/72531\n\t\tsetTimeout(() => this.flushPendingRequests(channelName), 0);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize: {\n\t\t\t\tconst msgLength = this.send([response.type]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, 0, RequestInitiator.OtherSide, responseTypeToStr(response.type));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj: {\n\t\t\t\tconst msgLength = this.send([response.type, response.id], response.data);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, response.id, RequestInitiator.OtherSide, responseTypeToStr(response.type), response.data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}: ${header[2]}.${header[3]}`, body);\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.OtherSide, `${requestTypeToStr(type)}`);\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\n\t\tif (!channel) {\n\t\t\tthis.collectPendingRequest(request);\n\t\t\treturn;\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tprivate collectPendingRequest(request: IRawPromiseRequest | IRawEventListenRequest): void {\n\t\tlet pendingRequests = this.pendingRequests.get(request.channelName);\n\n\t\tif (!pendingRequests) {\n\t\t\tpendingRequests = [];\n\t\t\tthis.pendingRequests.set(request.channelName, pendingRequests);\n\t\t}\n\n\t\tconst timer = setTimeout(() => {\n\t\t\tconsole.error(`Unknown channel: ${request.channelName}`);\n\n\t\t\tif (request.type === RequestType.Promise) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid: request.id,\n\t\t\t\t\tdata: { name: 'Unknown channel', message: `Channel name '${request.channelName}' timed out after ${this.timeoutDelay}ms`, stack: undefined },\n\t\t\t\t\ttype: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t}\n\t\t}, this.timeoutDelay);\n\n\t\tpendingRequests.push({ request, timeoutTimer: timer });\n\t}\n\n\tprivate flushPendingRequests(channelName: string): void {\n\t\tconst requests = this.pendingRequests.get(channelName);\n\n\t\tif (requests) {\n\t\t\tfor (const request of requests) {\n\t\t\t\tclearTimeout(request.timeoutTimer);\n\n\t\t\t\tswitch (request.request.type) {\n\t\t\t\t\tcase RequestType.Promise: this.onPromise(request.request); break;\n\t\t\t\t\tcase RequestType.EventListen: this.onEventListen(request.request); break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pendingRequests.delete(channelName);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport const enum RequestInitiator {\n\tLocalSide = 0,\n\tOtherSide = 1\n}\n\nexport interface IIPCLogger {\n\tlogIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n\tlogOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void;\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate isDisposed: boolean = false;\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\tprivate logger: IIPCLogger | null;\n\n\tprivate readonly _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol, logger: IIPCLogger | null = null) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t\tthis.logger = logger;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Promise.reject(errors.canceled());\n\t\t\t\t}\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tif (that.isDisposed) {\n\t\t\t\t\treturn Event.None;\n\t\t\t\t}\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tconst doRequest = () => {\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError: {\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t};\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\t\t\tif (this.state === State.Idle) {\n\t\t\t\tdoRequest();\n\t\t\t} else {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tdoRequest();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable(toDisposable(cancel), cancellationTokenListener);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => { this.activeRequests.delete(disposable); });\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawResponse) => emitter.fire((res as IRawEventFireResponse).data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, `${requestTypeToStr(request.type)}: ${request.channelName}.${request.name}`, request.arg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose: {\n\t\t\t\tconst msgLength = this.send([request.type, request.id]);\n\t\t\t\tthis.logger?.logOutgoing(msgLength, request.id, RequestInitiator.LocalSide, requestTypeToStr(request.type));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): number {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\treturn this.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): number {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t\treturn message.byteLength;\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, 0, RequestInitiator.LocalSide, responseTypeToStr(type));\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\tthis.logger?.logIncoming(message.byteLength, header[1], RequestInitiator.LocalSide, responseTypeToStr(type), body);\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\thandler?.(response);\n\t}\n\n\t@memoize\n\tget onDidInitializePromise(): Promise<void> {\n\t\treturn Event.toPromise(this.onDidInitialize);\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn this.onDidInitializePromise;\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tdispose(this.activeRequests.values());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelServer: ChannelServer<TContext>;\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate readonly _onDidAddConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidAddConnection: Event<Connection<TContext>> = this._onDidAddConnection.event;\n\n\tprivate readonly _onDidRemoveConnection = new Emitter<Connection<TContext>>();\n\treadonly onDidRemoveConnection: Event<Connection<TContext>> = this._onDidRemoveConnection.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelServer, channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidAddConnection.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t\tthis._onDidRemoveConnection.fire(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get a channel from a remote client. When passed a router,\n\t * one can specify which client it wants to call and listen to/from.\n\t * Otherwise, when calling without a router, a random client will\n\t * be selected and when listening without a router, every client\n\t * will be listened to.\n\t */\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n\tgetChannel<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean): T;\n\tgetChannel<T extends IChannel>(channelName: string, routerOrClientFilter: IClientRouter<TContext> | ((client: Client<TContext>) => boolean)): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\tlet connectionPromise: Promise<Client<TContext>>;\n\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\t// when no router is provided, we go random client picking\n\t\t\t\t\tconst connection = getRandomElement(that.connections.filter(routerOrClientFilter));\n\n\t\t\t\t\tconnectionPromise = connection\n\t\t\t\t\t\t// if we found a client, let's call on it\n\t\t\t\t\t\t? Promise.resolve(connection)\n\t\t\t\t\t\t// else, let's wait for a client to come along\n\t\t\t\t\t\t: Event.toPromise(Event.filter(that.onDidAddConnection, routerOrClientFilter));\n\t\t\t\t} else {\n\t\t\t\t\tconnectionPromise = routerOrClientFilter.routeCall(that, command, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = connectionPromise\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any): Event<T> {\n\t\t\t\tif (isFunction(routerOrClientFilter)) {\n\t\t\t\t\treturn that.getMulticastEvent(channelName, routerOrClientFilter, event, arg);\n\t\t\t\t}\n\n\t\t\t\tconst channelPromise = routerOrClientFilter.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate getMulticastEvent<T extends IChannel>(channelName: string, clientFilter: (client: Client<TContext>) => boolean, eventName: string, arg: any): Event<T> {\n\t\tconst that = this;\n\t\tlet disposables = new DisposableStore();\n\n\t\t// Create an emitter which hooks up to all clients\n\t\t// as soon as first listener is added. It also\n\t\t// disconnects from all clients as soon as the last listener\n\t\t// is removed.\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tdisposables = new DisposableStore();\n\n\t\t\t\t// The event multiplexer is useful since the active\n\t\t\t\t// client list is dynamic. We need to hook up and disconnection\n\t\t\t\t// to/from clients as they come and go.\n\t\t\t\tconst eventMultiplexer = new EventMultiplexer<T>();\n\t\t\t\tconst map = new Map<Connection<TContext>, IDisposable>();\n\n\t\t\t\tconst onDidAddConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst channel = connection.channelClient.getChannel(channelName);\n\t\t\t\t\tconst event = channel.listen<T>(eventName, arg);\n\t\t\t\t\tconst disposable = eventMultiplexer.add(event);\n\n\t\t\t\t\tmap.set(connection, disposable);\n\t\t\t\t};\n\n\t\t\t\tconst onDidRemoveConnection = (connection: Connection<TContext>) => {\n\t\t\t\t\tconst disposable = map.get(connection);\n\n\t\t\t\t\tif (!disposable) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t\tmap.delete(connection);\n\t\t\t\t};\n\n\t\t\t\tthat.connections.filter(clientFilter).forEach(onDidAddConnection);\n\t\t\t\tEvent.filter(that.onDidAddConnection, clientFilter)(onDidAddConnection, undefined, disposables);\n\t\t\t\tthat.onDidRemoveConnection(onDidRemoveConnection, undefined, disposables);\n\t\t\t\teventMultiplexer.event(emitter.fire, emitter, disposables);\n\n\t\t\t\tdisposables.add(eventMultiplexer);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tdisposables.dispose();\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\n\t\tthis._connections.forEach(connection => {\n\t\t\tconnection.channelServer.registerChannel(channelName, channel);\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidAddConnection.dispose();\n\t\tthis._onDidRemoveConnection.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext, ipcLogger: IIPCLogger | null = null) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol, ipcLogger);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx, ipcLogger);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidAddConnection);\n\t\treturn await this.route(hub);\n\t}\n}\n\n/**\n * Use ProxyChannels to automatically wrapping and unwrapping\n * services to/from IPC channels, instead of manually wrapping\n * each service method and event.\n *\n * Restrictions:\n * - If marshalling is enabled, only `URI` and `RegExp` is converted\n *   automatically for you\n * - Events must follow the naming convention `onUpperCase`\n * - `CancellationToken` is currently not supported\n * - If a context is provided, you can use `AddFirstParameterToFunctions`\n *   utility to signal this in the receiving side type\n */\nexport namespace ProxyChannel {\n\n\texport interface IProxyOptions {\n\n\t\t/**\n\t\t * Disables automatic marshalling of `URI`.\n\t\t * If marshalling is disabled, `UriComponents`\n\t\t * must be used instead.\n\t\t */\n\t\tdisableMarshalling?: boolean;\n\t}\n\n\texport interface ICreateServiceChannelOptions extends IProxyOptions { }\n\n\texport function fromService<TContext>(service: unknown, options?: ICreateServiceChannelOptions): IServerChannel<TContext> {\n\t\tconst handler = service as { [key: string]: unknown };\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\t// Buffer any event that should be supported by\n\t\t// iterating over all property keys and finding them\n\t\tconst mapEventNameToEvent = new Map<string, Event<unknown>>();\n\t\tfor (const key in handler) {\n\t\t\tif (propertyIsEvent(key)) {\n\t\t\t\tmapEventNameToEvent.set(key, Event.buffer(handler[key] as Event<unknown>, true));\n\t\t\t}\n\t\t}\n\n\t\treturn new class implements IServerChannel {\n\n\t\t\tlisten<T>(_: unknown, event: string, arg: any): Event<T> {\n\t\t\t\tconst eventImpl = mapEventNameToEvent.get(event);\n\t\t\t\tif (eventImpl) {\n\t\t\t\t\treturn eventImpl as Event<T>;\n\t\t\t\t}\n\n\t\t\t\tif (propertyIsDynamicEvent(event)) {\n\t\t\t\t\tconst target = handler[event];\n\t\t\t\t\tif (typeof target === 'function') {\n\t\t\t\t\t\treturn target.call(handler, arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Event not found: ${event}`);\n\t\t\t}\n\n\t\t\tcall(_: unknown, command: string, args?: any[]): Promise<any> {\n\t\t\t\tconst target = handler[command];\n\t\t\t\tif (typeof target === 'function') {\n\n\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\tif (!disableMarshalling && Array.isArray(args)) {\n\t\t\t\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\t\t\t\targs[i] = revive(args[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn target.apply(handler, args);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Method not found: ${command}`);\n\t\t\t}\n\t\t};\n\t}\n\n\texport interface ICreateProxyServiceOptions extends IProxyOptions {\n\n\t\t/**\n\t\t * If provided, will add the value of `context`\n\t\t * to each method call to the target.\n\t\t */\n\t\tcontext?: unknown;\n\n\t\t/**\n\t\t * If provided, will not proxy any of the properties\n\t\t * that are part of the Map but rather return that value.\n\t\t */\n\t\tproperties?: Map<string, unknown>;\n\t}\n\n\texport function toService<T extends object>(channel: IChannel, options?: ICreateProxyServiceOptions): T {\n\t\tconst disableMarshalling = options && options.disableMarshalling;\n\n\t\treturn new Proxy({}, {\n\t\t\tget(_target: T, propKey: PropertyKey) {\n\t\t\t\tif (typeof propKey === 'string') {\n\n\t\t\t\t\t// Check for predefined values\n\t\t\t\t\tif (options?.properties?.has(propKey)) {\n\t\t\t\t\t\treturn options.properties.get(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dynamic Event\n\t\t\t\t\tif (propertyIsDynamicEvent(propKey)) {\n\t\t\t\t\t\treturn function (arg: any) {\n\t\t\t\t\t\t\treturn channel.listen(propKey, arg);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Event\n\t\t\t\t\tif (propertyIsEvent(propKey)) {\n\t\t\t\t\t\treturn channel.listen(propKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Function\n\t\t\t\t\treturn async function (...args: any[]) {\n\n\t\t\t\t\t\t// Add context if any\n\t\t\t\t\t\tlet methodArgs: any[];\n\t\t\t\t\t\tif (options && !isUndefinedOrNull(options.context)) {\n\t\t\t\t\t\t\tmethodArgs = [options.context, ...args];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmethodArgs = args;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = await channel.call(propKey, methodArgs);\n\n\t\t\t\t\t\t// Revive unless marshalling disabled\n\t\t\t\t\t\tif (!disableMarshalling) {\n\t\t\t\t\t\t\treturn revive(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Property not found: ${String(propKey)}`);\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tfunction propertyIsEvent(name: string): boolean {\n\t\t// Assume a property is an event if it has a form of \"onSomething\"\n\t\treturn name[0] === 'o' && name[1] === 'n' && strings.isUpperAsciiLetter(name.charCodeAt(2));\n\t}\n\n\tfunction propertyIsDynamicEvent(name: string): boolean {\n\t\t// Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n\t\treturn /^onDynamic/.test(name) && strings.isUpperAsciiLetter(name.charCodeAt(9));\n\t}\n}\n\nconst colorTables = [\n\t['#2977B1', '#FC802D', '#34A13A', '#D3282F', '#9366BA'],\n\t['#8B564C', '#E177C0', '#7F7F7F', '#BBBE3D', '#2EBECD']\n];\n\nfunction prettyWithoutArrays(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data;\n\t}\n\tif (data && typeof data === 'object' && typeof data.toString === 'function') {\n\t\tconst result = data.toString();\n\t\tif (result !== '[object Object]') {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction pretty(data: any): any {\n\tif (Array.isArray(data)) {\n\t\treturn data.map(prettyWithoutArrays);\n\t}\n\treturn prettyWithoutArrays(data);\n}\n\nexport function logWithColors(direction: string, totalLength: number, msgLength: number, req: number, initiator: RequestInitiator, str: string, data: any): void {\n\tdata = pretty(data);\n\n\tconst colorTable = colorTables[initiator];\n\tconst color = colorTable[req % colorTable.length];\n\tlet args = [`%c[${direction}]%c[${String(totalLength).padStart(7, ' ')}]%c[len: ${String(msgLength).padStart(5, ' ')}]%c${String(req).padStart(5, ' ')} - ${str}`, 'color: darkgreen', 'color: grey', 'color: grey', `color: ${color}`];\n\tif (/\\($/.test(str)) {\n\t\targs = args.concat(data);\n\t\targs.push(')');\n\t} else {\n\t\targs.push(data);\n\t}\n\tconsole.log.apply(console, args as [string, ...string[]]);\n}\n\nexport class IPCLogger implements IIPCLogger {\n\tprivate _totalIncoming = 0;\n\tprivate _totalOutgoing = 0;\n\n\tconstructor(\n\t\tprivate readonly _outgoingPrefix: string,\n\t\tprivate readonly _incomingPrefix: string,\n\t) { }\n\n\tpublic logOutgoing(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalOutgoing += msgLength;\n\t\tlogWithColors(this._outgoingPrefix, this._totalOutgoing, msgLength, requestId, initiator, str, data);\n\t}\n\n\tpublic logIncoming(msgLength: number, requestId: number, initiator: RequestInitiator, str: string, data?: any): void {\n\t\tthis._totalIncoming += msgLength;\n\t\tlogWithColors(this._incomingPrefix, this._totalIncoming, msgLength, requestId, initiator, str, data);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as types from 'vs/base/common/types';\nimport * as nls from 'vs/nls';\nimport { IAction } from 'vs/base/common/actions';\n\nfunction exceptionToErrorMessage(exception: any, verbose: boolean): string {\n\tif (verbose && (exception.stack || exception.stacktrace)) {\n\t\treturn nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));\n\t}\n\n\treturn detectSystemErrorMessage(exception);\n}\n\nfunction stackToString(stack: string[] | string | undefined): string | undefined {\n\tif (Array.isArray(stack)) {\n\t\treturn stack.join('\\n');\n\t}\n\n\treturn stack;\n}\n\nfunction detectSystemErrorMessage(exception: any): string {\n\n\t// See https://nodejs.org/api/errors.html#errors_class_system_error\n\tif (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n\t\treturn nls.localize('nodeExceptionMessage', \"A system error occurred ({0})\", exception.message);\n\t}\n\n\treturn exception.message || nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n *\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error: any = null, verbose: boolean = false): string {\n\tif (!error) {\n\t\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n\t}\n\n\tif (Array.isArray(error)) {\n\t\tconst errors: any[] = arrays.coalesce(error);\n\t\tconst msg = toErrorMessage(errors[0], verbose);\n\n\t\tif (errors.length > 1) {\n\t\t\treturn nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n\t\t}\n\n\t\treturn msg;\n\t}\n\n\tif (types.isString(error)) {\n\t\treturn error;\n\t}\n\n\tif (error.detail) {\n\t\tconst detail = error.detail;\n\n\t\tif (detail.error) {\n\t\t\treturn exceptionToErrorMessage(detail.error, verbose);\n\t\t}\n\n\t\tif (detail.exception) {\n\t\t\treturn exceptionToErrorMessage(detail.exception, verbose);\n\t\t}\n\t}\n\n\tif (error.stack) {\n\t\treturn exceptionToErrorMessage(error, verbose);\n\t}\n\n\tif (error.message) {\n\t\treturn error.message;\n\t}\n\n\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n\n\nexport interface IErrorWithActions extends Error {\n\tactions: IAction[];\n}\n\nexport function isErrorWithActions(obj: unknown): obj is IErrorWithActions {\n\tconst candidate = obj as IErrorWithActions | undefined;\n\n\treturn candidate instanceof Error && Array.isArray(candidate.actions);\n}\n\nexport function createErrorWithActions(messageOrError: string | Error, actions: IAction[]): IErrorWithActions {\n\tlet error: IErrorWithActions;\n\tif (typeof messageOrError === 'string') {\n\t\terror = new Error(messageOrError) as IErrorWithActions;\n\t} else {\n\t\terror = messageOrError as IErrorWithActions;\n\t}\n\n\terror.actions = actions;\n\n\treturn error;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as cp from 'child_process';\nimport { Stats } from 'fs';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as extpath from 'vs/base/common/extpath';\nimport { FileAccess } from 'vs/base/common/network';\nimport * as Objects from 'vs/base/common/objects';\nimport * as path from 'vs/base/common/path';\nimport * as Platform from 'vs/base/common/platform';\nimport * as process from 'vs/base/common/process';\nimport { CommandOptions, Executable, ForkOptions, Source, SuccessData, TerminateResponse, TerminateResponseCode } from 'vs/base/common/processes';\nimport * as Types from 'vs/base/common/types';\nimport { LineDecoder } from 'vs/base/node/decoder';\nimport * as pfs from 'vs/base/node/pfs';\nimport * as nls from 'vs/nls';\nexport { CommandOptions, ForkOptions, SuccessData, Source, TerminateResponse, TerminateResponseCode };\n\nexport type ValueCallback<T> = (value: T | Promise<T>) => void;\nexport type ErrorCallback = (error?: any) => void;\nexport type ProgressCallback<T> = (progress: T) => void;\n\nexport interface LineData {\n\tline: string;\n\tsource: Source;\n}\n\nfunction getWindowsCode(status: number): TerminateResponseCode {\n\tswitch (status) {\n\t\tcase 0:\n\t\t\treturn TerminateResponseCode.Success;\n\t\tcase 1:\n\t\t\treturn TerminateResponseCode.AccessDenied;\n\t\tcase 128:\n\t\t\treturn TerminateResponseCode.ProcessNotFound;\n\t\tdefault:\n\t\t\treturn TerminateResponseCode.Unknown;\n\t}\n}\n\nfunction terminateProcess(process: cp.ChildProcess, cwd?: string): Promise<TerminateResponse> {\n\tif (Platform.isWindows) {\n\t\ttry {\n\t\t\tconst options: any = {\n\t\t\t\tstdio: ['pipe', 'pipe', 'ignore']\n\t\t\t};\n\t\t\tif (cwd) {\n\t\t\t\toptions.cwd = cwd;\n\t\t\t}\n\t\t\tconst killProcess = cp.execFile('taskkill', ['/T', '/F', '/PID', process.pid!.toString()], options);\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tkillProcess.once('error', (err) => {\n\t\t\t\t\tresolve({ success: false, error: err });\n\t\t\t\t});\n\t\t\t\tkillProcess.once('exit', (code, signal) => {\n\t\t\t\t\tif (code === 0) {\n\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ success: false, code: code !== null ? code : TerminateResponseCode.Unknown });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn Promise.resolve({ success: false, error: err, code: err.status ? getWindowsCode(err.status) : TerminateResponseCode.Unknown });\n\t\t}\n\t} else if (Platform.isLinux || Platform.isMacintosh) {\n\t\ttry {\n\t\t\tconst cmd = FileAccess.asFileUri('vs/base/node/terminateProcess.sh', require).fsPath;\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tcp.execFile(cmd, [process.pid!.toString()], { encoding: 'utf8', shell: true } as cp.ExecFileOptions, (err, stdout, stderr) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tresolve({ success: false, error: err });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve({ success: true });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn Promise.resolve({ success: false, error: err });\n\t\t}\n\t} else {\n\t\tprocess.kill('SIGKILL');\n\t}\n\treturn Promise.resolve({ success: true });\n}\n\nexport function getWindowsShell(env = process.env as Platform.IProcessEnvironment): string {\n\treturn env['comspec'] || 'cmd.exe';\n}\n\nexport abstract class AbstractProcess<TProgressData> {\n\tprivate cmd: string;\n\tprivate args: string[];\n\tprivate options: CommandOptions | ForkOptions;\n\tprotected shell: boolean;\n\n\tprivate childProcess: cp.ChildProcess | null;\n\tprotected childProcessPromise: Promise<cp.ChildProcess> | null;\n\tprivate pidResolve: ValueCallback<number> | undefined;\n\tprotected terminateRequested: boolean;\n\n\tprivate static WellKnowCommands: IStringDictionary<boolean> = {\n\t\t'ant': true,\n\t\t'cmake': true,\n\t\t'eslint': true,\n\t\t'gradle': true,\n\t\t'grunt': true,\n\t\t'gulp': true,\n\t\t'jake': true,\n\t\t'jenkins': true,\n\t\t'jshint': true,\n\t\t'make': true,\n\t\t'maven': true,\n\t\t'msbuild': true,\n\t\t'msc': true,\n\t\t'nmake': true,\n\t\t'npm': true,\n\t\t'rake': true,\n\t\t'tsc': true,\n\t\t'xbuild': true\n\t};\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[] | undefined, shell: boolean, options: CommandOptions | undefined);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean, arg4?: CommandOptions) {\n\t\tif (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n\t\t\tthis.cmd = <string>arg1;\n\t\t\tthis.args = arg2;\n\t\t\tthis.shell = arg3;\n\t\t\tthis.options = arg4;\n\t\t} else {\n\t\t\tconst executable = <Executable>arg1;\n\t\t\tthis.cmd = executable.command;\n\t\t\tthis.shell = executable.isShellCommand;\n\t\t\tthis.args = executable.args.slice(0);\n\t\t\tthis.options = executable.options || {};\n\t\t}\n\n\t\tthis.childProcess = null;\n\t\tthis.childProcessPromise = null;\n\t\tthis.terminateRequested = false;\n\n\t\tif (this.options.env) {\n\t\t\tconst newEnv: IStringDictionary<string> = Object.create(null);\n\t\t\tObject.keys(process.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = process.env[key]!;\n\t\t\t});\n\t\t\tObject.keys(this.options.env).forEach((key) => {\n\t\t\t\tnewEnv[key] = this.options.env![key]!;\n\t\t\t});\n\t\t\tthis.options.env = newEnv;\n\t\t}\n\t}\n\n\tpublic getSanitizedCommand(): string {\n\t\tlet result = this.cmd.toLowerCase();\n\t\tconst index = result.lastIndexOf(path.sep);\n\t\tif (index !== -1) {\n\t\t\tresult = result.substring(index + 1);\n\t\t}\n\t\tif (AbstractProcess.WellKnowCommands[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn 'other';\n\t}\n\n\tpublic start(pp: ProgressCallback<TProgressData>): Promise<SuccessData> {\n\t\tif (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n\t\t\treturn Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n\t\t}\n\t\treturn this.useExec().then((useExec) => {\n\t\t\tlet cc: ValueCallback<SuccessData>;\n\t\t\tlet ee: ErrorCallback;\n\t\t\tconst result = new Promise<any>((c, e) => {\n\t\t\t\tcc = c;\n\t\t\t\tee = e;\n\t\t\t});\n\n\t\t\tif (useExec) {\n\t\t\t\tlet cmd: string = this.cmd;\n\t\t\t\tif (this.args) {\n\t\t\t\t\tcmd = cmd + ' ' + this.args.join(' ');\n\t\t\t\t}\n\t\t\t\tthis.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tconst err: any = error;\n\t\t\t\t\t// This is tricky since executing a command shell reports error back in case the executed command return an\n\t\t\t\t\t// error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n\t\t\t\t\t// always parse the output and report success unless the job got killed.\n\t\t\t\t\tif (err && err.killed) {\n\t\t\t\t\t\tee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleExec(cc, pp, error, stdout as any, stderr as any);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet childProcess: cp.ChildProcess | null = null;\n\t\t\t\tconst closeHandler = (data: any) => {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\tthis.childProcessPromise = null;\n\t\t\t\t\tthis.handleClose(data, cc, pp, ee);\n\t\t\t\t\tconst result: SuccessData = {\n\t\t\t\t\t\tterminated: this.terminateRequested\n\t\t\t\t\t};\n\t\t\t\t\tif (Types.isNumber(data)) {\n\t\t\t\t\t\tresult.cmdCode = <number>data;\n\t\t\t\t\t}\n\t\t\t\t\tcc(result);\n\t\t\t\t};\n\t\t\t\tif (this.shell && Platform.isWindows) {\n\t\t\t\t\tconst options: any = Objects.deepClone(this.options);\n\t\t\t\t\toptions.windowsVerbatimArguments = true;\n\t\t\t\t\toptions.detached = false;\n\t\t\t\t\tlet quotedCommand: boolean = false;\n\t\t\t\t\tlet quotedArg: boolean = false;\n\t\t\t\t\tconst commandLine: string[] = [];\n\t\t\t\t\tlet quoted = this.ensureQuotes(this.cmd);\n\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\tquotedCommand = quoted.quoted;\n\t\t\t\t\tif (this.args) {\n\t\t\t\t\t\tthis.args.forEach((elem) => {\n\t\t\t\t\t\t\tquoted = this.ensureQuotes(elem);\n\t\t\t\t\t\t\tcommandLine.push(quoted.value);\n\t\t\t\t\t\t\tquotedArg = quotedArg && quoted.quoted;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tconst args: string[] = [\n\t\t\t\t\t\t'/s',\n\t\t\t\t\t\t'/c',\n\t\t\t\t\t];\n\t\t\t\t\tif (quotedCommand) {\n\t\t\t\t\t\tif (quotedArg) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine.join(' ') + '\"');\n\t\t\t\t\t\t} else if (commandLine.length > 1) {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs.push('\"' + commandLine[0] + '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push(commandLine.join(' '));\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess = cp.spawn(getWindowsShell(), args, options);\n\t\t\t\t} else {\n\t\t\t\t\tif (this.cmd) {\n\t\t\t\t\t\tchildProcess = cp.spawn(this.cmd, this.args, this.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (childProcess) {\n\t\t\t\t\tthis.childProcess = childProcess;\n\t\t\t\t\tthis.childProcessPromise = Promise.resolve(childProcess);\n\t\t\t\t\tif (this.pidResolve) {\n\t\t\t\t\t\tthis.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n\t\t\t\t\t\tthis.pidResolve = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tchildProcess.on('error', (error: Error) => {\n\t\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t\t\tee({ terminated: this.terminateRequested, error: error });\n\t\t\t\t\t});\n\t\t\t\t\tif (childProcess.pid) {\n\t\t\t\t\t\tthis.childProcess.on('close', closeHandler);\n\t\t\t\t\t\tthis.handleSpawn(childProcess, cc!, pp, ee!, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tprotected abstract handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, error: Error | null, stdout: Buffer, stderr: Buffer): void;\n\tprotected abstract handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback, sync: boolean): void;\n\n\tprotected handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<TProgressData>, ee: ErrorCallback): void {\n\t\t// Default is to do nothing.\n\t}\n\n\tprivate static readonly regexp = /^[^\"].* .*[^\"]/;\n\tprivate ensureQuotes(value: string) {\n\t\tif (AbstractProcess.regexp.test(value)) {\n\t\t\treturn {\n\t\t\t\tvalue: '\"' + value + '\"', //`\"${value}\"`,\n\t\t\t\tquoted: true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tquoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic get pid(): Promise<number> {\n\t\tif (this.childProcessPromise) {\n\t\t\treturn this.childProcessPromise.then(childProcess => childProcess.pid!, err => -1);\n\t\t} else {\n\t\t\treturn new Promise<number>((resolve) => {\n\t\t\t\tthis.pidResolve = resolve;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic terminate(): Promise<TerminateResponse> {\n\t\tif (!this.childProcessPromise) {\n\t\t\treturn Promise.resolve<TerminateResponse>({ success: true });\n\t\t}\n\t\treturn this.childProcessPromise.then((childProcess) => {\n\t\t\tthis.terminateRequested = true;\n\t\t\treturn terminateProcess(childProcess, this.options.cwd).then(response => {\n\t\t\t\tif (response.success) {\n\t\t\t\t\tthis.childProcess = null;\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t});\n\t\t}, (err) => {\n\t\t\treturn { success: true };\n\t\t});\n\t}\n\n\tprivate useExec(): Promise<boolean> {\n\t\treturn new Promise<boolean>(resolve => {\n\t\t\tif (!this.shell || !Platform.isWindows) {\n\t\t\t\treturn resolve(false);\n\t\t\t}\n\t\t\tconst cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n\t\t\tcmdShell.on('error', (error: Error) => {\n\t\t\t\treturn resolve(true);\n\t\t\t});\n\t\t\tcmdShell.on('exit', (data: any) => {\n\t\t\t\treturn resolve(false);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport class LineProcess extends AbstractProcess<LineData> {\n\n\tprivate stdoutLineDecoder: LineDecoder | null;\n\tprivate stderrLineDecoder: LineDecoder | null;\n\n\tpublic constructor(executable: Executable);\n\tpublic constructor(cmd: string, args: string[], shell: boolean, options: CommandOptions);\n\tpublic constructor(arg1: string | Executable, arg2?: string[], arg3?: boolean | ForkOptions, arg4?: CommandOptions) {\n\t\tsuper(<any>arg1, arg2, <any>arg3, arg4);\n\n\t\tthis.stdoutLineDecoder = null;\n\t\tthis.stderrLineDecoder = null;\n\t}\n\n\tprotected handleExec(cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, error: Error, stdout: Buffer, stderr: Buffer) {\n\t\t[stdout, stderr].forEach((buffer: Buffer, index: number) => {\n\t\t\tconst lineDecoder = new LineDecoder();\n\t\t\tconst lines = lineDecoder.write(buffer);\n\t\t\tlines.forEach((line) => {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t});\n\t\t\tconst line = lineDecoder.end();\n\t\t\tif (line) {\n\t\t\t\tpp({ line: line, source: index === 0 ? Source.stdout : Source.stderr });\n\t\t\t}\n\t\t});\n\t\tcc({ terminated: this.terminateRequested, error: error });\n\t}\n\n\tprotected handleSpawn(childProcess: cp.ChildProcess, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback, sync: boolean): void {\n\t\tconst stdoutLineDecoder = new LineDecoder();\n\t\tconst stderrLineDecoder = new LineDecoder();\n\t\tchildProcess.stdout!.on('data', (data: Buffer) => {\n\t\t\tconst lines = stdoutLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stdout }));\n\t\t});\n\t\tchildProcess.stderr!.on('data', (data: Buffer) => {\n\t\t\tconst lines = stderrLineDecoder.write(data);\n\t\t\tlines.forEach(line => pp({ line: line, source: Source.stderr }));\n\t\t});\n\n\t\tthis.stdoutLineDecoder = stdoutLineDecoder;\n\t\tthis.stderrLineDecoder = stderrLineDecoder;\n\t}\n\n\tprotected override handleClose(data: any, cc: ValueCallback<SuccessData>, pp: ProgressCallback<LineData>, ee: ErrorCallback): void {\n\t\tconst stdoutLine = this.stdoutLineDecoder ? this.stdoutLineDecoder.end() : null;\n\t\tif (stdoutLine) {\n\t\t\tpp({ line: stdoutLine, source: Source.stdout });\n\t\t}\n\t\tconst stderrLine = this.stderrLineDecoder ? this.stderrLineDecoder.end() : null;\n\t\tif (stderrLine) {\n\t\t\tpp({ line: stderrLine, source: Source.stderr });\n\t\t}\n\t}\n}\n\nexport interface IQueuedSender {\n\tsend: (msg: any) => void;\n}\n\n// Wrapper around process.send() that will queue any messages if the internal node.js\n// queue is filled with messages and only continue sending messages when the internal\n// queue is free again to consume messages.\n// On Windows we always wait for the send() method to return before sending the next message\n// to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\nexport function createQueuedSender(childProcess: cp.ChildProcess): IQueuedSender {\n\tlet msgQueue: string[] = [];\n\tlet useQueue = false;\n\n\tconst send = function (msg: any): void {\n\t\tif (useQueue) {\n\t\t\tmsgQueue.push(msg); // add to the queue if the process cannot handle more messages\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = childProcess.send(msg, (error: Error | null) => {\n\t\t\tif (error) {\n\t\t\t\tconsole.error(error); // unlikely to happen, best we can do is log this error\n\t\t\t}\n\n\t\t\tuseQueue = false; // we are good again to send directly without queue\n\n\t\t\t// now send all the messages that we have in our queue and did not send yet\n\t\t\tif (msgQueue.length > 0) {\n\t\t\t\tconst msgQueueCopy = msgQueue.slice(0);\n\t\t\t\tmsgQueue = [];\n\t\t\t\tmsgQueueCopy.forEach(entry => send(entry));\n\t\t\t}\n\t\t});\n\n\t\tif (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n\t\t\tuseQueue = true;\n\t\t}\n\t};\n\n\treturn { send };\n}\n\nexport namespace win32 {\n\texport async function findExecutable(command: string, cwd?: string, paths?: string[]): Promise<string> {\n\t\t// If we have an absolute path then we take it.\n\t\tif (path.isAbsolute(command)) {\n\t\t\treturn command;\n\t\t}\n\t\tif (cwd === undefined) {\n\t\t\tcwd = process.cwd();\n\t\t}\n\t\tconst dir = path.dirname(command);\n\t\tif (dir !== '.') {\n\t\t\t// We have a directory and the directory is relative (see above). Make the path absolute\n\t\t\t// to the current working directory.\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\t\tif (paths === undefined && Types.isString(process.env['PATH'])) {\n\t\t\tpaths = process.env['PATH'].split(path.delimiter);\n\t\t}\n\t\t// No PATH environment. Make path absolute to the cwd.\n\t\tif (paths === undefined || paths.length === 0) {\n\t\t\treturn path.join(cwd, command);\n\t\t}\n\n\t\tasync function fileExists(path: string): Promise<boolean> {\n\t\t\tif (await pfs.Promises.exists(path)) {\n\t\t\t\tlet statValue: Stats | undefined;\n\t\t\t\ttry {\n\t\t\t\t\tstatValue = await pfs.Promises.stat(path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.message.startsWith('EACCES')) {\n\t\t\t\t\t\t// it might be symlink\n\t\t\t\t\t\tstatValue = await pfs.Promises.lstat(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn statValue ? !statValue.isDirectory() : false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have a simple file name. We get the path variable from the env\n\t\t// and try to find the executable on the path.\n\t\tfor (const pathEntry of paths) {\n\t\t\t// The path entry is absolute.\n\t\t\tlet fullPath: string;\n\t\t\tif (path.isAbsolute(pathEntry)) {\n\t\t\t\tfullPath = path.join(pathEntry, command);\n\t\t\t} else {\n\t\t\t\tfullPath = path.join(cwd, pathEntry, command);\n\t\t\t}\n\t\t\tif (await fileExists(fullPath)) {\n\t\t\t\treturn fullPath;\n\t\t\t}\n\t\t\tlet withExtension = fullPath + '.com';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t\twithExtension = fullPath + '.exe';\n\t\t\tif (await fileExists(withExtension)) {\n\t\t\t\treturn withExtension;\n\t\t\t}\n\t\t}\n\t\treturn path.join(cwd, command);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChildProcess, fork, ForkOptions } from 'child_process';\nimport { createCancelablePromise, Delayer } from 'vs/base/common/async';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { isRemoteConsoleLog, log } from 'vs/base/common/console';\nimport * as errors from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { dispose, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { deepClone } from 'vs/base/common/objects';\nimport { createQueuedSender } from 'vs/base/node/processes';\nimport { removeDangerousEnvVariables } from 'vs/base/common/processes';\nimport { ChannelClient as IPCClient, ChannelServer as IPCServer, IChannel, IChannelClient } from 'vs/base/parts/ipc/common/ipc';\n\n/**\n * This implementation doesn't perform well since it uses base64 encoding for buffers.\n * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n */\n\nexport class Server<TContext extends string> extends IPCServer<TContext> {\n\tconstructor(ctx: TContext) {\n\t\tsuper({\n\t\t\tsend: r => {\n\t\t\t\ttry {\n\t\t\t\t\tprocess.send?.((<Buffer>r.buffer).toString('base64'));\n\t\t\t\t} catch (e) { /* not much to do */ }\n\t\t\t},\n\t\t\tonMessage: Event.fromNodeEventEmitter(process, 'message', msg => VSBuffer.wrap(Buffer.from(msg, 'base64')))\n\t\t}, ctx);\n\n\t\tprocess.once('disconnect', () => this.dispose());\n\t}\n}\n\nexport interface IIPCOptions {\n\n\t/**\n\t * A descriptive name for the server this connection is to. Used in logging.\n\t */\n\tserverName: string;\n\n\t/**\n\t * Time in millies before killing the ipc process. The next request after killing will start it again.\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Arguments to the module to execute.\n\t */\n\targs?: string[];\n\n\t/**\n\t * Environment key-value pairs to be passed to the process that gets spawned for the ipc.\n\t */\n\tenv?: any;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application executed.\n\t */\n\tdebug?: number;\n\n\t/**\n\t * Allows to assign a debug port for debugging the application and breaking it on the first line.\n\t */\n\tdebugBrk?: number;\n\n\t/**\n\t * If set, starts the fork with empty execArgv. If not set, execArgv from the parent process are inherited,\n\t * except --inspect= and --inspect-brk= which are filtered as they would result in a port conflict.\n\t */\n\tfreshExecArgv?: boolean;\n\n\t/**\n\t * Enables our createQueuedSender helper for this Client. Uses a queue when the internal Node.js queue is\n\t * full of messages - see notes on that method.\n\t */\n\tuseQueue?: boolean;\n}\n\nexport class Client implements IChannelClient, IDisposable {\n\n\tprivate disposeDelayer: Delayer<void> | undefined;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate child: ChildProcess | null;\n\tprivate _client: IPCClient | null;\n\tprivate channels = new Map<string, IChannel>();\n\n\tprivate readonly _onDidProcessExit = new Emitter<{ code: number; signal: string }>();\n\treadonly onDidProcessExit = this._onDidProcessExit.event;\n\n\tconstructor(private modulePath: string, private options: IIPCOptions) {\n\t\tconst timeout = options && options.timeout ? options.timeout : 60000;\n\t\tthis.disposeDelayer = new Delayer<void>(timeout);\n\t\tthis.child = null;\n\t\tthis._client = null;\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\t\treturn that.requestPromise<T>(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg?: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprotected requestPromise<T>(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Promise.reject(new Error('disposed'));\n\t\t}\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tconst channel = this.getCachedChannel(channelName);\n\t\tconst result = createCancelablePromise(token => channel.call<T>(name, arg, token));\n\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n\n\t\tconst disposable = toDisposable(() => result.cancel());\n\t\tthis.activeRequests.add(disposable);\n\n\t\tresult.finally(() => {\n\t\t\tcancellationTokenListener.dispose();\n\t\t\tthis.activeRequests.delete(disposable);\n\n\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tprotected requestEvent<T>(channelName: string, name: string, arg?: any): Event<T> {\n\t\tif (!this.disposeDelayer) {\n\t\t\treturn Event.None;\n\t\t}\n\n\t\tthis.disposeDelayer.cancel();\n\n\t\tlet listener: IDisposable;\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tconst channel = this.getCachedChannel(channelName);\n\t\t\t\tconst event: Event<T> = channel.listen(name, arg);\n\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t\tthis.activeRequests.add(listener);\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tthis.activeRequests.delete(listener);\n\t\t\t\tlistener.dispose();\n\n\t\t\t\tif (this.activeRequests.size === 0 && this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.trigger(() => this.disposeClient());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate get client(): IPCClient {\n\t\tif (!this._client) {\n\t\t\tconst args = this.options && this.options.args ? this.options.args : [];\n\t\t\tconst forkOpts: ForkOptions = Object.create(null);\n\n\t\t\tforkOpts.env = { ...deepClone(process.env), 'VSCODE_PARENT_PID': String(process.pid) };\n\n\t\t\tif (this.options && this.options.env) {\n\t\t\t\tforkOpts.env = { ...forkOpts.env, ...this.options.env };\n\t\t\t}\n\n\t\t\tif (this.options && this.options.freshExecArgv) {\n\t\t\t\tforkOpts.execArgv = [];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debug === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n\t\t\t}\n\n\t\t\tif (this.options && typeof this.options.debugBrk === 'number') {\n\t\t\t\tforkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n\t\t\t}\n\n\t\t\tif (forkOpts.execArgv === undefined) {\n\t\t\t\t// if not set, the forked process inherits the execArgv of the parent process\n\t\t\t\t// --inspect and --inspect-brk can not be inherited as the port would conflict\n\t\t\t\tforkOpts.execArgv = process.execArgv.filter(a => !/^--inspect(-brk)?=/.test(a)); // remove\n\t\t\t}\n\n\t\t\tremoveDangerousEnvVariables(forkOpts.env);\n\n\t\t\tthis.child = fork(this.modulePath, args, forkOpts);\n\n\t\t\tconst onMessageEmitter = new Emitter<VSBuffer>();\n\t\t\tconst onRawMessage = Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n\n\t\t\tonRawMessage(msg => {\n\n\t\t\t\t// Handle remote console logs specially\n\t\t\t\tif (isRemoteConsoleLog(msg)) {\n\t\t\t\t\tlog(msg, `IPC Library: ${this.options.serverName}`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Anything else goes to the outside\n\t\t\t\tonMessageEmitter.fire(VSBuffer.wrap(Buffer.from(msg, 'base64')));\n\t\t\t});\n\n\t\t\tconst sender = this.options.useQueue ? createQueuedSender(this.child) : this.child;\n\t\t\tconst send = (r: VSBuffer) => this.child && this.child.connected && sender.send((<Buffer>r.buffer).toString('base64'));\n\t\t\tconst onMessage = onMessageEmitter.event;\n\t\t\tconst protocol = { send, onMessage };\n\n\t\t\tthis._client = new IPCClient(protocol);\n\n\t\t\tconst onExit = () => this.disposeClient();\n\t\t\tprocess.once('exit', onExit);\n\n\t\t\tthis.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n\n\t\t\tthis.child.on('exit', (code: any, signal: any) => {\n\t\t\t\tprocess.removeListener('exit' as 'loaded', onExit); // https://github.com/electron/electron/issues/21475\n\n\t\t\t\tthis.activeRequests.forEach(r => dispose(r));\n\t\t\t\tthis.activeRequests.clear();\n\n\t\t\t\tif (code !== 0 && signal !== 'SIGTERM') {\n\t\t\t\t\tconsole.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n\t\t\t\t}\n\n\t\t\t\tif (this.disposeDelayer) {\n\t\t\t\t\tthis.disposeDelayer.cancel();\n\t\t\t\t}\n\t\t\t\tthis.disposeClient();\n\t\t\t\tthis._onDidProcessExit.fire({ code, signal });\n\t\t\t});\n\t\t}\n\n\t\treturn this._client;\n\t}\n\n\tprivate getCachedChannel(name: string): IChannel {\n\t\tlet channel = this.channels.get(name);\n\n\t\tif (!channel) {\n\t\t\tchannel = this.client.getChannel(name);\n\t\t\tthis.channels.set(name, channel);\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tprivate disposeClient() {\n\t\tif (this._client) {\n\t\t\tif (this.child) {\n\t\t\t\tthis.child.kill();\n\t\t\t\tthis.child = null;\n\t\t\t}\n\t\t\tthis._client = null;\n\t\t\tthis.channels.clear();\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._onDidProcessExit.dispose();\n\t\tif (this.disposeDelayer) {\n\t\t\tthis.disposeDelayer.cancel();\n\t\t\tthis.disposeDelayer = undefined;\n\t\t}\n\t\tthis.disposeClient();\n\t\tthis.activeRequests.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as descriptors from './descriptors';\nimport { ServiceCollection } from './serviceCollection';\n\n// ------ internal util\n\nexport namespace _util {\n\n\texport const serviceIds = new Map<string, ServiceIdentifier<any>>();\n\n\texport const DI_TARGET = '$di$target';\n\texport const DI_DEPENDENCIES = '$di$dependencies';\n\n\texport function getServiceDependencies(ctor: any): { id: ServiceIdentifier<any>; index: number }[] {\n\t\treturn ctor[DI_DEPENDENCIES] || [];\n\t}\n}\n\n// --- interfaces ------\n\nexport type BrandedService = { _serviceBrand: undefined };\n\nexport interface IConstructorSignature<T, Args extends any[] = []> {\n\tnew <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;\n}\n\nexport interface ServicesAccessor {\n\tget<T>(id: ServiceIdentifier<T>): T;\n}\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('instantiationService');\n\n/**\n * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments\n * to their own tuple.\n */\ntype GetLeadingNonServiceArgs<Args> =\n\tArgs extends [...BrandedService[]] ? []\n\t: Args extends [infer A, ...BrandedService[]] ? [A]\n\t: Args extends [infer A, ...infer R] ? [A, ...GetLeadingNonServiceArgs<R>]\n\t: never;\n\nexport interface IInstantiationService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Synchronously creates an instance that is denoted by the descriptor\n\t */\n\tcreateInstance<T>(descriptor: descriptors.SyncDescriptor0<T>): T;\n\tcreateInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n\n\t/**\n\t * Calls a function with a service accessor.\n\t */\n\tinvokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;\n\n\t/**\n\t * Creates a child of this service which inherits all current services\n\t * and adds/overwrites the given services.\n\t */\n\tcreateChild(services: ServiceCollection): IInstantiationService;\n}\n\n\n/**\n * Identifies a service of type `T`.\n */\nexport interface ServiceIdentifier<T> {\n\t(...args: any[]): void;\n\ttype: T;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n\tif ((target as any)[_util.DI_TARGET] === target) {\n\t\t(target as any)[_util.DI_DEPENDENCIES].push({ id, index });\n\t} else {\n\t\t(target as any)[_util.DI_DEPENDENCIES] = [{ id, index }];\n\t\t(target as any)[_util.DI_TARGET] = target;\n\t}\n}\n\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator<T>(serviceId: string): ServiceIdentifier<T> {\n\n\tif (_util.serviceIds.has(serviceId)) {\n\t\treturn _util.serviceIds.get(serviceId)!;\n\t}\n\n\tconst id = <any>function (target: Function, key: string, index: number): any {\n\t\tif (arguments.length !== 3) {\n\t\t\tthrow new Error('@IServiceName-decorator can only be used to decorate a parameter');\n\t\t}\n\t\tstoreServiceDependency(id, target, index);\n\t};\n\n\tid.toString = () => serviceId;\n\n\t_util.serviceIds.set(serviceId, id);\n\treturn id;\n}\n\nexport function refineServiceDecorator<T1, T extends T1>(serviceIdentifier: ServiceIdentifier<T1>): ServiceIdentifier<T> {\n\treturn <ServiceIdentifier<T>>serviceIdentifier;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { VSBuffer, VSBufferReadable, VSBufferReadableStream } from 'vs/base/common/buffer';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Event } from 'vs/base/common/event';\nimport { IExpression, IRelativePattern } from 'vs/base/common/glob';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { TernarySearchTree } from 'vs/base/common/map';\nimport { sep } from 'vs/base/common/path';\nimport { ReadableStreamEvents } from 'vs/base/common/stream';\nimport { startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\nimport { URI } from 'vs/base/common/uri';\nimport { localize } from 'vs/nls';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\n\n//#region file service & providers\n\nexport const IFileService = createDecorator<IFileService>('fileService');\n\nexport interface IFileService {\n\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * An event that is fired when a file system provider is added or removed\n\t */\n\treadonly onDidChangeFileSystemProviderRegistrations: Event<IFileSystemProviderRegistrationEvent>;\n\n\t/**\n\t * An event that is fired when a registered file system provider changes it's capabilities.\n\t */\n\treadonly onDidChangeFileSystemProviderCapabilities: Event<IFileSystemProviderCapabilitiesChangeEvent>;\n\n\t/**\n\t * An event that is fired when a file system provider is about to be activated. Listeners\n\t * can join this event with a long running promise to help in the activation process.\n\t */\n\treadonly onWillActivateFileSystemProvider: Event<IFileSystemProviderActivationEvent>;\n\n\t/**\n\t * Registers a file system provider for a certain scheme.\n\t */\n\tregisterProvider(scheme: string, provider: IFileSystemProvider): IDisposable;\n\n\t/**\n\t * Returns a file system provider for a certain scheme.\n\t */\n\tgetProvider(scheme: string): IFileSystemProvider | undefined;\n\n\t/**\n\t * Tries to activate a provider with the given scheme.\n\t */\n\tactivateProvider(scheme: string): Promise<void>;\n\n\t/**\n\t * Checks if this file service can handle the given resource by\n\t * first activating any extension that wants to be activated\n\t * on the provided resource scheme to include extensions that\n\t * contribute file system providers for the given resource.\n\t */\n\tcanHandleResource(resource: URI): Promise<boolean>;\n\n\t/**\n\t * Checks if the file service has a registered provider for the\n\t * provided resource.\n\t *\n\t * Note: this does NOT account for contributed providers from\n\t * extensions that have not been activated yet. To include those,\n\t * consider to call `await fileService.canHandleResource(resource)`.\n\t */\n\thasProvider(resource: URI): boolean;\n\n\t/**\n\t * Checks if the provider for the provided resource has the provided file system capability.\n\t */\n\thasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean;\n\n\t/**\n\t * List the schemes and capabilies for registered file system providers\n\t */\n\tlistCapabilities(): Iterable<{ scheme: string; capabilities: FileSystemProviderCapabilities }>;\n\n\t/**\n\t * Allows to listen for file changes. The event will fire for every file within the opened workspace\n\t * (if any) as well as all files that have been watched explicitly using the #watch() API.\n\t */\n\treadonly onDidFilesChange: Event<FileChangesEvent>;\n\n\t/**\n\t * An event that is fired upon successful completion of a certain file operation.\n\t */\n\treadonly onDidRunOperation: Event<FileOperationEvent>;\n\n\t/**\n\t * Resolve the properties of a file/folder identified by the resource. For a folder, children\n\t * information is resolved as well depending on the provided options. Use `stat()` method if\n\t * you do not need children information.\n\t *\n\t * If the optional parameter \"resolveTo\" is specified in options, the stat service is asked\n\t * to provide a stat object that should contain the full graph of folders up to all of the\n\t * target resources.\n\t *\n\t * If the optional parameter \"resolveSingleChildDescendants\" is specified in options,\n\t * the stat service is asked to automatically resolve child folders that only\n\t * contain a single element.\n\t *\n\t * If the optional parameter \"resolveMetadata\" is specified in options,\n\t * the stat will contain metadata information such as size, mtime and etag.\n\t */\n\tresolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;\n\tresolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;\n\n\t/**\n\t * Same as `resolve()` but supports resolving multiple resources in parallel.\n\t *\n\t * If one of the resolve targets fails to resolve returns a fake `IFileStat` instead of\n\t * making the whole call fail.\n\t */\n\tresolveAll(toResolve: { resource: URI; options: IResolveMetadataFileOptions }[]): Promise<IFileStatResult[]>;\n\tresolveAll(toResolve: { resource: URI; options?: IResolveFileOptions }[]): Promise<IFileStatResult[]>;\n\n\t/**\n\t * Same as `resolve()` but without resolving the children of a folder if the\n\t * resource is pointing to a folder.\n\t */\n\tstat(resource: URI): Promise<IFileStatWithPartialMetadata>;\n\n\t/**\n\t * Finds out if a file/folder identified by the resource exists.\n\t */\n\texists(resource: URI): Promise<boolean>;\n\n\t/**\n\t * Read the contents of the provided resource unbuffered.\n\t */\n\treadFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent>;\n\n\t/**\n\t * Read the contents of the provided resource buffered as stream.\n\t */\n\treadFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent>;\n\n\t/**\n\t * Updates the content replacing its previous value.\n\t *\n\t * Emits a `FileOperation.WRITE` file operation event when successful.\n\t */\n\twriteFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Moves the file/folder to a new path identified by the resource.\n\t *\n\t * The optional parameter overwrite can be set to replace an existing file at the location.\n\t *\n\t * Emits a `FileOperation.MOVE` file operation event when successful.\n\t */\n\tmove(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a move operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;\n\n\t/**\n\t * Copies the file/folder to a path identified by the resource. A folder is copied\n\t * recursively.\n\t *\n\t * Emits a `FileOperation.COPY` file operation event when successful.\n\t */\n\tcopy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a copy operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;\n\n\t/**\n\t * Clones a file to a path identified by the resource. Folders are not supported.\n\t *\n\t * If the target path exists, it will be overwritten.\n\t */\n\tcloneFile(source: URI, target: URI): Promise<void>;\n\n\t/**\n\t * Creates a new file with the given path and optional contents. The returned promise\n\t * will have the stat model object as a result.\n\t *\n\t * The optional parameter content can be used as value to fill into the new file.\n\t *\n\t * Emits a `FileOperation.CREATE` file operation event when successful.\n\t */\n\tcreateFile(resource: URI, bufferOrReadableOrStream?: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: ICreateFileOptions): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Find out if a file create operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true>;\n\n\t/**\n\t * Creates a new folder with the given path. The returned promise\n\t * will have the stat model object as a result.\n\t *\n\t * Emits a `FileOperation.CREATE` file operation event when successful.\n\t */\n\tcreateFolder(resource: URI): Promise<IFileStatWithMetadata>;\n\n\t/**\n\t * Deletes the provided file. The optional useTrash parameter allows to\n\t * move the file to trash. The optional recursive parameter allows to delete\n\t * non-empty folders recursively.\n\t *\n\t * Emits a `FileOperation.DELETE` file operation event when successful.\n\t */\n\tdel(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void>;\n\n\t/**\n\t * Find out if a delete operation is possible given the arguments. No changes on disk will\n\t * be performed. Returns an Error if the operation cannot be done.\n\t */\n\tcanDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true>;\n\n\t/**\n\t * An event that signals an error when watching for file changes.\n\t */\n\treadonly onDidWatchError: Event<Error>;\n\n\t/**\n\t * Allows to start a watcher that reports file/folder change events on the provided resource.\n\t *\n\t * Note: recursive file watching is not supported from this method. Only events from files\n\t * that are direct children of the provided resource will be reported.\n\t */\n\twatch(resource: URI, options?: IWatchOptions): IDisposable;\n\n\t/**\n\t * Frees up any resources occupied by this service.\n\t */\n\tdispose(): void;\n}\n\nexport interface IFileOverwriteOptions {\n\n\t/**\n\t * Set to `true` to overwrite a file if it exists. Will\n\t * throw an error otherwise if the file does exist.\n\t */\n\treadonly overwrite: boolean;\n}\n\nexport interface IFileUnlockOptions {\n\n\t/**\n\t * Set to `true` to try to remove any write locks the file might\n\t * have. A file that is write locked will throw an error for any\n\t * attempt to write to unless `unlock: true` is provided.\n\t */\n\treadonly unlock: boolean;\n}\n\nexport interface IFileAtomicReadOptions {\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `readFile` method is not running in parallel with\n\t * any `write` operations in the same process.\n\t *\n\t * Typically you should not need to use this flag but if\n\t * for example you are quickly reading a file right after\n\t * a file event occurred and the file changes a lot, there\n\t * is a chance that a read returns an empty or partial file\n\t * because a pending write has not finished yet.\n\t *\n\t * Note: this does not prevent the file from being written\n\t * to from a different process. If you need such atomic\n\t * operations, you better use a real database as storage.\n\t */\n\treadonly atomic: true;\n}\n\nexport interface IFileReadStreamOptions {\n\n\t/**\n\t * Is an integer specifying where to begin reading from in the file. If position is undefined,\n\t * data will be read from the current file position.\n\t */\n\treadonly position?: number;\n\n\t/**\n\t * Is an integer specifying how many bytes to read from the file. By default, all bytes\n\t * will be read.\n\t */\n\treadonly length?: number;\n\n\t/**\n\t * If provided, the size of the file will be checked against the limits.\n\t */\n\tlimits?: {\n\t\treadonly size?: number;\n\t\treadonly memory?: number;\n\t};\n}\n\nexport interface IFileWriteOptions extends IFileOverwriteOptions, IFileUnlockOptions {\n\n\t/**\n\t * Set to `true` to create a file when it does not exist. Will\n\t * throw an error otherwise if the file does not exist.\n\t */\n\treadonly create: boolean;\n}\n\nexport type IFileOpenOptions = IFileOpenForReadOptions | IFileOpenForWriteOptions;\n\nexport function isFileOpenForWriteOptions(options: IFileOpenOptions): options is IFileOpenForWriteOptions {\n\treturn options.create === true;\n}\n\nexport interface IFileOpenForReadOptions {\n\n\t/**\n\t * A hint that the file should be opened for reading only.\n\t */\n\treadonly create: false;\n}\n\nexport interface IFileOpenForWriteOptions extends IFileUnlockOptions {\n\n\t/**\n\t * A hint that the file should be opened for reading and writing.\n\t */\n\treadonly create: true;\n}\n\nexport interface IFileDeleteOptions {\n\n\t/**\n\t * Set to `true` to recursively delete any children of the file. This\n\t * only applies to folders and can lead to an error unless provided\n\t * if the folder is not empty.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * Set to `true` to attempt to move the file to trash\n\t * instead of deleting it permanently from disk. This\n\t * option maybe not be supported on all providers.\n\t */\n\treadonly useTrash: boolean;\n}\n\nexport enum FileType {\n\n\t/**\n\t * File is unknown (neither file, directory nor symbolic link).\n\t */\n\tUnknown = 0,\n\n\t/**\n\t * File is a normal file.\n\t */\n\tFile = 1,\n\n\t/**\n\t * File is a directory.\n\t */\n\tDirectory = 2,\n\n\t/**\n\t * File is a symbolic link.\n\t *\n\t * Note: even when the file is a symbolic link, you can test for\n\t * `FileType.File` and `FileType.Directory` to know the type of\n\t * the target the link points to.\n\t */\n\tSymbolicLink = 64\n}\n\nexport enum FilePermission {\n\n\t/**\n\t * File is readonly.\n\t */\n\tReadonly = 1\n}\n\nexport interface IStat {\n\n\t/**\n\t * The file type.\n\t */\n\treadonly type: FileType;\n\n\t/**\n\t * The last modification date represented as millis from unix epoch.\n\t */\n\treadonly mtime: number;\n\n\t/**\n\t * The creation date represented as millis from unix epoch.\n\t */\n\treadonly ctime: number;\n\n\t/**\n\t * The size of the file in bytes.\n\t */\n\treadonly size: number;\n\n\t/**\n\t * The file permissions.\n\t */\n\treadonly permissions?: FilePermission;\n}\n\nexport interface IWatchOptions {\n\n\t/**\n\t * Set to `true` to watch for changes recursively in a folder\n\t * and all of its children.\n\t */\n\treadonly recursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t */\n\texcludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t */\n\tincludes?: Array<string | IRelativePattern>;\n}\n\nexport const enum FileSystemProviderCapabilities {\n\n\t/**\n\t * Provider supports unbuffered read/write.\n\t */\n\tFileReadWrite = 1 << 1,\n\n\t/**\n\t * Provider supports open/read/write/close low level file operations.\n\t */\n\tFileOpenReadWriteClose = 1 << 2,\n\n\t/**\n\t * Provider supports stream based reading.\n\t */\n\tFileReadStream = 1 << 4,\n\n\t/**\n\t * Provider supports copy operation.\n\t */\n\tFileFolderCopy = 1 << 3,\n\n\t/**\n\t * Provider is path case sensitive.\n\t */\n\tPathCaseSensitive = 1 << 10,\n\n\t/**\n\t * All files of the provider are readonly.\n\t */\n\tReadonly = 1 << 11,\n\n\t/**\n\t * Provider supports to delete via trash.\n\t */\n\tTrash = 1 << 12,\n\n\t/**\n\t * Provider support to unlock files for writing.\n\t */\n\tFileWriteUnlock = 1 << 13,\n\n\t/**\n\t * Provider support to read files atomically. This implies the\n\t * provider provides the `FileReadWrite` capability too.\n\t */\n\tFileAtomicRead = 1 << 14,\n\n\t/**\n\t * Provider support to clone files atomically.\n\t */\n\tFileClone = 1 << 15\n}\n\nexport interface IFileSystemProvider {\n\n\treadonly capabilities: FileSystemProviderCapabilities;\n\treadonly onDidChangeCapabilities: Event<void>;\n\n\treadonly onDidChangeFile: Event<readonly IFileChange[]>;\n\treadonly onDidWatchError?: Event<string>;\n\twatch(resource: URI, opts: IWatchOptions): IDisposable;\n\n\tstat(resource: URI): Promise<IStat>;\n\tmkdir(resource: URI): Promise<void>;\n\treaddir(resource: URI): Promise<[string, FileType][]>;\n\tdelete(resource: URI, opts: IFileDeleteOptions): Promise<void>;\n\n\trename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;\n\tcopy?(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;\n\n\treadFile?(resource: URI): Promise<Uint8Array>;\n\twriteFile?(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;\n\n\treadFileStream?(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n\n\topen?(resource: URI, opts: IFileOpenOptions): Promise<number>;\n\tclose?(fd: number): Promise<void>;\n\tread?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n\tcloneFile?(from: URI, to: URI): Promise<void>;\n}\n\nexport interface IFileSystemProviderWithFileReadWriteCapability extends IFileSystemProvider {\n\treadFile(resource: URI): Promise<Uint8Array>;\n\twriteFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;\n}\n\nexport function hasReadWriteCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileReadWriteCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\n}\n\nexport interface IFileSystemProviderWithFileFolderCopyCapability extends IFileSystemProvider {\n\tcopy(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;\n}\n\nexport function hasFileFolderCopyCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileFolderCopyCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\n}\n\nexport interface IFileSystemProviderWithFileCloneCapability extends IFileSystemProvider {\n\tcloneFile(from: URI, to: URI): Promise<void>;\n}\n\nexport function hasFileCloneCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileCloneCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileClone);\n}\n\nexport interface IFileSystemProviderWithOpenReadWriteCloseCapability extends IFileSystemProvider {\n\topen(resource: URI, opts: IFileOpenOptions): Promise<number>;\n\tclose(fd: number): Promise<void>;\n\tread(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\twrite(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport function hasOpenReadWriteCloseCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithOpenReadWriteCloseCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\n}\n\nexport interface IFileSystemProviderWithFileReadStreamCapability extends IFileSystemProvider {\n\treadFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n}\n\nexport function hasFileReadStreamCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileReadStreamCapability {\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\n}\n\nexport interface IFileSystemProviderWithFileAtomicReadCapability extends IFileSystemProvider {\n\treadFile(resource: URI, opts?: IFileAtomicReadOptions): Promise<Uint8Array>;\n}\n\nexport function hasFileAtomicReadCapability(provider: IFileSystemProvider): provider is IFileSystemProviderWithFileAtomicReadCapability {\n\tif (!hasReadWriteCapability(provider)) {\n\t\treturn false; // we require the `FileReadWrite` capability too\n\t}\n\n\treturn !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicRead);\n}\n\nexport enum FileSystemProviderErrorCode {\n\tFileExists = 'EntryExists',\n\tFileNotFound = 'EntryNotFound',\n\tFileNotADirectory = 'EntryNotADirectory',\n\tFileIsADirectory = 'EntryIsADirectory',\n\tFileExceedsMemoryLimit = 'EntryExceedsMemoryLimit',\n\tFileTooLarge = 'EntryTooLarge',\n\tFileWriteLocked = 'EntryWriteLocked',\n\tNoPermissions = 'NoPermissions',\n\tUnavailable = 'Unavailable',\n\tUnknown = 'Unknown'\n}\n\nexport class FileSystemProviderError extends Error {\n\n\tconstructor(message: string, readonly code: FileSystemProviderErrorCode) {\n\t\tsuper(message);\n\t}\n}\n\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n\tconst providerError = new FileSystemProviderError(error.toString(), code);\n\tmarkAsFileSystemProviderError(providerError, code);\n\n\treturn providerError;\n}\n\nexport function ensureFileSystemProviderError(error?: Error): Error {\n\tif (!error) {\n\t\treturn createFileSystemProviderError(localize('unknownError', \"Unknown Error\"), FileSystemProviderErrorCode.Unknown); // https://github.com/microsoft/vscode/issues/72798\n\t}\n\n\treturn error;\n}\n\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\n\terror.name = code ? `${code} (FileSystemError)` : `FileSystemError`;\n\n\treturn error;\n}\n\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\n\n\t// Guard against abuse\n\tif (!error) {\n\t\treturn FileSystemProviderErrorCode.Unknown;\n\t}\n\n\t// FileSystemProviderError comes with the code\n\tif (error instanceof FileSystemProviderError) {\n\t\treturn error.code;\n\t}\n\n\t// Any other error, check for name match by assuming that the error\n\t// went through the markAsFileSystemProviderError() method\n\tconst match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n\tif (!match) {\n\t\treturn FileSystemProviderErrorCode.Unknown;\n\t}\n\n\tswitch (match[1]) {\n\t\tcase FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n\t\tcase FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n\t\tcase FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n\t\tcase FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n\t\tcase FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;\n\t\tcase FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n\t\tcase FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;\n\t\tcase FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n\t\tcase FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n\t}\n\n\treturn FileSystemProviderErrorCode.Unknown;\n}\n\nexport function toFileOperationResult(error: Error): FileOperationResult {\n\n\t// FileSystemProviderError comes with the result already\n\tif (error instanceof FileOperationError) {\n\t\treturn error.fileOperationResult;\n\t}\n\n\t// Otherwise try to find from code\n\tswitch (toFileSystemProviderErrorCode(error)) {\n\t\tcase FileSystemProviderErrorCode.FileNotFound:\n\t\t\treturn FileOperationResult.FILE_NOT_FOUND;\n\t\tcase FileSystemProviderErrorCode.FileIsADirectory:\n\t\t\treturn FileOperationResult.FILE_IS_DIRECTORY;\n\t\tcase FileSystemProviderErrorCode.FileNotADirectory:\n\t\t\treturn FileOperationResult.FILE_NOT_DIRECTORY;\n\t\tcase FileSystemProviderErrorCode.FileWriteLocked:\n\t\t\treturn FileOperationResult.FILE_WRITE_LOCKED;\n\t\tcase FileSystemProviderErrorCode.NoPermissions:\n\t\t\treturn FileOperationResult.FILE_PERMISSION_DENIED;\n\t\tcase FileSystemProviderErrorCode.FileExists:\n\t\t\treturn FileOperationResult.FILE_MOVE_CONFLICT;\n\t\tcase FileSystemProviderErrorCode.FileExceedsMemoryLimit:\n\t\t\treturn FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n\t\tcase FileSystemProviderErrorCode.FileTooLarge:\n\t\t\treturn FileOperationResult.FILE_TOO_LARGE;\n\t\tdefault:\n\t\t\treturn FileOperationResult.FILE_OTHER_ERROR;\n\t}\n}\n\nexport interface IFileSystemProviderRegistrationEvent {\n\treadonly added: boolean;\n\treadonly scheme: string;\n\treadonly provider?: IFileSystemProvider;\n}\n\nexport interface IFileSystemProviderCapabilitiesChangeEvent {\n\treadonly provider: IFileSystemProvider;\n\treadonly scheme: string;\n}\n\nexport interface IFileSystemProviderActivationEvent {\n\treadonly scheme: string;\n\tjoin(promise: Promise<void>): void;\n}\n\nexport const enum FileOperation {\n\tCREATE,\n\tDELETE,\n\tMOVE,\n\tCOPY,\n\tWRITE\n}\n\nexport interface IFileOperationEvent {\n\n\treadonly resource: URI;\n\treadonly operation: FileOperation;\n\n\tisOperation(operation: FileOperation.DELETE | FileOperation.WRITE): boolean;\n\tisOperation(operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY): this is IFileOperationEventWithMetadata;\n}\n\nexport interface IFileOperationEventWithMetadata extends IFileOperationEvent {\n\treadonly target: IFileStatWithMetadata;\n}\n\nexport class FileOperationEvent implements IFileOperationEvent {\n\n\tconstructor(resource: URI, operation: FileOperation.DELETE | FileOperation.WRITE);\n\tconstructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: IFileStatWithMetadata);\n\tconstructor(readonly resource: URI, readonly operation: FileOperation, readonly target?: IFileStatWithMetadata) { }\n\n\tisOperation(operation: FileOperation.DELETE | FileOperation.WRITE): boolean;\n\tisOperation(operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY): this is IFileOperationEventWithMetadata;\n\tisOperation(operation: FileOperation): boolean {\n\t\treturn this.operation === operation;\n\t}\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n\tUPDATED,\n\tADDED,\n\tDELETED\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface IFileChange {\n\n\t/**\n\t * The type of change that occurred to the file.\n\t */\n\treadonly type: FileChangeType;\n\n\t/**\n\t * The unified resource identifier of the file that changed.\n\t */\n\treadonly resource: URI;\n}\n\nexport class FileChangesEvent {\n\n\tprivate readonly added: TernarySearchTree<URI, IFileChange> | undefined = undefined;\n\tprivate readonly updated: TernarySearchTree<URI, IFileChange> | undefined = undefined;\n\tprivate readonly deleted: TernarySearchTree<URI, IFileChange> | undefined = undefined;\n\n\tconstructor(changes: readonly IFileChange[], ignorePathCasing: boolean) {\n\t\tthis.rawChanges = changes;\n\n\t\tconst entriesByType = new Map<FileChangeType, [URI, IFileChange][]>();\n\n\t\tfor (const change of changes) {\n\t\t\tconst array = entriesByType.get(change.type);\n\t\t\tif (array) {\n\t\t\t\tarray.push([change.resource, change]);\n\t\t\t} else {\n\t\t\t\tentriesByType.set(change.type, [[change.resource, change]]);\n\t\t\t}\n\n\t\t\tswitch (change.type) {\n\t\t\t\tcase FileChangeType.ADDED:\n\t\t\t\t\tthis.rawAdded.push(change.resource);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\t\tthis.rawUpdated.push(change.resource);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.DELETED:\n\t\t\t\t\tthis.rawDeleted.push(change.resource);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (const [key, value] of entriesByType) {\n\t\t\tswitch (key) {\n\t\t\t\tcase FileChangeType.ADDED:\n\t\t\t\t\tthis.added = TernarySearchTree.forUris<IFileChange>(() => ignorePathCasing);\n\t\t\t\t\tthis.added.fill(value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.UPDATED:\n\t\t\t\t\tthis.updated = TernarySearchTree.forUris<IFileChange>(() => ignorePathCasing);\n\t\t\t\t\tthis.updated.fill(value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FileChangeType.DELETED:\n\t\t\t\t\tthis.deleted = TernarySearchTree.forUris<IFileChange>(() => ignorePathCasing);\n\t\t\t\t\tthis.deleted.fill(value);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find out if the file change events match the provided resource.\n\t *\n\t * Note: when passing `FileChangeType.DELETED`, we consider a match\n\t * also when the parent of the resource got deleted.\n\t */\n\tcontains(resource: URI, ...types: FileChangeType[]): boolean {\n\t\treturn this.doContains(resource, { includeChildren: false }, ...types);\n\t}\n\n\t/**\n\t * Find out if the file change events either match the provided\n\t * resource, or contain a child of this resource.\n\t */\n\taffects(resource: URI, ...types: FileChangeType[]): boolean {\n\t\treturn this.doContains(resource, { includeChildren: true }, ...types);\n\t}\n\n\tprivate doContains(resource: URI, options: { includeChildren: boolean }, ...types: FileChangeType[]): boolean {\n\t\tif (!resource) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasTypesFilter = types.length > 0;\n\n\t\t// Added\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.ADDED)) {\n\t\t\tif (this.added?.get(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.added?.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Updated\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.UPDATED)) {\n\t\t\tif (this.updated?.get(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.updated?.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Deleted\n\t\tif (!hasTypesFilter || types.includes(FileChangeType.DELETED)) {\n\t\t\tif (this.deleted?.findSubstr(resource) /* deleted also considers parent folders */) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (options.includeChildren && this.deleted?.findSuperstr(resource)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns if this event contains added files.\n\t */\n\tgotAdded(): boolean {\n\t\treturn !!this.added;\n\t}\n\n\t/**\n\t * Returns if this event contains deleted files.\n\t */\n\tgotDeleted(): boolean {\n\t\treturn !!this.deleted;\n\t}\n\n\t/**\n\t * Returns if this event contains updated files.\n\t */\n\tgotUpdated(): boolean {\n\t\treturn !!this.updated;\n\t}\n\n\t/**\n\t * @deprecated use the `contains` or `affects` method to efficiently find\n\t * out if the event relates to a given resource. these methods ensure:\n\t * - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\treadonly rawChanges: readonly IFileChange[] = [];\n\n\t/**\n\t * @deprecated use the `contains` or `affects` method to efficiently find\n\t * out if the event relates to a given resource. these methods ensure:\n\t * - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t * - correctly handles `FileChangeType.DELETED` events\n\t */\n\treadonly rawAdded: URI[] = [];\n\n\t/**\n\t* @deprecated use the `contains` or `affects` method to efficiently find\n\t* out if the event relates to a given resource. these methods ensure:\n\t* - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t* - correctly handles `FileChangeType.DELETED` events\n\t*/\n\treadonly rawUpdated: URI[] = [];\n\n\t/**\n\t* @deprecated use the `contains` or `affects` method to efficiently find\n\t* out if the event relates to a given resource. these methods ensure:\n\t* - that there is no expensive lookup needed (by using a `TernarySearchTree`)\n\t* - correctly handles `FileChangeType.DELETED` events\n\t*/\n\treadonly rawDeleted: URI[] = [];\n}\n\nexport function isParent(path: string, candidate: string, ignoreCase?: boolean): boolean {\n\tif (!path || !candidate || path === candidate) {\n\t\treturn false;\n\t}\n\n\tif (candidate.length > path.length) {\n\t\treturn false;\n\t}\n\n\tif (candidate.charAt(candidate.length - 1) !== sep) {\n\t\tcandidate += sep;\n\t}\n\n\tif (ignoreCase) {\n\t\treturn startsWithIgnoreCase(path, candidate);\n\t}\n\n\treturn path.indexOf(candidate) === 0;\n}\n\ninterface IBaseFileStat {\n\n\t/**\n\t * The unified resource identifier of this file or folder.\n\t */\n\treadonly resource: URI;\n\n\t/**\n\t * The name which is the last segment\n\t * of the {{path}}.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * The size of the file.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly size?: number;\n\n\t/**\n\t * The last modification date represented as millis from unix epoch.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly mtime?: number;\n\n\t/**\n\t * The creation date represented as millis from unix epoch.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly ctime?: number;\n\n\t/**\n\t * A unique identifier thet represents the\n\t * current state of the file or directory.\n\t *\n\t * The value may or may not be resolved as\n\t * it is optional.\n\t */\n\treadonly etag?: string;\n\n\t/**\n\t * The file is read-only.\n\t */\n\treadonly readonly?: boolean;\n}\n\nexport interface IBaseFileStatWithMetadata extends Required<IBaseFileStat> { }\n\n/**\n * A file resource with meta information and resolved children if any.\n */\nexport interface IFileStat extends IBaseFileStat {\n\n\t/**\n\t * The resource is a file.\n\t */\n\treadonly isFile: boolean;\n\n\t/**\n\t * The resource is a directory.\n\t */\n\treadonly isDirectory: boolean;\n\n\t/**\n\t * The resource is a symbolic link. Note: even when the\n\t * file is a symbolic link, you can test for `FileType.File`\n\t * and `FileType.Directory` to know the type of the target\n\t * the link points to.\n\t */\n\treadonly isSymbolicLink: boolean;\n\n\t/**\n\t * The children of the file stat or undefined if none.\n\t */\n\tchildren: IFileStat[] | undefined;\n}\n\nexport interface IFileStatWithMetadata extends IFileStat, IBaseFileStatWithMetadata {\n\treadonly mtime: number;\n\treadonly ctime: number;\n\treadonly etag: string;\n\treadonly size: number;\n\treadonly readonly: boolean;\n\treadonly children: IFileStatWithMetadata[] | undefined;\n}\n\nexport interface IFileStatResult {\n\treadonly stat?: IFileStat;\n\treadonly success: boolean;\n}\n\nexport interface IFileStatResultWithMetadata extends IFileStatResult {\n\treadonly stat?: IFileStatWithMetadata;\n}\n\nexport interface IFileStatWithPartialMetadata extends Omit<IFileStatWithMetadata, 'children'> { }\n\nexport interface IFileContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The content of a file as buffer.\n\t */\n\treadonly value: VSBuffer;\n}\n\nexport interface IFileStreamContent extends IBaseFileStatWithMetadata {\n\n\t/**\n\t * The content of a file as stream.\n\t */\n\treadonly value: VSBufferReadableStream;\n}\n\nexport interface IBaseReadFileOptions extends IFileReadStreamOptions {\n\n\t/**\n\t * The optional etag parameter allows to return early from resolving the resource if\n\t * the contents on disk match the etag. This prevents accumulated reading of resources\n\t * that have been read already with the same etag.\n\t * It is the task of the caller to makes sure to handle this error case from the promise.\n\t */\n\treadonly etag?: string;\n}\n\nexport interface IReadFileStreamOptions extends IBaseReadFileOptions { }\n\nexport interface IReadFileOptions extends IBaseReadFileOptions {\n\n\t/**\n\t * The optional `atomic` flag can be used to make sure\n\t * the `readFile` method is not running in parallel with\n\t * any `write` operations in the same process.\n\t *\n\t * Typically you should not need to use this flag but if\n\t * for example you are quickly reading a file right after\n\t * a file event occurred and the file changes a lot, there\n\t * is a chance that a read returns an empty or partial file\n\t * because a pending write has not finished yet.\n\t *\n\t * Note: this does not prevent the file from being written\n\t * to from a different process. If you need such atomic\n\t * operations, you better use a real database as storage.\n\t */\n\treadonly atomic?: boolean;\n}\n\nexport interface IWriteFileOptions {\n\n\t/**\n\t * The last known modification time of the file. This can be used to prevent dirty writes.\n\t */\n\treadonly mtime?: number;\n\n\t/**\n\t * The etag of the file. This can be used to prevent dirty writes.\n\t */\n\treadonly etag?: string;\n\n\t/**\n\t * Whether to attempt to unlock a file before writing.\n\t */\n\treadonly unlock?: boolean;\n}\n\nexport interface IResolveFileOptions {\n\n\t/**\n\t * Automatically continue resolving children of a directory until the provided resources\n\t * are found.\n\t */\n\treadonly resolveTo?: readonly URI[];\n\n\t/**\n\t * Automatically continue resolving children of a directory if the number of children is 1.\n\t */\n\treadonly resolveSingleChildDescendants?: boolean;\n\n\t/**\n\t * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\n\t * on performance and thus should only be used when these values are required.\n\t */\n\treadonly resolveMetadata?: boolean;\n}\n\nexport interface IResolveMetadataFileOptions extends IResolveFileOptions {\n\treadonly resolveMetadata: true;\n}\n\nexport interface ICreateFileOptions {\n\n\t/**\n\t * Overwrite the file to create if it already exists on disk. Otherwise\n\t * an error will be thrown (FILE_MODIFIED_SINCE).\n\t */\n\treadonly overwrite?: boolean;\n}\n\nexport class FileOperationError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly fileOperationResult: FileOperationResult,\n\t\treadonly options?: IReadFileOptions & IWriteFileOptions & ICreateFileOptions\n\t) {\n\t\tsuper(message);\n\t}\n}\n\nexport class NotModifiedSinceFileOperationError extends FileOperationError {\n\n\tconstructor(\n\t\tmessage: string,\n\t\treadonly stat: IFileStatWithMetadata,\n\t\toptions?: IReadFileOptions\n\t) {\n\t\tsuper(message, FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n\t}\n}\n\nexport const enum FileOperationResult {\n\tFILE_IS_DIRECTORY,\n\tFILE_NOT_FOUND,\n\tFILE_NOT_MODIFIED_SINCE,\n\tFILE_MODIFIED_SINCE,\n\tFILE_MOVE_CONFLICT,\n\tFILE_WRITE_LOCKED,\n\tFILE_PERMISSION_DENIED,\n\tFILE_TOO_LARGE,\n\tFILE_INVALID_PATH,\n\tFILE_EXCEEDS_MEMORY_LIMIT,\n\tFILE_NOT_DIRECTORY,\n\tFILE_OTHER_ERROR\n}\n\n//#endregion\n\n//#region Settings\n\nexport const AutoSaveConfiguration = {\n\tOFF: 'off',\n\tAFTER_DELAY: 'afterDelay',\n\tON_FOCUS_CHANGE: 'onFocusChange',\n\tON_WINDOW_CHANGE: 'onWindowChange'\n};\n\nexport const HotExitConfiguration = {\n\tOFF: 'off',\n\tON_EXIT: 'onExit',\n\tON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'\n};\n\nexport const FILES_ASSOCIATIONS_CONFIG = 'files.associations';\nexport const FILES_EXCLUDE_CONFIG = 'files.exclude';\n\nexport interface IFilesConfiguration {\n\tfiles: {\n\t\tassociations: { [filepattern: string]: string };\n\t\texclude: IExpression;\n\t\twatcherExclude: { [filepattern: string]: boolean };\n\t\twatcherInclude: string[];\n\t\tencoding: string;\n\t\tautoGuessEncoding: boolean;\n\t\tdefaultLanguage: string;\n\t\ttrimTrailingWhitespace: boolean;\n\t\tautoSave: string;\n\t\tautoSaveDelay: number;\n\t\teol: string;\n\t\tenableTrash: boolean;\n\t\thotExit: string;\n\t\tsaveConflictResolution: 'askUser' | 'overwriteFileOnDisk';\n\t};\n}\n\n//#endregion\n\n//#region Utilities\n\nexport enum FileKind {\n\tFILE,\n\tFOLDER,\n\tROOT_FOLDER\n}\n\n/**\n * A hint to disable etag checking for reading/writing.\n */\nexport const ETAG_DISABLED = '';\n\nexport function etag(stat: { mtime: number; size: number }): string;\nexport function etag(stat: { mtime: number | undefined; size: number | undefined }): string | undefined;\nexport function etag(stat: { mtime: number | undefined; size: number | undefined }): string | undefined {\n\tif (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n\t\treturn undefined;\n\t}\n\n\treturn stat.mtime.toString(29) + stat.size.toString(31);\n}\n\nexport async function whenProviderRegistered(file: URI, fileService: IFileService): Promise<void> {\n\tif (fileService.hasProvider(URI.from({ scheme: file.scheme }))) {\n\t\treturn;\n\t}\n\n\treturn new Promise(resolve => {\n\t\tconst disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {\n\t\t\tif (e.scheme === file.scheme && e.added) {\n\t\t\t\tdisposable.dispose();\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Native only: limits for memory sizes\n */\nexport const MIN_MAX_MEMORY_SIZE_MB = 2048;\nexport const FALLBACK_MAX_MEMORY_SIZE_MB = 4096;\n\n/**\n * Helper to format a raw byte size into a human readable label.\n */\nexport class ByteSize {\n\n\tstatic readonly KB = 1024;\n\tstatic readonly MB = ByteSize.KB * ByteSize.KB;\n\tstatic readonly GB = ByteSize.MB * ByteSize.KB;\n\tstatic readonly TB = ByteSize.GB * ByteSize.KB;\n\n\tstatic formatSize(size: number): string {\n\t\tif (!isNumber(size)) {\n\t\t\tsize = 0;\n\t\t}\n\n\t\tif (size < ByteSize.KB) {\n\t\t\treturn localize('sizeB', \"{0}B\", size.toFixed(0));\n\t\t}\n\n\t\tif (size < ByteSize.MB) {\n\t\t\treturn localize('sizeKB', \"{0}KB\", (size / ByteSize.KB).toFixed(2));\n\t\t}\n\n\t\tif (size < ByteSize.GB) {\n\t\t\treturn localize('sizeMB', \"{0}MB\", (size / ByteSize.MB).toFixed(2));\n\t\t}\n\n\t\tif (size < ByteSize.TB) {\n\t\t\treturn localize('sizeGB', \"{0}GB\", (size / ByteSize.GB).toFixed(2));\n\t\t}\n\n\t\treturn localize('sizeTB', \"{0}TB\", (size / ByteSize.TB).toFixed(2));\n\t}\n}\n\n// Native only: Arch limits\n\nexport interface IArchLimits {\n\treadonly maxFileSize: number;\n\treadonly maxHeapSize: number;\n}\n\nexport const enum Arch {\n\tIA32,\n\tOTHER\n}\n\nexport function getPlatformLimits(arch: Arch): IArchLimits {\n\treturn {\n\t\tmaxFileSize: arch === Arch.IA32 ? 300 * ByteSize.MB : 16 * ByteSize.GB,  // https://github.com/microsoft/vscode/issues/30180\n\t\tmaxHeapSize: arch === Arch.IA32 ? 700 * ByteSize.MB : 2 * 700 * ByteSize.MB, // https://github.com/v8/v8/blob/5918a23a3d571b9625e5cce246bdd5b46ff7cd8b/src/heap/heap.cc#L149\n\t};\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { GLOBSTAR, IRelativePattern, parse, ParsedPattern } from 'vs/base/common/glob';\nimport { Disposable, DisposableStore, MutableDisposable } from 'vs/base/common/lifecycle';\nimport { isAbsolute } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { FileChangeType, IFileChange, isParent } from 'vs/platform/files/common/files';\n\ninterface IWatchRequest {\n\n\t/**\n\t * The path to watch.\n\t */\n\tpath: string;\n\n\t/**\n\t * Whether to watch recursively or not.\n\t */\n\trecursive: boolean;\n\n\t/**\n\t * A set of glob patterns or paths to exclude from watching.\n\t *\n\t * Paths or basic glob patterns that are relative will be\n\t * resolved to an absolute path using the currently opened\n\t * workspace. Complex glob patterns must match on absolute\n\t * paths via leading or trailing `**`.\n\t */\n\texcludes: string[];\n\n\t/**\n\t * An optional set of glob patterns or paths to include for\n\t * watching. If not provided, all paths are considered for\n\t * events.\n\t *\n\t * Paths or basic glob patterns that are relative will be\n\t * resolved to an absolute path using the currently opened\n\t * workspace. Complex glob patterns must match on absolute\n\t * paths via leading or trailing `**`.\n\t */\n\tincludes?: Array<string | IRelativePattern>;\n}\n\nexport interface INonRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be non-recursive.\n\t */\n\trecursive: false;\n}\n\nexport interface IRecursiveWatchRequest extends IWatchRequest {\n\n\t/**\n\t * The watcher will be recursive.\n\t */\n\trecursive: true;\n\n\t/**\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport function isRecursiveWatchRequest(request: IWatchRequest): request is IRecursiveWatchRequest {\n\treturn request.recursive === true;\n}\n\nexport type IUniversalWatchRequest = IRecursiveWatchRequest | INonRecursiveWatchRequest;\n\ninterface IWatcher {\n\n\t/**\n\t * A normalized file change event from the raw events\n\t * the watcher emits.\n\t */\n\treadonly onDidChangeFile: Event<IDiskFileChange[]>;\n\n\t/**\n\t * An event to indicate a message that should get logged.\n\t */\n\treadonly onDidLogMessage: Event<ILogMessage>;\n\n\t/**\n\t * An event to indicate an error occurred from the watcher\n\t * that is unrecoverable. Listeners should restart the\n\t * watcher if possible.\n\t */\n\treadonly onDidError: Event<string>;\n\n\t/**\n\t * Configures the watcher to watch according to the\n\t * requests. Any existing watched path that is not\n\t * in the array, will be removed from watching and\n\t * any new path will be added to watching.\n\t */\n\twatch(requests: IWatchRequest[]): Promise<void>;\n\n\t/**\n\t * Enable verbose logging in the watcher.\n\t */\n\tsetVerboseLogging(enabled: boolean): Promise<void>;\n\n\t/**\n\t * Stop all watchers.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport interface IRecursiveWatcher extends IWatcher {\n\twatch(requests: IRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IRecursiveWatcherOptions {\n\n\t/**\n\t * If `true`, will enable polling for all watchers, otherwise\n\t * will enable it for paths included in the string array.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tusePolling: boolean | string[];\n\n\t/**\n\t * If polling is enabled (via `usePolling`), defines the duration\n\t * in which the watcher will poll for changes.\n\t *\n\t * @deprecated this only exists for WSL1 support and should never\n\t * be used in any other case.\n\t */\n\tpollingInterval?: number;\n}\n\nexport interface INonRecursiveWatcher extends IWatcher {\n\twatch(requests: INonRecursiveWatchRequest[]): Promise<void>;\n}\n\nexport interface IUniversalWatcher extends IWatcher {\n\twatch(requests: IUniversalWatchRequest[]): Promise<void>;\n}\n\nexport abstract class AbstractWatcherClient extends Disposable {\n\n\tprivate static readonly MAX_RESTARTS = 5;\n\n\tprivate watcher: IWatcher | undefined;\n\tprivate readonly watcherDisposables = this._register(new MutableDisposable());\n\n\tprivate requests: IWatchRequest[] | undefined = undefined;\n\n\tprivate restartCounter = 0;\n\n\tconstructor(\n\t\tprivate readonly onFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tprivate readonly onLogMessage: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging: boolean,\n\t\tprivate options: {\n\t\t\ttype: string;\n\t\t\trestartOnError: boolean;\n\t\t}\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected abstract createWatcher(disposables: DisposableStore): IWatcher;\n\n\tprotected init(): void {\n\n\t\t// Associate disposables to the watcher\n\t\tconst disposables = new DisposableStore();\n\t\tthis.watcherDisposables.value = disposables;\n\n\t\t// Ask implementors to create the watcher\n\t\tthis.watcher = this.createWatcher(disposables);\n\t\tthis.watcher.setVerboseLogging(this.verboseLogging);\n\n\t\t// Wire in event handlers\n\t\tdisposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));\n\t\tdisposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));\n\t\tdisposables.add(this.watcher.onDidError(error => this.onError(error)));\n\t}\n\n\tprotected onError(error: string): void {\n\n\t\t// Restart on error (up to N times, if enabled)\n\t\tif (this.options.restartOnError) {\n\t\t\tif (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {\n\t\t\t\tthis.error(`restarting watcher after error: ${error}`);\n\t\t\t\tthis.restart(this.requests);\n\t\t\t} else {\n\t\t\t\tthis.error(`gave up attempting to restart watcher after error: ${error}`);\n\t\t\t}\n\t\t}\n\n\t\t// Do not attempt to restart if not enabled\n\t\telse {\n\t\t\tthis.error(error);\n\t\t}\n\t}\n\n\tprivate restart(requests: IUniversalWatchRequest[]): void {\n\t\tthis.restartCounter++;\n\n\t\tthis.init();\n\t\tthis.watch(requests);\n\t}\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tthis.requests = requests;\n\n\t\tawait this.watcher?.watch(requests);\n\t}\n\n\tasync setVerboseLogging(verboseLogging: boolean): Promise<void> {\n\t\tthis.verboseLogging = verboseLogging;\n\n\t\tawait this.watcher?.setVerboseLogging(verboseLogging);\n\t}\n\n\tprivate error(message: string) {\n\t\tthis.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });\n\t}\n\n\toverride dispose(): void {\n\n\t\t// Render the watcher invalid from here\n\t\tthis.watcher = undefined;\n\n\t\treturn super.dispose();\n\t}\n}\n\nexport abstract class AbstractNonRecursiveWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'node.js', restartOnError: false });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): INonRecursiveWatcher;\n}\n\nexport abstract class AbstractUniversalWatcherClient extends AbstractWatcherClient {\n\n\tconstructor(\n\t\tonFileChanges: (changes: IDiskFileChange[]) => void,\n\t\tonLogMessage: (msg: ILogMessage) => void,\n\t\tverboseLogging: boolean\n\t) {\n\t\tsuper(onFileChanges, onLogMessage, verboseLogging, { type: 'universal', restartOnError: true });\n\t}\n\n\tprotected abstract override createWatcher(disposables: DisposableStore): IUniversalWatcher;\n}\n\nexport interface IDiskFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport interface ILogMessage {\n\ttype: 'trace' | 'warn' | 'error' | 'info' | 'debug';\n\tmessage: string;\n}\n\nexport function toFileChanges(changes: IDiskFileChange[]): IFileChange[] {\n\treturn changes.map(change => ({\n\t\ttype: change.type,\n\t\tresource: uri.file(change.path)\n\t}));\n}\n\nexport function coalesceEvents(changes: IDiskFileChange[]): IDiskFileChange[] {\n\n\t// Build deltas\n\tconst coalescer = new EventCoalescer();\n\tfor (const event of changes) {\n\t\tcoalescer.processEvent(event);\n\t}\n\n\treturn coalescer.coalesce();\n}\n\nexport function normalizeWatcherPattern(path: string, pattern: string | IRelativePattern): string | IRelativePattern {\n\n\t// Patterns are always matched on the full absolute path\n\t// of the event. As such, if the pattern is not absolute\n\t// and is a string and does not start with a leading\n\t// `**`, we have to convert it to a relative pattern with\n\t// the given `base`\n\n\tif (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {\n\t\treturn { base: path, pattern };\n\t}\n\n\treturn pattern;\n}\n\nexport function parseWatcherPatterns(path: string, patterns: Array<string | IRelativePattern>): ParsedPattern[] {\n\tconst parsedPatterns: ParsedPattern[] = [];\n\n\tfor (const pattern of patterns) {\n\t\tparsedPatterns.push(parse(normalizeWatcherPattern(path, pattern)));\n\t}\n\n\treturn parsedPatterns;\n}\n\nclass EventCoalescer {\n\n\tprivate readonly coalesced = new Set<IDiskFileChange>();\n\tprivate readonly mapPathToChange = new Map<string, IDiskFileChange>();\n\n\tprivate toKey(event: IDiskFileChange): string {\n\t\tif (isLinux) {\n\t\t\treturn event.path;\n\t\t}\n\n\t\treturn event.path.toLowerCase(); // normalise to file system case sensitivity\n\t}\n\n\tprocessEvent(event: IDiskFileChange): void {\n\t\tconst existingEvent = this.mapPathToChange.get(this.toKey(event));\n\n\t\tlet keepEvent = false;\n\n\t\t// Event path already exists\n\t\tif (existingEvent) {\n\t\t\tconst currentChangeType = existingEvent.type;\n\t\t\tconst newChangeType = event.type;\n\n\t\t\t// macOS/Windows: track renames to different case\n\t\t\t// by keeping both CREATE and DELETE events\n\t\t\tif (existingEvent.path !== event.path && (event.type === FileChangeType.DELETED || event.type === FileChangeType.ADDED)) {\n\t\t\t\tkeepEvent = true;\n\t\t\t}\n\n\t\t\t// Ignore CREATE followed by DELETE in one go\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tthis.mapPathToChange.delete(this.toKey(event));\n\t\t\t\tthis.coalesced.delete(existingEvent);\n\t\t\t}\n\n\t\t\t// Flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) { }\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise keep\n\t\telse {\n\t\t\tkeepEvent = true;\n\t\t}\n\n\t\tif (keepEvent) {\n\t\t\tthis.coalesced.add(event);\n\t\t\tthis.mapPathToChange.set(this.toKey(event), event);\n\t\t}\n\t}\n\n\tcoalesce(): IDiskFileChange[] {\n\t\tconst addOrChangeEvents: IDiskFileChange[] = [];\n\t\tconst deletedPaths: string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn Array.from(this.coalesced).filter(e => {\n\t\t\tif (e.type !== FileChangeType.DELETED) {\n\t\t\t\taddOrChangeEvents.push(e);\n\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(deletedPath => isParent(e.path, deletedPath, !isLinux /* ignorecase */))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addOrChangeEvents);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { watch } from 'fs';\nimport { ThrottledDelayer, ThrottledWorker } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { basename, dirname, join } from 'vs/base/common/path';\nimport { isLinux, isMacintosh } from 'vs/base/common/platform';\nimport { realcase } from 'vs/base/node/extpath';\nimport { Promises } from 'vs/base/node/pfs';\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport { IDiskFileChange, ILogMessage, coalesceEvents, INonRecursiveWatchRequest, parseWatcherPatterns } from 'vs/platform/files/common/watcher';\n\nexport class NodeJSFileWatcherLibrary extends Disposable {\n\n\t// A delay in reacting to file deletes to support\n\t// atomic save operations where a tool may chose\n\t// to delete a file before creating it again for\n\t// an update.\n\tprivate static readonly FILE_DELETE_HANDLER_DELAY = 100;\n\n\t// A delay for collecting file changes from node.js\n\t// before collecting them for coalescing and emitting\n\t// (same delay as Parcel is using)\n\tprivate static readonly FILE_CHANGES_HANDLER_DELAY = 50;\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// These numbers are a bit more aggressive compared to the\n\t// recursive watcher because we can have many individual\n\t// node.js watchers per request.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesWorker = new ThrottledWorker<IDiskFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 100,\t// only process up to 100 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 10000 \t// ...but never buffering more than 10000 events in memory\n\t\t},\n\t\tevents => this.onDidFilesChange(events)\n\t);\n\n\tprivate readonly fileChangesDelayer = this._register(new ThrottledDelayer<void>(NodeJSFileWatcherLibrary.FILE_CHANGES_HANDLER_DELAY));\n\tprivate fileChangesBuffer: IDiskFileChange[] = [];\n\n\tprivate readonly excludes = parseWatcherPatterns(this.request.path, this.request.excludes);\n\tprivate readonly includes = this.request.includes ? parseWatcherPatterns(this.request.path, this.request.includes) : undefined;\n\n\tprivate readonly cts = new CancellationTokenSource();\n\n\treadonly ready = this.watch();\n\n\tconstructor(\n\t\tprivate request: INonRecursiveWatchRequest,\n\t\tprivate onDidFilesChange: (changes: IDiskFileChange[]) => void,\n\t\tprivate onLogMessage?: (msg: ILogMessage) => void,\n\t\tprivate verboseLogging?: boolean\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate async watch(): Promise<void> {\n\t\ttry {\n\t\t\tconst realPath = await this.normalizePath(this.request);\n\n\t\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Watch via node.js\n\t\t\tconst stat = await Promises.stat(realPath);\n\t\t\tthis._register(await this.doWatch(realPath, stat.isDirectory()));\n\n\t\t} catch (error) {\n\t\t\tif (error.code !== 'ENOENT') {\n\t\t\t\tthis.error(error);\n\t\t\t} else {\n\t\t\t\tthis.trace(error);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async normalizePath(request: INonRecursiveWatchRequest): Promise<string> {\n\t\tlet realPath = request.path;\n\n\t\ttry {\n\n\t\t\t// First check for symbolic link\n\t\t\trealPath = await Promises.realpath(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = await realcase(request.path) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn realPath;\n\t}\n\n\tprivate async doWatch(path: string, isDirectory: boolean): Promise<IDisposable> {\n\n\t\t// macOS: watching samba shares can crash VSCode so we do\n\t\t// a simple check for the file path pointing to /Volumes\n\t\t// (https://github.com/microsoft/vscode/issues/106879)\n\t\t// TODO@electron this needs a revisit when the crash is\n\t\t// fixed or mitigated upstream.\n\t\tif (isMacintosh && isEqualOrParent(path, '/Volumes/', true)) {\n\t\t\tthis.error(`Refusing to watch ${path} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);\n\n\t\t\treturn Disposable.None;\n\t\t}\n\n\t\tconst cts = new CancellationTokenSource(this.cts.token);\n\n\t\tconst disposables = new DisposableStore();\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\n\t\t\t// Creating watcher can fail with an exception\n\t\t\tconst watcher = watch(path);\n\t\t\tdisposables.add(toDisposable(() => {\n\t\t\t\twatcher.removeAllListeners();\n\t\t\t\twatcher.close();\n\t\t\t}));\n\n\t\t\tthis.trace(`Started watching: '${path}'`);\n\n\t\t\t// Folder: resolve children to emit proper events\n\t\t\tconst folderChildren = new Set<string>();\n\t\t\tif (isDirectory) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const child of await Promises.readdir(path)) {\n\t\t\t\t\t\tfolderChildren.add(child);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.error(error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst mapPathToStatDisposable = new Map<string, IDisposable>();\n\t\t\tdisposables.add(toDisposable(() => {\n\t\t\t\tfor (const [, disposable] of mapPathToStatDisposable) {\n\t\t\t\t\tdisposable.dispose();\n\t\t\t\t}\n\t\t\t\tmapPathToStatDisposable.clear();\n\t\t\t}));\n\n\t\t\twatcher.on('error', (code: number, signal: string) => {\n\t\t\t\tthis.error(`Failed to watch ${path} for changes using fs.watch() (${code}, ${signal})`);\n\n\t\t\t\t// The watcher is no longer functional reliably\n\t\t\t\t// so we go ahead and dispose it\n\t\t\t\tthis.dispose();\n\t\t\t});\n\n\t\t\twatcher.on('change', (type, raw) => {\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn; // ignore if already disposed\n\t\t\t\t}\n\n\t\t\t\tthis.trace(`[raw] [\"${type}\"] ${raw}`);\n\n\t\t\t\t// Normalize file name\n\t\t\t\tlet changedFileName = '';\n\t\t\t\tif (raw) { // https://github.com/microsoft/vscode/issues/38191\n\t\t\t\t\tchangedFileName = raw.toString();\n\t\t\t\t\tif (isMacintosh) {\n\t\t\t\t\t\t// Mac: uses NFD unicode form on disk, but we want NFC\n\t\t\t\t\t\t// See also https://github.com/nodejs/node/issues/2165\n\t\t\t\t\t\tchangedFileName = normalizeNFC(changedFileName);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!changedFileName || (type !== 'change' && type !== 'rename')) {\n\t\t\t\t\treturn; // ignore unexpected events\n\t\t\t\t}\n\n\t\t\t\t// Folder\n\t\t\t\tif (isDirectory) {\n\n\t\t\t\t\t// Folder child added/deleted\n\t\t\t\t\tif (type === 'rename') {\n\n\t\t\t\t\t\t// Cancel any previous stats for this file if existing\n\t\t\t\t\t\tmapPathToStatDisposable.get(changedFileName)?.dispose();\n\n\t\t\t\t\t\t// Wait a bit and try see if the file still exists on disk\n\t\t\t\t\t\t// to decide on the resulting event\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tmapPathToStatDisposable.delete(changedFileName);\n\n\t\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t\t// folder path is being deleted:\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// -   macOS: not reported but events continue to\n\t\t\t\t\t\t\t//            work even when the folder is brought\n\t\t\t\t\t\t\t//            back, though it seems every change\n\t\t\t\t\t\t\t//            to a file is reported as \"rename\"\n\t\t\t\t\t\t\t// -   Linux: \"rename\" event is reported with the\n\t\t\t\t\t\t\t//            name of the folder and events stop\n\t\t\t\t\t\t\t//            working\n\t\t\t\t\t\t\t// - Windows: an EPERM error is thrown that we\n\t\t\t\t\t\t\t//            handle from the `on('error')` event\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// We do not re-attach the watcher after timeout\n\t\t\t\t\t\t\t// though as we do for file watches because for\n\t\t\t\t\t\t\t// file watching specifically we want to handle\n\t\t\t\t\t\t\t// the atomic-write cases where the file is being\n\t\t\t\t\t\t\t// deleted and recreated with different contents.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Same as with recursive watching, we do not\n\t\t\t\t\t\t\t// emit a delete event in this case.\n\t\t\t\t\t\t\tif (changedFileName === pathBasename && !await Promises.exists(path)) {\n\t\t\t\t\t\t\t\tthis.warn('Watcher shutdown because watched path got deleted');\n\n\t\t\t\t\t\t\t\t// The watcher is no longer functional reliably\n\t\t\t\t\t\t\t\t// so we go ahead and dispose it\n\t\t\t\t\t\t\t\tthis.dispose();\n\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In order to properly detect renames on a case-insensitive\n\t\t\t\t\t\t\t// file system, we need to use `existsChildStrictCase` helper\n\t\t\t\t\t\t\t// because otherwise we would wrongly assume a file exists\n\t\t\t\t\t\t\t// when it was renamed to same name but different case.\n\t\t\t\t\t\t\tconst fileExists = await this.existsChildStrictCase(join(path, changedFileName));\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Figure out the correct event type:\n\t\t\t\t\t\t\t// File Exists: either 'added' or 'updated' if known before\n\t\t\t\t\t\t\t// File Does not Exist: always 'deleted'\n\t\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfolderChildren.delete(changedFileName);\n\t\t\t\t\t\t\t\ttype = FileChangeType.DELETED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.onFileChange({ path: join(this.request.path, changedFileName), type });\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\tmapPathToStatDisposable.set(changedFileName, toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Folder child changed\n\t\t\t\t\telse {\n\n\t\t\t\t\t\t// Figure out the correct event type: if this is the\n\t\t\t\t\t\t// first time we see this child, it can only be added\n\t\t\t\t\t\tlet type: FileChangeType;\n\t\t\t\t\t\tif (folderChildren.has(changedFileName)) {\n\t\t\t\t\t\t\ttype = FileChangeType.UPDATED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttype = FileChangeType.ADDED;\n\t\t\t\t\t\t\tfolderChildren.add(changedFileName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.onFileChange({ path: join(this.request.path, changedFileName), type });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// File\n\t\t\t\telse {\n\n\t\t\t\t\t// File added/deleted\n\t\t\t\t\tif (type === 'rename' || changedFileName !== pathBasename) {\n\n\t\t\t\t\t\t// Depending on the OS the watcher runs on, there\n\t\t\t\t\t\t// is different behaviour for when the watched\n\t\t\t\t\t\t// file path is being deleted:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// -   macOS: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// -   Linux: \"rename\" event is reported and events\n\t\t\t\t\t\t//            stop working\n\t\t\t\t\t\t// - Windows: \"rename\" event is reported and events\n\t\t\t\t\t\t//            continue to work when file is restored\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// As opposed to folder watching, we re-attach the\n\t\t\t\t\t\t// watcher after brief timeout to support \"atomic save\"\n\t\t\t\t\t\t// operations where a tool may decide to delete a file\n\t\t\t\t\t\t// and then create it with the updated contents.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Different to folder watching, we emit a delete event\n\t\t\t\t\t\t// though we never detect when the file is brought back\n\t\t\t\t\t\t// because the watcher is disposed then.\n\n\t\t\t\t\t\tconst timeoutHandle = setTimeout(async () => {\n\t\t\t\t\t\t\tconst fileExists = await Promises.exists(path);\n\n\t\t\t\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\treturn; // ignore if disposed by now\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File still exists, so emit as change event and reapply the watcher\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\tthis.onFileChange({ path: this.request.path, type: FileChangeType.UPDATED }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\tdisposables.add(await this.doWatch(path, false));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// File seems to be really gone, so emit a deleted event and dispose\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst eventPromise = this.onFileChange({ path: this.request.path, type: FileChangeType.DELETED }, true /* skip excludes/includes (file is explicitly watched) */);\n\n\t\t\t\t\t\t\t\t// Important to await the event delivery\n\t\t\t\t\t\t\t\t// before disposing the watcher, otherwise\n\t\t\t\t\t\t\t\t// we will loose this event.\n\t\t\t\t\t\t\t\tawait eventPromise;\n\t\t\t\t\t\t\t\tthis.dispose();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, NodeJSFileWatcherLibrary.FILE_DELETE_HANDLER_DELAY);\n\n\t\t\t\t\t\t// Very important to dispose the watcher which now points to a stale inode\n\t\t\t\t\t\t// and wire in a new disposable that tracks our timeout that is installed\n\t\t\t\t\t\tdisposables.clear();\n\t\t\t\t\t\tdisposables.add(toDisposable(() => clearTimeout(timeoutHandle)));\n\t\t\t\t\t}\n\n\t\t\t\t\t// File changed\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.onFileChange({ path: this.request.path, type: FileChangeType.UPDATED }, true /* skip excludes/includes (file is explicitly watched) */);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (await Promises.exists(path) && !cts.token.isCancellationRequested) {\n\t\t\t\tthis.error(`Failed to watch ${path} for changes using fs.watch() (${error.toString()})`);\n\t\t\t}\n\t\t}\n\n\t\treturn toDisposable(() => {\n\t\t\tcts.dispose(true);\n\t\t\tdisposables.dispose();\n\t\t});\n\t}\n\n\tprivate async onFileChange(event: IDiskFileChange, skipIncludeExcludeChecks = false): Promise<void> {\n\t\tif (this.cts.token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tthis.trace(`${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n\t\t}\n\n\t\t// Add to buffer unless excluded or not included (not if explicitly disabled)\n\t\tif (!skipIncludeExcludeChecks && this.excludes.some(exclude => exclude(event.path))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.trace(` >> ignored (excluded) ${event.path}`);\n\t\t\t}\n\t\t} else if (!skipIncludeExcludeChecks && this.includes && this.includes.length > 0 && !this.includes.some(include => include(event.path))) {\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.trace(` >> ignored (not included) ${event.path}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.fileChangesBuffer.push(event);\n\t\t}\n\n\t\t// Handle emit through delayer to accommodate for bulk changes and thus reduce spam\n\t\ttry {\n\t\t\tawait this.fileChangesDelayer.trigger(async () => {\n\t\t\t\tconst fileChanges = this.fileChangesBuffer;\n\t\t\t\tthis.fileChangesBuffer = [];\n\n\t\t\t\t// Coalesce events: merge events of same kind\n\t\t\t\tconst coalescedFileChanges = coalesceEvents(fileChanges);\n\n\t\t\t\tif (coalescedFileChanges.length > 0) {\n\n\t\t\t\t\t// Logging\n\t\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\t\tfor (const event of coalescedFileChanges) {\n\t\t\t\t\t\t\tthis.trace(`>> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Broadcast to clients via throttler\n\t\t\t\t\tconst worked = this.throttledFileChangesWorker.work(coalescedFileChanges);\n\n\t\t\t\t\t// Logging\n\t\t\t\t\tif (!worked) {\n\t\t\t\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${coalescedFileChanges.length}, most recent change: ${coalescedFileChanges[0].path}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this.throttledFileChangesWorker.pending > 0) {\n\t\t\t\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesWorker.pending}, most recent change: ${coalescedFileChanges[0].path}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (error) {\n\t\t\t// ignore (we are likely disposed and cancelled)\n\t\t}\n\t}\n\n\tprivate async existsChildStrictCase(path: string): Promise<boolean> {\n\t\tif (isLinux) {\n\t\t\treturn Promises.exists(path);\n\t\t}\n\n\t\ttry {\n\t\t\tconst pathBasename = basename(path);\n\t\t\tconst children = await Promises.readdir(dirname(path));\n\n\t\t\treturn children.some(child => child === pathBasename);\n\t\t} catch (error) {\n\t\t\tthis.trace(error);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsetVerboseLogging(verboseLogging: boolean): void {\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tprivate error(error: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'error', message: `[File Watcher (node.js)] ${error}` });\n\t\t}\n\t}\n\n\tprivate warn(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested) {\n\t\t\tthis.onLogMessage?.({ type: 'warn', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (!this.cts.token.isCancellationRequested && this.verboseLogging) {\n\t\t\tthis.onLogMessage?.({ type: 'trace', message: `[File Watcher (node.js)] ${message}` });\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tthis.trace(`stopping file watcher on ${this.request.path}`);\n\n\t\tthis.cts.dispose(true);\n\n\t\tsuper.dispose();\n\t}\n}\n\n/**\n * Watch the provided `path` for changes and return\n * the data in chunks of `Uint8Array` for further use.\n */\nexport async function watchFileContents(path: string, onData: (chunk: Uint8Array) => void, onReady: () => void, token: CancellationToken, bufferSize = 512): Promise<void> {\n\tconst handle = await Promises.open(path, 'r');\n\tconst buffer = Buffer.allocUnsafe(bufferSize);\n\n\tconst cts = new CancellationTokenSource(token);\n\n\tlet error: Error | undefined = undefined;\n\tlet isReading = false;\n\n\tconst request: INonRecursiveWatchRequest = { path, excludes: [], recursive: false };\n\tconst watcher = new NodeJSFileWatcherLibrary(request, changes => {\n\t\t(async () => {\n\t\t\tfor (const { type } of changes) {\n\t\t\t\tif (type === FileChangeType.UPDATED) {\n\n\t\t\t\t\tif (isReading) {\n\t\t\t\t\t\treturn; // return early if we are already reading the output\n\t\t\t\t\t}\n\n\t\t\t\t\tisReading = true;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Consume the new contents of the file until finished\n\t\t\t\t\t\t// everytime there is a change event signalling a change\n\t\t\t\t\t\twhile (!cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\tconst { bytesRead } = await Promises.read(handle, buffer, 0, bufferSize, null);\n\t\t\t\t\t\t\tif (!bytesRead || cts.token.isCancellationRequested) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tonData(buffer.slice(0, bytesRead));\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\terror = new Error(err);\n\t\t\t\t\t\tcts.dispose(true);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tisReading = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n\n\tawait watcher.ready;\n\tonReady();\n\n\treturn new Promise<void>((resolve, reject) => {\n\t\tcts.token.onCancellationRequested(async () => {\n\t\t\twatcher.dispose();\n\n\t\t\ttry {\n\t\t\t\tawait Promises.close(handle);\n\t\t\t} catch (err) {\n\t\t\t\terror = new Error(err);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { patternsEquals } from 'vs/base/common/glob';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { isLinux } from 'vs/base/common/platform';\nimport { IDiskFileChange, ILogMessage, INonRecursiveWatchRequest, INonRecursiveWatcher } from 'vs/platform/files/common/watcher';\nimport { NodeJSFileWatcherLibrary } from 'vs/platform/files/node/watcher/nodejs/nodejsWatcherLib';\n\nexport interface INodeJSWatcherInstance {\n\n\t/**\n\t * The watcher instance.\n\t */\n\treadonly instance: NodeJSFileWatcherLibrary;\n\n\t/**\n\t * The watch request associated to the watcher.\n\t */\n\treadonly request: INonRecursiveWatchRequest;\n}\n\nexport class NodeJSWatcher extends Disposable implements INonRecursiveWatcher {\n\n\tprivate readonly _onDidChangeFile = this._register(new Emitter<IDiskFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprivate readonly _onDidLogMessage = this._register(new Emitter<ILogMessage>());\n\treadonly onDidLogMessage = this._onDidLogMessage.event;\n\n\treadonly onDidError = Event.None;\n\n\tprotected readonly watchers = new Map<string, INodeJSWatcherInstance>();\n\n\tprivate verboseLogging = false;\n\n\tasync watch(requests: INonRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\tconst normalizedRequests = this.normalizeRequests(requests);\n\n\t\t// Gather paths that we should start watching\n\t\tconst requestsToStartWatching = normalizedRequests.filter(request => {\n\t\t\tconst watcher = this.watchers.get(request.path);\n\t\t\tif (!watcher) {\n\t\t\t\treturn true; // not yet watching that path\n\t\t\t}\n\n\t\t\t// Re-watch path if excludes or includes have changed\n\t\t\treturn !patternsEquals(watcher.request.excludes, request.excludes) || !patternsEquals(watcher.request.includes, request.includes);\n\t\t});\n\n\t\t// Gather paths that we should stop watching\n\t\tconst pathsToStopWatching = Array.from(this.watchers.values()).filter(({ request }) => {\n\t\t\treturn !normalizedRequests.find(normalizedRequest => normalizedRequest.path === request.path && patternsEquals(normalizedRequest.excludes, request.excludes) && patternsEquals(normalizedRequest.includes, request.includes));\n\t\t}).map(({ request }) => request.path);\n\n\t\t// Logging\n\n\t\tif (requestsToStartWatching.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStartWatching.map(request => `${request.path} (excludes: ${request.excludes.length > 0 ? request.excludes : '<none>'}, includes: ${request.includes && request.includes.length > 0 ? JSON.stringify(request.includes) : '<all>'})`).join(',')}`);\n\t\t}\n\n\t\tif (pathsToStopWatching.length) {\n\t\t\tthis.trace(`Request to stop watching: ${pathsToStopWatching.join(',')}`);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const pathToStopWatching of pathsToStopWatching) {\n\t\t\tthis.stopWatching(pathToStopWatching);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStartWatching) {\n\t\t\tthis.startWatching(request);\n\t\t}\n\t}\n\n\tprivate startWatching(request: INonRecursiveWatchRequest): void {\n\n\t\t// Start via node.js lib\n\t\tconst instance = new NodeJSFileWatcherLibrary(request, changes => this._onDidChangeFile.fire(changes), msg => this._onDidLogMessage.fire(msg), this.verboseLogging);\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: INodeJSWatcherInstance = { request, instance };\n\t\tthis.watchers.set(request.path, watcher);\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tfor (const [path] of this.watchers) {\n\t\t\tthis.stopWatching(path);\n\t\t}\n\n\t\tthis.watchers.clear();\n\t}\n\n\tprivate stopWatching(path: string): void {\n\t\tconst watcher = this.watchers.get(path);\n\t\tif (watcher) {\n\t\t\tthis.watchers.delete(path);\n\n\t\t\twatcher.instance.dispose();\n\t\t}\n\t}\n\n\tprivate normalizeRequests(requests: INonRecursiveWatchRequest[]): INonRecursiveWatchRequest[] {\n\t\tconst requestsMap = new Map<string, INonRecursiveWatchRequest>();\n\n\t\t// Ignore requests for the same paths\n\t\tfor (const request of requests) {\n\t\t\tconst path = isLinux ? request.path : request.path.toLowerCase(); // adjust for case sensitivity\n\t\t\trequestsMap.set(path, request);\n\t\t}\n\n\t\treturn Array.from(requestsMap.values());\n\t}\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis.verboseLogging = enabled;\n\n\t\tfor (const [, watcher] of this.watchers) {\n\t\t\twatcher.instance.setVerboseLogging(enabled);\n\t\t}\n\t}\n\n\tprivate trace(message: string): void {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message) });\n\t\t}\n\t}\n\n\tprivate toMessage(message: string, watcher?: INodeJSWatcherInstance): string {\n\t\treturn watcher ? `[File Watcher (node.js)] ${message} (path: ${watcher.request.path})` : `[File Watcher (node.js)] ${message}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as parcelWatcher from '@parcel/watcher';\nimport { existsSync, statSync, unlinkSync } from 'fs';\nimport { tmpdir } from 'os';\nimport { DeferredPromise, RunOnceScheduler, ThrottledWorker } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { toErrorMessage } from 'vs/base/common/errorMessage';\nimport { Emitter } from 'vs/base/common/event';\nimport { isEqualOrParent, randomPath } from 'vs/base/common/extpath';\nimport { GLOBSTAR, ParsedPattern, patternsEquals } from 'vs/base/common/glob';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { TernarySearchTree } from 'vs/base/common/map';\nimport { normalizeNFC } from 'vs/base/common/normalization';\nimport { dirname, isAbsolute, join, normalize, sep } from 'vs/base/common/path';\nimport { isLinux, isMacintosh, isWindows } from 'vs/base/common/platform';\nimport { rtrim } from 'vs/base/common/strings';\nimport { realcaseSync, realpathSync } from 'vs/base/node/extpath';\nimport { NodeJSFileWatcherLibrary } from 'vs/platform/files/node/watcher/nodejs/nodejsWatcherLib';\nimport { FileChangeType } from 'vs/platform/files/common/files';\nimport { IDiskFileChange, ILogMessage, coalesceEvents, IRecursiveWatchRequest, IRecursiveWatcher, parseWatcherPatterns } from 'vs/platform/files/common/watcher';\n\nexport interface IParcelWatcherInstance {\n\n\t/**\n\t * Signals when the watcher is ready to watch.\n\t */\n\treadonly ready: Promise<unknown>;\n\n\t/**\n\t * The watch request associated to the watcher.\n\t */\n\treadonly request: IRecursiveWatchRequest;\n\n\t/**\n\t * How often this watcher has been restarted in case of an unexpected\n\t * shutdown.\n\t */\n\treadonly restarts: number;\n\n\t/**\n\t * The cancellation token associated with the lifecycle of the watcher.\n\t */\n\treadonly token: CancellationToken;\n\n\t/**\n\t * Stops and disposes the watcher. This operation is async to await\n\t * unsubscribe call in Parcel.\n\t */\n\tstop(): Promise<void>;\n}\n\nexport class ParcelWatcher extends Disposable implements IRecursiveWatcher {\n\n\tprivate static readonly MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE = new Map<parcelWatcher.EventType, number>(\n\t\t[\n\t\t\t['create', FileChangeType.ADDED],\n\t\t\t['update', FileChangeType.UPDATED],\n\t\t\t['delete', FileChangeType.DELETED]\n\t\t]\n\t);\n\n\tprivate static readonly GLOB_MARKERS = {\n\t\tStar: '*',\n\t\tGlobStar: '**',\n\t\tGlobStarPosix: '**/**',\n\t\tGlobStarWindows: '**\\\\**',\n\t\tGlobStarPathStartPosix: '**/',\n\t\tGlobStarPathEndPosix: '/**',\n\t\tStarPathEndPosix: '/*',\n\t\tGlobStarPathStartWindows: '**\\\\',\n\t\tGlobStarPathEndWindows: '\\\\**'\n\t};\n\n\tprivate static readonly PARCEL_WATCHER_BACKEND = isWindows ? 'windows' : isLinux ? 'inotify' : 'fs-events';\n\n\tprivate readonly _onDidChangeFile = this._register(new Emitter<IDiskFileChange[]>());\n\treadonly onDidChangeFile = this._onDidChangeFile.event;\n\n\tprivate readonly _onDidLogMessage = this._register(new Emitter<ILogMessage>());\n\treadonly onDidLogMessage = this._onDidLogMessage.event;\n\n\tprivate readonly _onDidError = this._register(new Emitter<string>());\n\treadonly onDidError = this._onDidError.event;\n\n\tprotected readonly watchers = new Map<string, IParcelWatcherInstance>();\n\n\t// Reduce likelyhood of spam from file events via throttling.\n\t// (https://github.com/microsoft/vscode/issues/124723)\n\tprivate readonly throttledFileChangesWorker = new ThrottledWorker<IDiskFileChange>(\n\t\t{\n\t\t\tmaxWorkChunkSize: 500,\t// only process up to 500 changes at once before...\n\t\t\tthrottleDelay: 200,\t  \t// ...resting for 200ms until we process events again...\n\t\t\tmaxBufferedWork: 30000 \t// ...but never buffering more than 30000 events in memory\n\t\t},\n\t\tevents => this._onDidChangeFile.fire(events)\n\t);\n\n\tprivate verboseLogging = false;\n\tprivate enospcErrorLogged = false;\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// Error handling on process\n\t\tprocess.on('uncaughtException', error => this.onUnexpectedError(error));\n\t\tprocess.on('unhandledRejection', error => this.onUnexpectedError(error));\n\t}\n\n\tasync watch(requests: IRecursiveWatchRequest[]): Promise<void> {\n\n\t\t// Figure out duplicates to remove from the requests\n\t\tconst normalizedRequests = this.normalizeRequests(requests);\n\n\t\t// Gather paths that we should start watching\n\t\tconst requestsToStartWatching = normalizedRequests.filter(request => {\n\t\t\tconst watcher = this.watchers.get(request.path);\n\t\t\tif (!watcher) {\n\t\t\t\treturn true; // not yet watching that path\n\t\t\t}\n\n\t\t\t// Re-watch path if excludes/includes have changed or polling interval\n\t\t\treturn !patternsEquals(watcher.request.excludes, request.excludes) || !patternsEquals(watcher.request.includes, request.includes) || watcher.request.pollingInterval !== request.pollingInterval;\n\t\t});\n\n\t\t// Gather paths that we should stop watching\n\t\tconst pathsToStopWatching = Array.from(this.watchers.values()).filter(({ request }) => {\n\t\t\treturn !normalizedRequests.find(normalizedRequest => {\n\t\t\t\treturn normalizedRequest.path === request.path &&\n\t\t\t\t\tpatternsEquals(normalizedRequest.excludes, request.excludes) &&\n\t\t\t\t\tpatternsEquals(normalizedRequest.includes, request.includes) &&\n\t\t\t\t\tnormalizedRequest.pollingInterval === request.pollingInterval;\n\n\t\t\t});\n\t\t}).map(({ request }) => request.path);\n\n\t\t// Logging\n\n\t\tif (requestsToStartWatching.length) {\n\t\t\tthis.trace(`Request to start watching: ${requestsToStartWatching.map(request => `${request.path} (excludes: ${request.excludes.length > 0 ? request.excludes : '<none>'}, includes: ${request.includes && request.includes.length > 0 ? JSON.stringify(request.includes) : '<all>'})`).join(',')}`);\n\t\t}\n\n\t\tif (pathsToStopWatching.length) {\n\t\t\tthis.trace(`Request to stop watching: ${pathsToStopWatching.join(',')}`);\n\t\t}\n\n\t\t// Stop watching as instructed\n\t\tfor (const pathToStopWatching of pathsToStopWatching) {\n\t\t\tawait this.stopWatching(pathToStopWatching);\n\t\t}\n\n\t\t// Start watching as instructed\n\t\tfor (const request of requestsToStartWatching) {\n\t\t\tif (request.pollingInterval) {\n\t\t\t\tthis.startPolling(request, request.pollingInterval);\n\t\t\t} else {\n\t\t\t\tthis.startWatching(request);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected toExcludePaths(path: string, excludes: string[] | undefined): string[] | undefined {\n\t\tif (!Array.isArray(excludes)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst excludePaths = new Set<string>();\n\n\t\t// Parcel watcher currently does not support glob patterns\n\t\t// for native exclusions. As long as that is the case, try\n\t\t// to convert exclude patterns into absolute paths that the\n\t\t// watcher supports natively to reduce the overhead at the\n\t\t// level of the file watcher as much as possible.\n\t\t// Refs: https://github.com/parcel-bundler/watcher/issues/64\n\t\tfor (const exclude of excludes) {\n\t\t\tconst isGlob = exclude.includes(ParcelWatcher.GLOB_MARKERS.Star);\n\n\t\t\t// Glob pattern: check for typical patterns and convert\n\t\t\tlet normalizedExclude: string | undefined = undefined;\n\t\t\tif (isGlob) {\n\n\t\t\t\t// Examples: **, **/**, **\\**\n\t\t\t\tif (\n\t\t\t\t\texclude === ParcelWatcher.GLOB_MARKERS.GlobStar ||\n\t\t\t\t\texclude === ParcelWatcher.GLOB_MARKERS.GlobStarPosix ||\n\t\t\t\t\texclude === ParcelWatcher.GLOB_MARKERS.GlobStarWindows\n\t\t\t\t) {\n\t\t\t\t\tnormalizedExclude = path;\n\t\t\t\t}\n\n\t\t\t\t// Examples:\n\t\t\t\t// - **/node_modules/**\n\t\t\t\t// - **/.git/objects/**\n\t\t\t\t// - **/build-folder\n\t\t\t\t// - output/**\n\t\t\t\telse {\n\t\t\t\t\tconst startsWithGlobStar = exclude.startsWith(ParcelWatcher.GLOB_MARKERS.GlobStarPathStartPosix) || exclude.startsWith(ParcelWatcher.GLOB_MARKERS.GlobStarPathStartWindows);\n\t\t\t\t\tconst endsWithGlobStar = exclude.endsWith(ParcelWatcher.GLOB_MARKERS.GlobStarPathEndPosix) || exclude.endsWith(ParcelWatcher.GLOB_MARKERS.GlobStarPathEndWindows);\n\t\t\t\t\tif (startsWithGlobStar || endsWithGlobStar) {\n\t\t\t\t\t\tif (startsWithGlobStar && endsWithGlobStar) {\n\t\t\t\t\t\t\tnormalizedExclude = exclude.substring(ParcelWatcher.GLOB_MARKERS.GlobStarPathStartPosix.length, exclude.length - ParcelWatcher.GLOB_MARKERS.GlobStarPathEndPosix.length);\n\t\t\t\t\t\t} else if (startsWithGlobStar) {\n\t\t\t\t\t\t\tnormalizedExclude = exclude.substring(ParcelWatcher.GLOB_MARKERS.GlobStarPathStartPosix.length);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnormalizedExclude = exclude.substring(0, exclude.length - ParcelWatcher.GLOB_MARKERS.GlobStarPathEndPosix.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support even more glob patterns on Linux where we know\n\t\t\t\t\t// that each folder requires a file handle to watch.\n\t\t\t\t\t// Examples:\n\t\t\t\t\t// - node_modules/* (full form: **/node_modules/*/**)\n\t\t\t\t\tif (isLinux && normalizedExclude) {\n\t\t\t\t\t\tconst endsWithStar = normalizedExclude?.endsWith(ParcelWatcher.GLOB_MARKERS.StarPathEndPosix);\n\t\t\t\t\t\tif (endsWithStar) {\n\t\t\t\t\t\t\tnormalizedExclude = normalizedExclude.substring(0, normalizedExclude.length - ParcelWatcher.GLOB_MARKERS.StarPathEndPosix.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not a glob pattern, take as is\n\t\t\telse {\n\t\t\t\tnormalizedExclude = exclude;\n\t\t\t}\n\n\t\t\tif (!normalizedExclude || normalizedExclude.includes(ParcelWatcher.GLOB_MARKERS.Star)) {\n\t\t\t\tcontinue; // skip for parcel (will be applied later by our glob matching)\n\t\t\t}\n\n\t\t\t// Absolute path: normalize to watched path and\n\t\t\t// exclude if not a parent of it otherwise.\n\t\t\tif (isAbsolute(normalizedExclude)) {\n\t\t\t\tif (!isEqualOrParent(normalizedExclude, path, !isLinux)) {\n\t\t\t\t\tcontinue; // exclude points to path outside of watched folder, ignore\n\t\t\t\t}\n\n\t\t\t\t// convert to relative path to ensure we\n\t\t\t\t// get the correct path casing going forward\n\t\t\t\tnormalizedExclude = normalizedExclude.substr(path.length);\n\t\t\t}\n\n\t\t\t// Finally take as relative path joined to watched path\n\t\t\texcludePaths.add(rtrim(join(path, normalizedExclude), sep));\n\t\t}\n\n\t\tif (excludePaths.size > 0) {\n\t\t\treturn Array.from(excludePaths);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate startPolling(request: IRecursiveWatchRequest, pollingInterval: number, restarts = 0): void {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<void>();\n\n\t\tconst snapshotFile = randomPath(tmpdir(), 'vscode-watcher-snapshot');\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: IParcelWatcherInstance = {\n\t\t\trequest,\n\t\t\tready: instance.p,\n\t\t\trestarts,\n\t\t\ttoken: cts.token,\n\t\t\tstop: async () => {\n\t\t\t\tcts.dispose(true);\n\t\t\t\tpollingWatcher.dispose();\n\t\t\t\tunlinkSync(snapshotFile);\n\t\t\t}\n\t\t};\n\t\tthis.watchers.set(request.path, watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = this.normalizePath(request);\n\n\t\t// Warm up exclude/include patterns for usage\n\t\tconst excludePatterns = parseWatcherPatterns(request.path, request.excludes);\n\t\tconst includePatterns = request.includes ? parseWatcherPatterns(request.path, request.includes) : undefined;\n\n\t\tconst ignore = this.toExcludePaths(realPath, watcher.request.excludes);\n\n\t\tthis.trace(`Started watching: '${realPath}' with polling interval '${pollingInterval}' and native excludes '${ignore?.join(', ')}'`);\n\n\t\tlet counter = 0;\n\n\t\tconst pollingWatcher = new RunOnceScheduler(async () => {\n\t\t\tcounter++;\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We already ran before, check for events since\n\t\t\tif (counter > 1) {\n\t\t\t\tconst parcelEvents = await parcelWatcher.getEventsSince(realPath, snapshotFile, { ignore, backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\n\t\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Handle & emit events\n\t\t\t\tthis.onParcelEvents(parcelEvents, watcher, excludePatterns, includePatterns, realPathDiffers, realPathLength);\n\t\t\t}\n\n\t\t\t// Store a snapshot of files to the snapshot file\n\t\t\tawait parcelWatcher.writeSnapshot(realPath, snapshotFile, { ignore, backend: ParcelWatcher.PARCEL_WATCHER_BACKEND });\n\n\t\t\t// Signal we are ready now when the first snapshot was written\n\t\t\tif (counter === 1) {\n\t\t\t\tinstance.complete();\n\t\t\t}\n\n\t\t\tif (cts.token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Schedule again at the next interval\n\t\t\tpollingWatcher.schedule();\n\t\t}, pollingInterval);\n\t\tpollingWatcher.schedule(0);\n\t}\n\n\tprivate startWatching(request: IRecursiveWatchRequest, restarts = 0): void {\n\t\tconst cts = new CancellationTokenSource();\n\n\t\tconst instance = new DeferredPromise<parcelWatcher.AsyncSubscription | undefined>();\n\n\t\t// Remember as watcher instance\n\t\tconst watcher: IParcelWatcherInstance = {\n\t\t\trequest,\n\t\t\tready: instance.p,\n\t\t\trestarts,\n\t\t\ttoken: cts.token,\n\t\t\tstop: async () => {\n\t\t\t\tcts.dispose(true);\n\n\t\t\t\tconst watcherInstance = await instance.p;\n\t\t\t\tawait watcherInstance?.unsubscribe();\n\t\t\t}\n\t\t};\n\t\tthis.watchers.set(request.path, watcher);\n\n\t\t// Path checks for symbolic links / wrong casing\n\t\tconst { realPath, realPathDiffers, realPathLength } = this.normalizePath(request);\n\n\t\t// Warm up exclude/include patterns for usage\n\t\tconst excludePatterns = parseWatcherPatterns(request.path, request.excludes);\n\t\tconst includePatterns = request.includes ? parseWatcherPatterns(request.path, request.includes) : undefined;\n\n\t\tconst ignore = this.toExcludePaths(realPath, watcher.request.excludes);\n\t\tparcelWatcher.subscribe(realPath, (error, parcelEvents) => {\n\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\treturn; // return early when disposed\n\t\t\t}\n\n\t\t\t// In any case of an error, treat this like a unhandled exception\n\t\t\t// that might require the watcher to restart. We do not really know\n\t\t\t// the state of parcel at this point and as such will try to restart\n\t\t\t// up to our maximum of restarts.\n\t\t\tif (error) {\n\t\t\t\tthis.onUnexpectedError(error, watcher);\n\t\t\t}\n\n\t\t\t// Handle & emit events\n\t\t\tthis.onParcelEvents(parcelEvents, watcher, excludePatterns, includePatterns, realPathDiffers, realPathLength);\n\t\t}, {\n\t\t\tbackend: ParcelWatcher.PARCEL_WATCHER_BACKEND,\n\t\t\tignore\n\t\t}).then(parcelWatcher => {\n\t\t\tthis.trace(`Started watching: '${realPath}' with backend '${ParcelWatcher.PARCEL_WATCHER_BACKEND}' and native excludes '${ignore?.join(', ')}'`);\n\n\t\t\tinstance.complete(parcelWatcher);\n\t\t}).catch(error => {\n\t\t\tthis.onUnexpectedError(error, watcher);\n\n\t\t\tinstance.complete(undefined);\n\t\t});\n\t}\n\n\tprivate onParcelEvents(parcelEvents: parcelWatcher.Event[], watcher: IParcelWatcherInstance, excludes: ParsedPattern[], includes: ParsedPattern[] | undefined, realPathDiffers: boolean, realPathLength: number): void {\n\t\tif (parcelEvents.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Normalize events: handle NFC normalization and symlinks\n\t\t// It is important to do this before checking for includes\n\t\t// and excludes to check on the original path.\n\t\tconst { events: normalizedEvents, rootDeleted } = this.normalizeEvents(parcelEvents, watcher.request, realPathDiffers, realPathLength);\n\n\t\t// Check for excludes\n\t\tconst includedEvents = this.handleExcludeIncludes(normalizedEvents, excludes, includes);\n\n\t\t// Coalesce events: merge events of same kind\n\t\tconst coalescedEvents = coalesceEvents(includedEvents);\n\n\t\t// Filter events: check for specific events we want to exclude\n\t\tconst filteredEvents = this.filterEvents(coalescedEvents, watcher.request, rootDeleted);\n\n\t\t// Broadcast to clients\n\t\tthis.emitEvents(filteredEvents);\n\n\t\t// Handle root path delete if confirmed from coalesced events\n\t\tif (rootDeleted && coalescedEvents.some(event => event.path === watcher.request.path && event.type === FileChangeType.DELETED)) {\n\t\t\tthis.onWatchedPathDeleted(watcher);\n\t\t}\n\t}\n\n\tprivate handleExcludeIncludes(parcelEvents: parcelWatcher.Event[], excludes: ParsedPattern[], includes: ParsedPattern[] | undefined): IDiskFileChange[] {\n\t\tconst events: IDiskFileChange[] = [];\n\n\t\tfor (const { path, type: parcelEventType } of parcelEvents) {\n\t\t\tconst type = ParcelWatcher.MAP_PARCEL_WATCHER_ACTION_TO_FILE_CHANGE.get(parcelEventType)!;\n\t\t\tif (this.verboseLogging) {\n\t\t\t\tthis.trace(`${type === FileChangeType.ADDED ? '[ADDED]' : type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${path}`);\n\t\t\t}\n\n\t\t\t// Add to buffer unless excluded or not included (not if explicitly disabled)\n\t\t\tif (excludes.some(exclude => exclude(path))) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.trace(` >> ignored (excluded) ${path}`);\n\t\t\t\t}\n\t\t\t} else if (includes && includes.length > 0 && !includes.some(include => include(path))) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tthis.trace(` >> ignored (not included) ${path}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tevents.push({ type, path });\n\t\t\t}\n\t\t}\n\n\t\treturn events;\n\t}\n\n\tprivate emitEvents(events: IDiskFileChange[]): void {\n\t\tif (events.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Logging\n\t\tif (this.verboseLogging) {\n\t\t\tfor (const event of events) {\n\t\t\t\tthis.trace(` >> normalized ${event.type === FileChangeType.ADDED ? '[ADDED]' : event.type === FileChangeType.DELETED ? '[DELETED]' : '[CHANGED]'} ${event.path}`);\n\t\t\t}\n\t\t}\n\n\t\t// Broadcast to clients via throttler\n\t\tconst worked = this.throttledFileChangesWorker.work(events);\n\n\t\t// Logging\n\t\tif (!worked) {\n\t\t\tthis.warn(`started ignoring events due to too many file change events at once (incoming: ${events.length}, most recent change: ${events[0].path}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t} else {\n\t\t\tif (this.throttledFileChangesWorker.pending > 0) {\n\t\t\t\tthis.trace(`started throttling events due to large amount of file change events at once (pending: ${this.throttledFileChangesWorker.pending}, most recent change: ${events[0].path}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate normalizePath(request: IRecursiveWatchRequest): { realPath: string; realPathDiffers: boolean; realPathLength: number } {\n\t\tlet realPath = request.path;\n\t\tlet realPathDiffers = false;\n\t\tlet realPathLength = request.path.length;\n\n\t\ttry {\n\n\t\t\t// First check for symbolic link\n\t\t\trealPath = realpathSync(request.path);\n\n\t\t\t// Second check for casing difference\n\t\t\t// Note: this will be a no-op on Linux platforms\n\t\t\tif (request.path === realPath) {\n\t\t\t\trealPath = realcaseSync(request.path) ?? request.path;\n\t\t\t}\n\n\t\t\t// Correct watch path as needed\n\t\t\tif (request.path !== realPath) {\n\t\t\t\trealPathLength = realPath.length;\n\t\t\t\trealPathDiffers = true;\n\n\t\t\t\tthis.trace(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${request.path}, real: ${realPath})`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// ignore\n\t\t}\n\n\t\treturn { realPath, realPathDiffers, realPathLength };\n\t}\n\n\tprivate normalizeEvents(events: parcelWatcher.Event[], request: IRecursiveWatchRequest, realPathDiffers: boolean, realPathLength: number): { events: parcelWatcher.Event[]; rootDeleted: boolean } {\n\t\tlet rootDeleted = false;\n\n\t\tfor (const event of events) {\n\n\t\t\t// Mac uses NFD unicode form on disk, but we want NFC\n\t\t\tif (isMacintosh) {\n\t\t\t\tevent.path = normalizeNFC(event.path);\n\t\t\t}\n\n\t\t\t// Workaround for https://github.com/parcel-bundler/watcher/issues/68\n\t\t\t// where watching root drive letter adds extra backslashes.\n\t\t\tif (isWindows) {\n\t\t\t\tif (request.path.length <= 3) { // for ex. c:, C:\\\n\t\t\t\t\tevent.path = normalize(event.path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert paths back to original form in case it differs\n\t\t\tif (realPathDiffers) {\n\t\t\t\tevent.path = request.path + event.path.substr(realPathLength);\n\t\t\t}\n\n\t\t\t// Check for root deleted\n\t\t\tif (event.path === request.path && event.type === 'delete') {\n\t\t\t\trootDeleted = true;\n\t\t\t}\n\t\t}\n\n\t\treturn { events, rootDeleted };\n\t}\n\n\tprivate filterEvents(events: IDiskFileChange[], request: IRecursiveWatchRequest, rootDeleted: boolean): IDiskFileChange[] {\n\t\tif (!rootDeleted) {\n\t\t\treturn events;\n\t\t}\n\n\t\treturn events.filter(event => {\n\t\t\tif (event.path === request.path && event.type === FileChangeType.DELETED) {\n\t\t\t\t// Explicitly exclude changes to root if we have any\n\t\t\t\t// to avoid VS Code closing all opened editors which\n\t\t\t\t// can happen e.g. in case of network connectivity\n\t\t\t\t// issues\n\t\t\t\t// (https://github.com/microsoft/vscode/issues/136673)\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tprivate onWatchedPathDeleted(watcher: IParcelWatcherInstance): void {\n\t\tthis.warn('Watcher shutdown because watched path got deleted', watcher);\n\n\t\tconst parentPath = dirname(watcher.request.path);\n\t\tif (existsSync(parentPath)) {\n\t\t\tconst nodeWatcher = new NodeJSFileWatcherLibrary({ path: parentPath, excludes: [], recursive: false }, changes => {\n\t\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\t\treturn; // return early when disposed\n\t\t\t\t}\n\n\t\t\t\t// Watcher path came back! Restart watching...\n\t\t\t\tfor (const { path, type } of changes) {\n\t\t\t\t\tif (path === watcher.request.path && (type === FileChangeType.ADDED || type === FileChangeType.UPDATED)) {\n\t\t\t\t\t\tthis.warn('Watcher restarts because watched path got created again', watcher);\n\n\t\t\t\t\t\t// Stop watching that parent folder\n\t\t\t\t\t\tnodeWatcher.dispose();\n\n\t\t\t\t\t\t// Restart the file watching\n\t\t\t\t\t\tthis.restartWatching(watcher);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, msg => this._onDidLogMessage.fire(msg), this.verboseLogging);\n\n\t\t\t// Make sure to stop watching when the watcher is disposed\n\t\t\twatcher.token.onCancellationRequested(() => nodeWatcher.dispose());\n\t\t}\n\t}\n\n\tprivate onUnexpectedError(error: unknown, watcher?: IParcelWatcherInstance): void {\n\t\tconst msg = toErrorMessage(error);\n\n\t\t// Specially handle ENOSPC errors that can happen when\n\t\t// the watcher consumes so many file descriptors that\n\t\t// we are running into a limit. We only want to warn\n\t\t// once in this case to avoid log spam.\n\t\t// See https://github.com/microsoft/vscode/issues/7950\n\t\tif (msg.indexOf('No space left on device') !== -1) {\n\t\t\tif (!this.enospcErrorLogged) {\n\t\t\t\tthis.error('Inotify limit reached (ENOSPC)', watcher);\n\n\t\t\t\tthis.enospcErrorLogged = true;\n\t\t\t}\n\t\t}\n\n\t\t// Any other error is unexpected and we should try to\n\t\t// restart the watcher as a result to get into healthy\n\t\t// state again if possible and if not attempted too much\n\t\telse {\n\t\t\tthis.error(`Unexpected error: ${msg} (EUNKNOWN)`, watcher);\n\n\t\t\tthis._onDidError.fire(msg);\n\t\t}\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tfor (const [path] of this.watchers) {\n\t\t\tawait this.stopWatching(path);\n\t\t}\n\n\t\tthis.watchers.clear();\n\t}\n\n\tprotected restartWatching(watcher: IParcelWatcherInstance, delay = 800): void {\n\n\t\t// Restart watcher delayed to accomodate for\n\t\t// changes on disk that have triggered the\n\t\t// need for a restart in the first place.\n\t\tconst scheduler = new RunOnceScheduler(async () => {\n\t\t\tif (watcher.token.isCancellationRequested) {\n\t\t\t\treturn; // return early when disposed\n\t\t\t}\n\n\t\t\t// Await the watcher having stopped, as this is\n\t\t\t// needed to properly re-watch the same path\n\t\t\tawait this.stopWatching(watcher.request.path);\n\n\t\t\t// Start watcher again counting the restarts\n\t\t\tif (watcher.request.pollingInterval) {\n\t\t\t\tthis.startPolling(watcher.request, watcher.request.pollingInterval, watcher.restarts + 1);\n\t\t\t} else {\n\t\t\t\tthis.startWatching(watcher.request, watcher.restarts + 1);\n\t\t\t}\n\t\t}, delay);\n\n\t\tscheduler.schedule();\n\t\twatcher.token.onCancellationRequested(() => scheduler.dispose());\n\t}\n\n\tprivate async stopWatching(path: string): Promise<void> {\n\t\tconst watcher = this.watchers.get(path);\n\t\tif (watcher) {\n\t\t\tthis.trace(`stopping file watcher on ${watcher.request.path}`);\n\n\t\t\tthis.watchers.delete(path);\n\n\t\t\ttry {\n\t\t\t\tawait watcher.stop();\n\t\t\t} catch (error) {\n\t\t\t\tthis.error(`Unexpected error stopping watcher: ${toErrorMessage(error)}`, watcher);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected normalizeRequests(requests: IRecursiveWatchRequest[], validatePaths = true): IRecursiveWatchRequest[] {\n\t\tconst requestTrie = TernarySearchTree.forPaths<IRecursiveWatchRequest>(!isLinux);\n\n\t\t// Sort requests by path length to have shortest first\n\t\t// to have a way to prevent children to be watched if\n\t\t// parents exist.\n\t\trequests.sort((requestA, requestB) => requestA.path.length - requestB.path.length);\n\n\t\t// Only consider requests for watching that are not\n\t\t// a child of an existing request path to prevent\n\t\t// duplication. In addition, drop any request where\n\t\t// everything is excluded (via `**` glob).\n\t\t//\n\t\t// However, allow explicit requests to watch folders\n\t\t// that are symbolic links because the Parcel watcher\n\t\t// does not allow to recursively watch symbolic links.\n\t\tfor (const request of requests) {\n\t\t\tif (request.excludes.includes(GLOBSTAR)) {\n\t\t\t\tcontinue; // path is ignored entirely (via `**` glob exclude)\n\t\t\t}\n\n\t\t\t// Check for overlapping requests\n\t\t\tif (requestTrie.findSubstr(request.path)) {\n\t\t\t\ttry {\n\t\t\t\t\tconst realpath = realpathSync(request.path);\n\t\t\t\t\tif (realpath === request.path) {\n\t\t\t\t\t\tthis.trace(`ignoring a path for watching who's parent is already watched: ${request.path}`);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.trace(`ignoring a path for watching who's realpath failed to resolve: ${request.path} (error: ${error})`);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for invalid paths\n\t\t\tif (validatePaths) {\n\t\t\t\ttry {\n\t\t\t\t\tconst stat = statSync(request.path);\n\t\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\t\tthis.trace(`ignoring a path for watching that is a file and not a folder: ${request.path}`);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.trace(`ignoring a path for watching who's stat info failed to resolve: ${request.path} (error: ${error})`);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequestTrie.set(request.path, request);\n\t\t}\n\n\t\treturn Array.from(requestTrie).map(([, request]) => request);\n\t}\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tthis.verboseLogging = enabled;\n\t}\n\n\tprivate trace(message: string) {\n\t\tif (this.verboseLogging) {\n\t\t\tthis._onDidLogMessage.fire({ type: 'trace', message: this.toMessage(message) });\n\t\t}\n\t}\n\n\tprivate warn(message: string, watcher?: IParcelWatcherInstance) {\n\t\tthis._onDidLogMessage.fire({ type: 'warn', message: this.toMessage(message, watcher) });\n\t}\n\n\tprivate error(message: string, watcher: IParcelWatcherInstance | undefined) {\n\t\tthis._onDidLogMessage.fire({ type: 'error', message: this.toMessage(message, watcher) });\n\t}\n\n\tprivate toMessage(message: string, watcher?: IParcelWatcherInstance): string {\n\t\treturn watcher ? `[File Watcher (parcel)] ${message} (path: ${watcher.request.path})` : `[File Watcher (parcel)] ${message}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { INonRecursiveWatchRequest, IRecursiveWatchRequest, IUniversalWatcher, IUniversalWatchRequest } from 'vs/platform/files/common/watcher';\nimport { Event } from 'vs/base/common/event';\nimport { ParcelWatcher } from 'vs/platform/files/node/watcher/parcel/parcelWatcher';\nimport { NodeJSWatcher } from 'vs/platform/files/node/watcher/nodejs/nodejsWatcher';\nimport { Promises } from 'vs/base/common/async';\n\nexport class UniversalWatcher extends Disposable implements IUniversalWatcher {\n\n\tprivate readonly recursiveWatcher = this._register(new ParcelWatcher());\n\tprivate readonly nonRecursiveWatcher = this._register(new NodeJSWatcher());\n\n\treadonly onDidChangeFile = Event.any(this.recursiveWatcher.onDidChangeFile, this.nonRecursiveWatcher.onDidChangeFile);\n\treadonly onDidLogMessage = Event.any(this.recursiveWatcher.onDidLogMessage, this.nonRecursiveWatcher.onDidLogMessage);\n\treadonly onDidError = Event.any(this.recursiveWatcher.onDidError, this.nonRecursiveWatcher.onDidError);\n\n\tasync watch(requests: IUniversalWatchRequest[]): Promise<void> {\n\t\tconst recursiveWatchRequests: IRecursiveWatchRequest[] = [];\n\t\tconst nonRecursiveWatchRequests: INonRecursiveWatchRequest[] = [];\n\n\t\tfor (const request of requests) {\n\t\t\tif (request.recursive) {\n\t\t\t\trecursiveWatchRequests.push(request);\n\t\t\t} else {\n\t\t\t\tnonRecursiveWatchRequests.push(request);\n\t\t\t}\n\t\t}\n\n\t\tawait Promises.settled([\n\t\t\tthis.recursiveWatcher.watch(recursiveWatchRequests),\n\t\t\tthis.nonRecursiveWatcher.watch(nonRecursiveWatchRequests)\n\t\t]);\n\t}\n\n\tasync setVerboseLogging(enabled: boolean): Promise<void> {\n\t\tawait Promises.settled([\n\t\t\tthis.recursiveWatcher.setVerboseLogging(enabled),\n\t\t\tthis.nonRecursiveWatcher.setVerboseLogging(enabled)\n\t\t]);\n\t}\n\n\tasync stop(): Promise<void> {\n\t\tawait Promises.settled([\n\t\t\tthis.recursiveWatcher.stop(),\n\t\t\tthis.nonRecursiveWatcher.stop()\n\t\t]);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ProxyChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { Server } from 'vs/base/parts/ipc/node/ipc.cp';\nimport { UniversalWatcher } from 'vs/platform/files/node/watcher/watcher';\n\nconst server = new Server('watcher');\nconst service = new UniversalWatcher();\nserver.registerChannel('watcher', ProxyChannel.fromService(service));\n"],"mappings":"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","names":[],"file":"watcherMain.js"}