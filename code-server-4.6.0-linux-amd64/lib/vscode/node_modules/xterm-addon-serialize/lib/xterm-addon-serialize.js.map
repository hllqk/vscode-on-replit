{"version":3,"file":"xterm-addon-serialize.js","mappings":"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","sources":["webpack://SerializeAddon/webpack/universalModuleDefinition","webpack://SerializeAddon/webpack/startup","webpack://SerializeAddon/./src/SerializeAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SerializeAddon\"] = factory();\n\telse\n\t\troot[\"SerializeAddon\"] = factory();\n})(this, function() {\nreturn ","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[44](0, __webpack_exports__);\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * (EXPERIMENTAL) This Addon is still under development\n */\n\nimport { Terminal, ITerminalAddon, IBuffer, IBufferCell, IBufferRange } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IAttributeData } from 'common/Types';\n\nfunction constrain(value: number, low: number, high: number): number {\n  return Math.max(low, Math.min(value, high));\n}\n\n// TODO: Refine this template class later\nabstract class BaseSerializeHandler {\n  constructor(\n    protected readonly _buffer: IBuffer\n  ) {\n  }\n\n  public serialize(range: IBufferRange): string {\n    // we need two of them to flip between old and new cell\n    const cell1 = this._buffer.getNullCell();\n    const cell2 = this._buffer.getNullCell();\n    let oldCell = cell1;\n\n    const startRow = range.start.x;\n    const endRow = range.end.x;\n    const startColumn = range.start.y;\n    const endColumn = range.end.y;\n\n    this._beforeSerialize(endRow - startRow, startRow, endRow);\n\n    for (let row = startRow; row <= endRow; row++) {\n      const line = this._buffer.getLine(row);\n      if (line) {\n        const startLineColumn = row !== range.start.x ? 0 : startColumn;\n        const endLineColumn = row !== range.end.x ? line.length : endColumn;\n        for (let col = startLineColumn; col < endLineColumn; col++) {\n          const c = line.getCell(col, oldCell === cell1 ? cell2 : cell1);\n          if (!c) {\n            console.warn(`Can't get cell at row=${row}, col=${col}`);\n            continue;\n          }\n          this._nextCell(c, oldCell, row, col);\n          oldCell = c;\n        }\n      }\n      this._rowEnd(row, row === endRow);\n    }\n\n    this._afterSerialize();\n\n    return this._serializeString();\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void { }\n  protected _rowEnd(row: number, isLastRow: boolean): void { }\n  protected _beforeSerialize(rows: number, startRow: number, endRow: number): void { }\n  protected _afterSerialize(): void { }\n  protected _serializeString(): string { return ''; }\n}\n\nfunction equalFg(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.getFgColorMode() === cell2.getFgColorMode()\n    && cell1.getFgColor() === cell2.getFgColor();\n}\n\nfunction equalBg(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.getBgColorMode() === cell2.getBgColorMode()\n    && cell1.getBgColor() === cell2.getBgColor();\n}\n\nfunction equalFlags(cell1: IBufferCell | IAttributeData, cell2: IBufferCell): boolean {\n  return cell1.isInverse() === cell2.isInverse()\n    && cell1.isBold() === cell2.isBold()\n    && cell1.isUnderline() === cell2.isUnderline()\n    && cell1.isBlink() === cell2.isBlink()\n    && cell1.isInvisible() === cell2.isInvisible()\n    && cell1.isItalic() === cell2.isItalic()\n    && cell1.isDim() === cell2.isDim()\n    && cell1.isStrikethrough() === cell2.isStrikethrough();\n}\n\nclass StringSerializeHandler extends BaseSerializeHandler {\n  private _rowIndex: number = 0;\n  private _allRows: string[] = new Array<string>();\n  private _allRowSeparators: string[] = new Array<string>();\n  private _currentRow: string = '';\n  private _nullCellCount: number = 0;\n\n  // we can see a full colored cell and a null cell that only have background the same style\n  // but the information isn't preserved by null cell itself\n  // so wee need to record it when required.\n  private _cursorStyle: IBufferCell = this._buffer.getNullCell();\n\n  // where exact the cursor styles comes from\n  // because we can't copy the cell directly\n  // so we remember where the content comes from instead\n  private _cursorStyleRow: number = 0;\n  private _cursorStyleCol: number = 0;\n\n  // this is a null cell for reference for checking whether background is empty or not\n  private _backgroundCell: IBufferCell = this._buffer.getNullCell();\n\n  private _firstRow: number = 0;\n  private _lastCursorRow: number = 0;\n  private _lastCursorCol: number = 0;\n  private _lastContentCursorRow: number = 0;\n  private _lastContentCursorCol: number = 0;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal\n  ) {\n    super(buffer);\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._allRows = new Array<string>(rows);\n    this._lastContentCursorRow = start;\n    this._lastCursorRow = start;\n    this._firstRow = start;\n  }\n\n  private _thisRowLastChar: IBufferCell = this._buffer.getNullCell();\n  private _thisRowLastSecondChar: IBufferCell = this._buffer.getNullCell();\n  private _nextRowFirstChar: IBufferCell = this._buffer.getNullCell();\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    // if there is colorful empty cell at line end, whe must pad it back, or the the color block will missing\n    if (this._nullCellCount > 0 && !equalBg(this._cursorStyle, this._backgroundCell)) {\n      // use clear right to set background.\n      this._currentRow += `\\u001b[${this._nullCellCount}X`;\n    }\n\n    let rowSeparator = '';\n\n    // handle row separator\n    if (!isLastRow) {\n      // Enable BCE\n      if (row - this._firstRow >= this._terminal.rows) {\n        this._buffer.getLine(this._cursorStyleRow)?.getCell(this._cursorStyleCol, this._backgroundCell);\n      }\n\n      // Fetch current line\n      const currentLine = this._buffer.getLine(row)!;\n      // Fetch next line\n      const nextLine = this._buffer.getLine(row + 1)!;\n\n      if (!nextLine.isWrapped) {\n        // just insert the line break\n        rowSeparator = '\\r\\n';\n        // we sended the enter\n        this._lastCursorRow = row + 1;\n        this._lastCursorCol = 0;\n      } else {\n        rowSeparator = '';\n        const thisRowLastChar = currentLine.getCell(currentLine.length - 1, this._thisRowLastChar)!;\n        const thisRowLastSecondChar = currentLine.getCell(currentLine.length - 2, this._thisRowLastSecondChar)!;\n        const nextRowFirstChar = nextLine.getCell(0, this._nextRowFirstChar)!;\n        const isNextRowFirstCharDoubleWidth = nextRowFirstChar.getWidth() > 1;\n\n        // validate whether this line wrap is ever possible\n        // which mean whether cursor can placed at a overflow position (x === row) naturally\n        let isValid = false;\n\n        if (\n          // you must output character to cause overflow, control sequence can't do this\n          nextRowFirstChar.getChars() &&\n            isNextRowFirstCharDoubleWidth ? this._nullCellCount <= 1 : this._nullCellCount <= 0\n        ) {\n          if (\n            // the last character can't be null,\n            // you can't use control sequence to move cursor to (x === row)\n            (thisRowLastChar.getChars() || thisRowLastChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n\n          if (\n            // the second to last character can't be null if the next line starts with CJK,\n            // you can't use control sequence to move cursor to (x === row)\n            isNextRowFirstCharDoubleWidth &&\n            (thisRowLastSecondChar.getChars() || thisRowLastSecondChar.getWidth() === 0) &&\n            // change background of the first wrapped cell also affects BCE\n            // so we mark it as invalid to simply the process to determine line separator\n            equalBg(thisRowLastChar, nextRowFirstChar) &&\n            equalBg(thisRowLastSecondChar, nextRowFirstChar)\n          ) {\n            isValid = true;\n          }\n        }\n\n        if (!isValid) {\n          // force the wrap with magic\n          // insert enough character to force the wrap\n          rowSeparator = '-'.repeat(this._nullCellCount + 1);\n          // move back and erase next line head\n          rowSeparator += '\\u001b[1D\\u001b[1X';\n\n          if (this._nullCellCount > 0) {\n            // do these because we filled the last several null slot, which we shouldn't\n            rowSeparator += '\\u001b[A';\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}C`;\n            rowSeparator += `\\u001b[${this._nullCellCount}X`;\n            rowSeparator += `\\u001b[${currentLine.length - this._nullCellCount}D`;\n            rowSeparator += '\\u001b[B';\n          }\n\n          // This is content and need the be serialized even it is invisible.\n          // without this, wrap will be missing from outputs.\n          this._lastContentCursorRow = row + 1;\n          this._lastContentCursorCol = 0;\n\n          // force commit the cursor position\n          this._lastCursorRow = row + 1;\n          this._lastCursorCol = 0;\n        }\n      }\n    }\n\n    this._allRows[this._rowIndex] = this._currentRow;\n    this._allRowSeparators[this._rowIndex++] = rowSeparator;\n    this._currentRow = '';\n    this._nullCellCount = 0;\n  }\n\n  private _diffStyle(cell: IBufferCell | IAttributeData, oldCell: IBufferCell): number[] {\n    const sgrSeq: number[] = [];\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      if (cell.isAttributeDefault()) {\n        if (!oldCell.isAttributeDefault()) {\n          sgrSeq.push(0);\n        }\n      } else {\n        if (fgChanged) {\n          const color = cell.getFgColor();\n          if (cell.isFgRGB()) { sgrSeq.push(38, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isFgPalette()) {\n            if (color >= 16) { sgrSeq.push(38, 5, color); }\n            else { sgrSeq.push(color & 8 ? 90 + (color & 7) : 30 + (color & 7)); }\n          }\n          else { sgrSeq.push(39); }\n        }\n        if (bgChanged) {\n          const color = cell.getBgColor();\n          if (cell.isBgRGB()) { sgrSeq.push(48, 2, (color >>> 16) & 0xFF, (color >>> 8) & 0xFF, color & 0xFF); }\n          else if (cell.isBgPalette()) {\n            if (color >= 16) { sgrSeq.push(48, 5, color); }\n            else { sgrSeq.push(color & 8 ? 100 + (color & 7) : 40 + (color & 7)); }\n          }\n          else { sgrSeq.push(49); }\n        }\n        if (flagsChanged) {\n          if (cell.isInverse() !== oldCell.isInverse()) { sgrSeq.push(cell.isInverse() ? 7 : 27); }\n          if (cell.isBold() !== oldCell.isBold()) { sgrSeq.push(cell.isBold() ? 1 : 22); }\n          if (cell.isUnderline() !== oldCell.isUnderline()) { sgrSeq.push(cell.isUnderline() ? 4 : 24); }\n          if (cell.isBlink() !== oldCell.isBlink()) { sgrSeq.push(cell.isBlink() ? 5 : 25); }\n          if (cell.isInvisible() !== oldCell.isInvisible()) { sgrSeq.push(cell.isInvisible() ? 8 : 28); }\n          if (cell.isItalic() !== oldCell.isItalic()) { sgrSeq.push(cell.isItalic() ? 3 : 23); }\n          if (cell.isDim() !== oldCell.isDim()) { sgrSeq.push(cell.isDim() ? 2 : 22); }\n          if (cell.isStrikethrough() !== oldCell.isStrikethrough()) { sgrSeq.push(cell.isStrikethrough() ? 9 : 29); }\n        }\n      }\n    }\n\n    return sgrSeq;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const sgrSeq = this._diffStyle(cell, this._cursorStyle);\n\n    // the empty cell style is only assumed to be changed when background changed, because foreground is always 0.\n    const styleChanged = isEmptyCell ? !equalBg(this._cursorStyle, cell) : sgrSeq.length > 0;\n\n    /**\n     *  handles style change\n     */\n    if (styleChanged) {\n      // before update the style, we need to fill empty cell back\n      if (this._nullCellCount > 0) {\n        // use clear right to set background.\n        if (!equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n        }\n        // use move right to move cursor.\n        this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        this._nullCellCount = 0;\n      }\n\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col;\n\n      this._currentRow += `\\u001b[${sgrSeq.join(';')}m`;\n\n      // update the last cursor style\n      const line = this._buffer.getLine(row);\n      if (line !== undefined) {\n        line.getCell(col, this._cursorStyle);\n        this._cursorStyleRow = row;\n        this._cursorStyleCol = col;\n      }\n    }\n\n    /**\n     *  handles actual content\n     */\n    if (isEmptyCell) {\n      this._nullCellCount += cell.getWidth();\n    } else {\n      if (this._nullCellCount > 0) {\n        // we can just assume we have same style with previous one here\n        // because style change is handled by previous stage\n        // use move right when background is empty, use clear right when there is background.\n        if (equalBg(this._cursorStyle, this._backgroundCell)) {\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        } else {\n          this._currentRow += `\\u001b[${this._nullCellCount}X`;\n          this._currentRow += `\\u001b[${this._nullCellCount}C`;\n        }\n        this._nullCellCount = 0;\n      }\n\n      this._currentRow += cell.getChars();\n\n      // update cursor\n      this._lastContentCursorRow = this._lastCursorRow = row;\n      this._lastContentCursorCol = this._lastCursorCol = col + cell.getWidth();\n    }\n  }\n\n  protected _serializeString(): string {\n    let rowEnd = this._allRows.length;\n\n    // the fixup is only required for data without scrollback\n    // because it will always be placed at last line otherwise\n    if (this._buffer.length - this._firstRow <= this._terminal.rows) {\n      rowEnd = this._lastContentCursorRow + 1 - this._firstRow;\n      this._lastCursorCol = this._lastContentCursorCol;\n      this._lastCursorRow = this._lastContentCursorRow;\n    }\n\n    let content = '';\n\n    for (let i = 0; i < rowEnd; i++) {\n      content += this._allRows[i];\n      if (i + 1 < rowEnd) {\n        content += this._allRowSeparators[i];\n      }\n    }\n\n    // restore the cursor\n    const realCursorRow = this._buffer.baseY + this._buffer.cursorY;\n    const realCursorCol = this._buffer.cursorX;\n\n    const cursorMoved = (realCursorRow !== this._lastCursorRow || realCursorCol !== this._lastCursorCol);\n\n    const moveRight = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}C`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}D`;\n      }\n    };\n    const moveDown = (offset: number): void => {\n      if (offset > 0) {\n        content += `\\u001b[${offset}B`;\n      } else if (offset < 0) {\n        content += `\\u001b[${-offset}A`;\n      }\n    };\n\n    if (cursorMoved) {\n      moveDown(realCursorRow - this._lastCursorRow);\n      moveRight(realCursorCol - this._lastCursorCol);\n    }\n\n    // Restore the cursor's current style, see https://github.com/xtermjs/xterm.js/issues/3677\n    // HACK: Internal API access since it's awkward to expose this in the API and serialize will\n    // likely be the only consumer\n    const curAttrData: IAttributeData = (this._terminal as any)._core._inputHandler._curAttrData;\n    const sgrSeq = this._diffStyle(curAttrData, this._cursorStyle);\n    if (sgrSeq.length > 0) {\n      content += `\\u001b[${sgrSeq.join(';')}m`;\n    }\n\n    return content;\n  }\n}\n\nexport class SerializeAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n\n  constructor() { }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n  }\n\n  private _serializeBuffer(terminal: Terminal, buffer: IBuffer, scrollback?: number): string {\n    const maxRows = buffer.length;\n    const handler = new StringSerializeHandler(buffer, terminal);\n    const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n    return handler.serialize({\n      start: { x: maxRows - correctRows, y: 0 },\n      end: { x: maxRows - 1, y: terminal.cols }\n    });\n  }\n\n  private _serializeBufferAsHTML(terminal: Terminal, options: Partial<IHTMLSerializeOptions>): string {\n    const buffer = terminal.buffer.active;\n    const handler = new HTMLSerializeHandler(buffer, terminal, options);\n    const onlySelection = options.onlySelection ?? false;\n    if (!onlySelection) {\n      const maxRows = buffer.length;\n      const scrollback = options.scrollback;\n      const correctRows = (scrollback === undefined) ? maxRows : constrain(scrollback + terminal.rows, 0, maxRows);\n      return handler.serialize({\n        start: { x: maxRows - correctRows, y: 0 },\n        end: { x: maxRows - 1, y: terminal.cols }\n      });\n    }\n\n    const selection = this._terminal?.getSelectionPosition();\n    if (selection !== undefined) {\n      return handler.serialize({\n        start: { x: selection.startRow, y: selection.startColumn },\n        end: { x: selection.endRow, y: selection.endColumn }\n      });\n    }\n\n    return '';\n  }\n\n  private _serializeModes(terminal: Terminal): string {\n    let content = '';\n    const modes = terminal.modes;\n\n    // Default: false\n    if (modes.applicationCursorKeysMode) content += '\\x1b[?1h';\n    if (modes.applicationKeypadMode) content += '\\x1b[?66h';\n    if (modes.bracketedPasteMode) content += '\\x1b[?2004h';\n    if (modes.insertMode) content += '\\x1b[4h';\n    if (modes.originMode) content += '\\x1b[?6h';\n    if (modes.reverseWraparoundMode) content += '\\x1b[?45h';\n    if (modes.sendFocusMode) content += '\\x1b[?1004h';\n\n    // Default: true\n    if (modes.wraparoundMode === false) content += '\\x1b[?7l';\n\n    // Default: 'none'\n    if (modes.mouseTrackingMode !== 'none') {\n      switch (modes.mouseTrackingMode) {\n        case 'x10': content += '\\x1b[?9h'; break;\n        case 'vt200': content += '\\x1b[?1000h'; break;\n        case 'drag': content += '\\x1b[?1002h'; break;\n        case 'any': content += '\\x1b[?1003h'; break;\n      }\n    }\n\n    return content;\n  }\n\n  public serialize(options?: ISerializeOptions): string {\n    // TODO: Add combinedData support\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    // Normal buffer\n    let content = this._serializeBuffer(this._terminal, this._terminal.buffer.normal, options?.scrollback);\n\n    // Alternate buffer\n    if (!options?.excludeAltBuffer) {\n      if (this._terminal.buffer.active.type === 'alternate') {\n        const alternativeScreenContent = this._serializeBuffer(this._terminal, this._terminal.buffer.alternate, undefined);\n        content += `\\u001b[?1049h\\u001b[H${alternativeScreenContent}`;\n      }\n    }\n\n    // Modes\n    if (!options?.excludeModes) {\n      content += this._serializeModes(this._terminal);\n    }\n\n    return content;\n  }\n\n  public serializeAsHTML(options?: Partial<IHTMLSerializeOptions>): string {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    return this._serializeBufferAsHTML(this._terminal, options || {});\n  }\n\n  public dispose(): void { }\n}\n\n\ninterface ISerializeOptions {\n  scrollback?: number;\n  excludeModes?: boolean;\n  excludeAltBuffer?: boolean;\n}\n\ninterface IHTMLSerializeOptions {\n  scrollback: number;\n  onlySelection: boolean;\n  includeGlobalBackground: boolean;\n}\n\nexport class HTMLSerializeHandler extends BaseSerializeHandler {\n  private _currentRow: string = '';\n\n  private _htmlContent = '';\n\n  private _colors: IColorSet;\n\n  constructor(\n    buffer: IBuffer,\n    private readonly _terminal: Terminal,\n    private readonly _options: Partial<IHTMLSerializeOptions>\n  ) {\n    super(buffer);\n\n    // https://github.com/xtermjs/xterm.js/issues/3601\n    this._colors = (_terminal as any)._core._colorManager.colors;\n  }\n\n  private _padStart(target: string, targetLength: number, padString: string): string {\n    targetLength = targetLength >> 0;\n    padString = padString ?? ' ';\n    if (target.length > targetLength) {\n      return target;\n    }\n\n    targetLength -= target.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + target;\n  }\n\n  protected _beforeSerialize(rows: number, start: number, end: number): void {\n    this._htmlContent += '<html><body><!--StartFragment--><pre>';\n\n    let foreground = '#000000';\n    let background = '#ffffff';\n    if (this._options.includeGlobalBackground ?? false) {\n      foreground = this._terminal.options.theme?.foreground ?? '#ffffff';\n      background = this._terminal.options.theme?.background ?? '#000000';\n    }\n\n    const globalStyleDefinitions = [];\n    globalStyleDefinitions.push('color: ' + foreground + ';');\n    globalStyleDefinitions.push('background-color: ' + background + ';');\n    globalStyleDefinitions.push('font-family: ' + this._terminal.options.fontFamily + ';');\n    globalStyleDefinitions.push('font-size: ' + this._terminal.options.fontSize + 'px;');\n    this._htmlContent += '<div style=\\'' + globalStyleDefinitions.join(' ') + '\\'>';\n  }\n\n  protected _afterSerialize(): void {\n    this._htmlContent += '</div>';\n    this._htmlContent += '</pre><!--EndFragment--></body></html>';\n  }\n\n  protected _rowEnd(row: number, isLastRow: boolean): void {\n    this._htmlContent += '<div><span>' + this._currentRow + '</span></div>';\n    this._currentRow = '';\n  }\n\n  private _getHexColor(cell: IBufferCell, isFg: boolean): string | undefined {\n    const color = isFg ? cell.getFgColor() : cell.getBgColor();\n    if (isFg ? cell.isFgRGB() : cell.isBgRGB()) {\n      const rgb = [\n        (color >> 16) & 255,\n        (color >>  8) & 255,\n        (color      ) & 255\n      ];\n      return rgb.map(x => this._padStart(x.toString(16), 2, '0')).join('');\n    }\n    if (isFg ? cell.isFgPalette() : cell.isBgPalette()) {\n      return this._colors.ansi[color].css;\n    }\n    return undefined;\n  }\n\n  private _diffStyle(cell: IBufferCell, oldCell: IBufferCell): string[] | undefined {\n    const content: string[] = [];\n\n    const fgChanged = !equalFg(cell, oldCell);\n    const bgChanged = !equalBg(cell, oldCell);\n    const flagsChanged = !equalFlags(cell, oldCell);\n\n    if (fgChanged || bgChanged || flagsChanged) {\n      const fgHexColor = this._getHexColor(cell, true);\n      if (fgHexColor) {\n        content.push('color: ' + fgHexColor + ';');\n      }\n\n      const bgHexColor = this._getHexColor(cell, false);\n      if (bgHexColor) {\n        content.push('background-color: ' + bgHexColor + ';');\n      }\n\n      if (cell.isInverse()) { content.push('color: #000000; background-color: #BFBFBF;'); }\n      if (cell.isBold()) { content.push('font-weight: bold;'); }\n      if (cell.isUnderline()) { content.push('text-decoration: underline;'); }\n      if (cell.isBlink()) { content.push('text-decoration: blink;'); }\n      if (cell.isInvisible()) { content.push('visibility: hidden;'); }\n      if (cell.isItalic()) { content.push('font-style: italic;'); }\n      if (cell.isDim()) { content.push('opacity: 0.5;'); }\n      if (cell.isStrikethrough()) { content.push('text-decoration: line-through;'); }\n\n      return content;\n    }\n\n    return undefined;\n  }\n\n  protected _nextCell(cell: IBufferCell, oldCell: IBufferCell, row: number, col: number): void {\n    // a width 0 cell don't need to be count because it is just a placeholder after a CJK character;\n    const isPlaceHolderCell = cell.getWidth() === 0;\n    if (isPlaceHolderCell) {\n      return;\n    }\n\n    // this cell don't have content\n    const isEmptyCell = cell.getChars() === '';\n\n    const styleDefinitions = this._diffStyle(cell, oldCell);\n\n    // handles style change\n    if (styleDefinitions) {\n      this._currentRow += styleDefinitions.length === 0 ?\n        '</span><span>' :\n        '</span><span style=\\'' + styleDefinitions.join(' ') + '\\'>';\n    }\n\n    // handles actual content\n    if (isEmptyCell) {\n      this._currentRow += ' ';\n    } else {\n      this._currentRow += cell.getChars();\n    }\n  }\n\n  protected _serializeString(): string {\n    return this._htmlContent;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_exports__","constrain","value","low","high","Math","max","min","_buffer","serialize","range","cell1","getNullCell","cell2","oldCell","startRow","start","x","endRow","end","startColumn","y","endColumn","_beforeSerialize","row","line","getLine","startLineColumn","endLineColumn","length","col","c","getCell","_nextCell","console","warn","_rowEnd","_afterSerialize","_serializeString","cell","isLastRow","rows","equalFg","getFgColorMode","getFgColor","equalBg","getBgColorMode","getBgColor","equalFlags","isInverse","isBold","isUnderline","isBlink","isInvisible","isItalic","isDim","isStrikethrough","buffer","_terminal","_rowIndex","_allRows","Array","_allRowSeparators","_currentRow","_nullCellCount","_cursorStyle","_cursorStyleRow","_cursorStyleCol","_backgroundCell","_firstRow","_lastCursorRow","_lastCursorCol","_lastContentCursorRow","_lastContentCursorCol","_this","_thisRowLastChar","_thisRowLastSecondChar","_nextRowFirstChar","rowSeparator","currentLine","nextLine","isWrapped","thisRowLastChar","thisRowLastSecondChar","nextRowFirstChar","isNextRowFirstCharDoubleWidth","getWidth","isValid","getChars","repeat","_diffStyle","sgrSeq","fgChanged","bgChanged","flagsChanged","isAttributeDefault","push","color","isFgRGB","isFgPalette","isBgRGB","isBgPalette","isEmptyCell","join","undefined","rowEnd","content","i","offset","realCursorRow","baseY","cursorY","realCursorCol","cursorX","moveRight","curAttrData","_core","_inputHandler","_curAttrData","BaseSerializeHandler","activate","terminal","_serializeBuffer","scrollback","maxRows","handler","StringSerializeHandler","correctRows","cols","_serializeBufferAsHTML","options","active","HTMLSerializeHandler","onlySelection","selection","getSelectionPosition","_serializeModes","modes","applicationCursorKeysMode","applicationKeypadMode","bracketedPasteMode","insertMode","originMode","reverseWraparoundMode","sendFocusMode","wraparoundMode","mouseTrackingMode","Error","normal","excludeAltBuffer","type","alternate","excludeModes","serializeAsHTML","dispose","SerializeAddon","_options","_htmlContent","_colors","_colorManager","colors","_padStart","target","targetLength","padString","slice","foreground","background","includeGlobalBackground","theme","globalStyleDefinitions","fontFamily","fontSize","_getHexColor","isFg","map","toString","ansi","css","fgHexColor","bgHexColor","styleDefinitions"],"sourceRoot":""}